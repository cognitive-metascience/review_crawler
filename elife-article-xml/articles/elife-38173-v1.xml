<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.1 20151215//EN"  "JATS-archivearticle1.dtd"><article article-type="research-article" dtd-version="1.1" xmlns:ali="http://www.niso.org/schemas/ali/1.0/" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink"><front><journal-meta><journal-id journal-id-type="nlm-ta">elife</journal-id><journal-id journal-id-type="publisher-id">eLife</journal-id><journal-title-group><journal-title>eLife</journal-title></journal-title-group><issn pub-type="epub" publication-format="electronic">2050-084X</issn><publisher><publisher-name>eLife Sciences Publications, Ltd</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="publisher-id">38173</article-id><article-id pub-id-type="doi">10.7554/eLife.38173</article-id><article-categories><subj-group subj-group-type="display-channel"><subject>Tools and Resources</subject></subj-group><subj-group subj-group-type="heading"><subject>Neuroscience</subject></subj-group></article-categories><title-group><article-title>CaImAn an open source tool for scalable calcium imaging data analysis</article-title></title-group><contrib-group><contrib contrib-type="author" corresp="yes" id="author-15272"><name><surname>Giovannucci</surname><given-names>Andrea</given-names></name><contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-7850-444X</contrib-id><email>agiovann@email.unc.edu</email><xref ref-type="aff" rid="aff1">1</xref><xref ref-type="other" rid="fund2"/><xref ref-type="fn" rid="con1"/><xref ref-type="fn" rid="conf1"/><xref ref-type="other" rid="dataset4"/></contrib><contrib contrib-type="author" id="author-102333"><name><surname>Friedrich</surname><given-names>Johannes</given-names></name><contrib-id authenticated="true" contrib-id-type="orcid">https://orcid.org/0000-0002-1321-5866</contrib-id><xref ref-type="aff" rid="aff1">1</xref><xref ref-type="aff" rid="aff2">2</xref><xref ref-type="aff" rid="aff3">3</xref><xref ref-type="other" rid="fund2"/><xref ref-type="fn" rid="con2"/><xref ref-type="fn" rid="conf1"/><xref ref-type="other" rid="dataset4"/></contrib><contrib contrib-type="author" id="author-114312"><name><surname>Gunn</surname><given-names>Pat</given-names></name><xref ref-type="aff" rid="aff1">1</xref><xref ref-type="other" rid="fund2"/><xref ref-type="fn" rid="con3"/><xref ref-type="fn" rid="conf1"/><xref ref-type="other" rid="dataset4"/></contrib><contrib contrib-type="author" id="author-114313"><name><surname>Kalfon</surname><given-names>Jérémie</given-names></name><contrib-id authenticated="true" contrib-id-type="orcid">https://orcid.org/0000-0002-2818-9728</contrib-id><xref ref-type="aff" rid="aff4">4</xref><xref ref-type="other" rid="fund2"/><xref ref-type="fn" rid="con4"/><xref ref-type="fn" rid="conf1"/><xref ref-type="fn" rid="fn1">†</xref></contrib><contrib contrib-type="author" id="author-124258"><name><surname>Brown</surname><given-names>Brandon L</given-names></name><xref ref-type="aff" rid="aff5">5</xref><xref ref-type="fn" rid="con5"/><xref ref-type="fn" rid="conf1"/><xref ref-type="other" rid="dataset4"/></contrib><contrib contrib-type="author" id="author-109421"><name><surname>Koay</surname><given-names>Sue Ann</given-names></name><xref ref-type="aff" rid="aff6">6</xref><xref ref-type="other" rid="fund3"/><xref ref-type="other" rid="fund4"/><xref ref-type="other" rid="fund5"/><xref ref-type="fn" rid="con6"/><xref ref-type="fn" rid="conf1"/><xref ref-type="other" rid="dataset4"/></contrib><contrib contrib-type="author" id="author-114310"><name><surname>Taxidis</surname><given-names>Jiannis</given-names></name><xref ref-type="aff" rid="aff7">7</xref><xref ref-type="other" rid="fund9"/><xref ref-type="fn" rid="con7"/><xref ref-type="fn" rid="conf1"/><xref ref-type="other" rid="dataset4"/></contrib><contrib contrib-type="author" id="author-15271"><name><surname>Najafi</surname><given-names>Farzaneh</given-names></name><xref ref-type="aff" rid="aff8">8</xref><xref ref-type="other" rid="fund3"/><xref ref-type="other" rid="fund10"/><xref ref-type="fn" rid="con8"/><xref ref-type="fn" rid="conf1"/><xref ref-type="other" rid="dataset4"/></contrib><contrib contrib-type="author" id="author-114311"><name><surname>Gauthier</surname><given-names>Jeffrey L</given-names></name><xref ref-type="aff" rid="aff6">6</xref><xref ref-type="other" rid="fund1"/><xref ref-type="other" rid="fund3"/><xref ref-type="other" rid="fund4"/><xref ref-type="other" rid="fund5"/><xref ref-type="fn" rid="con9"/><xref ref-type="fn" rid="conf1"/><xref ref-type="other" rid="dataset4"/></contrib><contrib contrib-type="author" id="author-58658"><name><surname>Zhou</surname><given-names>Pengcheng</given-names></name><contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0003-1237-3931</contrib-id><xref ref-type="aff" rid="aff2">2</xref><xref ref-type="aff" rid="aff3">3</xref><xref ref-type="other" rid="fund6"/><xref ref-type="other" rid="fund7"/><xref ref-type="other" rid="fund8"/><xref ref-type="fn" rid="con10"/><xref ref-type="fn" rid="conf1"/><xref ref-type="other" rid="dataset4"/></contrib><contrib contrib-type="author" id="author-39326"><name><surname>Khakh</surname><given-names>Baljit S</given-names></name><xref ref-type="aff" rid="aff5">5</xref><xref ref-type="aff" rid="aff9">9</xref><xref ref-type="fn" rid="con11"/><xref ref-type="fn" rid="conf1"/><xref ref-type="other" rid="dataset4"/></contrib><contrib contrib-type="author" id="author-9453"><name><surname>Tank</surname><given-names>David W</given-names></name><contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-9423-4267</contrib-id><xref ref-type="aff" rid="aff6">6</xref><xref ref-type="other" rid="fund3"/><xref ref-type="other" rid="fund4"/><xref ref-type="other" rid="fund5"/><xref ref-type="fn" rid="con12"/><xref ref-type="fn" rid="conf1"/><xref ref-type="other" rid="dataset4"/></contrib><contrib contrib-type="author" id="author-78191"><name><surname>Chklovskii</surname><given-names>Dmitri B</given-names></name><contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-4781-2546</contrib-id><xref ref-type="aff" rid="aff1">1</xref><xref ref-type="other" rid="fund2"/><xref ref-type="fn" rid="con13"/><xref ref-type="fn" rid="conf1"/><xref ref-type="other" rid="dataset4"/></contrib><contrib contrib-type="author" corresp="yes" id="author-102334"><name><surname>Pnevmatikakis</surname><given-names>Eftychios A</given-names></name><contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0003-1509-6394</contrib-id><email>epnevmatikakis@flatironinstitute.org</email><xref ref-type="aff" rid="aff1">1</xref><xref ref-type="other" rid="fund2"/><xref ref-type="fn" rid="con14"/><xref ref-type="fn" rid="conf1"/><xref ref-type="other" rid="dataset4"/></contrib><aff id="aff1"><label>1</label><institution content-type="dept">Center for Computational Biology</institution><institution>Flatiron Institute, Simons Foundation</institution><addr-line><named-content content-type="city">New York</named-content></addr-line><country>United States</country></aff><aff id="aff2"><label>2</label><institution content-type="dept">Department of Statistics</institution><institution>Columbia University</institution><addr-line><named-content content-type="city">New York</named-content></addr-line><country>United States</country></aff><aff id="aff3"><label>3</label><institution content-type="dept">Center for Theoretical Neuroscience</institution><institution>Columbia University</institution><addr-line><named-content content-type="city">New York</named-content></addr-line><country>United States</country></aff><aff id="aff4"><label>4</label><institution>ECE Paris</institution><addr-line><named-content content-type="city">Paris</named-content></addr-line><country>France</country></aff><aff id="aff5"><label>5</label><institution content-type="dept">Department of Physiology</institution><institution>University of California, Los Angeles</institution><addr-line><named-content content-type="city">Los Angeles</named-content></addr-line><country>United States</country></aff><aff id="aff6"><label>6</label><institution content-type="dept">Princeton Neuroscience Institute</institution><institution>Princeton University</institution><addr-line><named-content content-type="city">Princeton</named-content></addr-line><country>United States</country></aff><aff id="aff7"><label>7</label><institution content-type="dept">Department of Neurology</institution><institution>University of California, Los Angeles</institution><addr-line><named-content content-type="city">Los Angeles</named-content></addr-line><country>United States</country></aff><aff id="aff8"><label>8</label><institution>Cold Spring Harbor Laboratory</institution><addr-line><named-content content-type="city">New York</named-content></addr-line><country>United States</country></aff><aff id="aff9"><label>9</label><institution content-type="dept">Department of Neurobiology</institution><institution>University of California, Los Angeles</institution><addr-line><named-content content-type="city">Los Angeles</named-content></addr-line><country>United States</country></aff></contrib-group><contrib-group content-type="section"><contrib contrib-type="editor"><name><surname>Kleinfeld</surname><given-names>David</given-names></name><role>Reviewing Editor</role><aff><institution>University of California, San Diego</institution><country>United States</country></aff></contrib><contrib contrib-type="senior_editor"><name><surname>King</surname><given-names>Andrew J</given-names></name><role>Senior Editor</role><aff><institution>University of Oxford</institution><country>United Kingdom</country></aff></contrib></contrib-group><author-notes><fn fn-type="other" id="fn1"><label>†</label><p>JK contributed to this work during an internship at the Flatiron Institute</p></fn></author-notes><pub-date date-type="publication" publication-format="electronic"><day>17</day><month>01</month><year>2019</year></pub-date><pub-date pub-type="collection"><year>2019</year></pub-date><volume>8</volume><elocation-id>e38173</elocation-id><history><date date-type="received" iso-8601-date="2018-05-08"><day>08</day><month>05</month><year>2018</year></date><date date-type="accepted" iso-8601-date="2018-11-23"><day>23</day><month>11</month><year>2018</year></date></history><permissions><copyright-statement>© 2019, Giovannucci et al</copyright-statement><copyright-year>2019</copyright-year><copyright-holder>Giovannucci et al</copyright-holder><ali:free_to_read/><license xlink:href="http://creativecommons.org/licenses/by/4.0/"><ali:license_ref>http://creativecommons.org/licenses/by/4.0/</ali:license_ref><license-p>This article is distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use and redistribution provided that the original author and source are credited.</license-p></license></permissions><self-uri content-type="pdf" xlink:href="elife-38173-v1.pdf"/><abstract><object-id pub-id-type="doi">10.7554/eLife.38173.001</object-id><p>Advances in fluorescence microscopy enable monitoring larger brain areas in-vivo with finer time resolution. The resulting data rates require reproducible analysis pipelines that are reliable, fully automated, and scalable to datasets generated over the course of months. We present C<sc>a</sc>I<sc>m</sc>A<sc>n</sc>, an open-source library for calcium imaging data analysis. C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> provides automatic and scalable methods to address problems common to pre-processing, including motion correction, neural activity identification, and registration across different sessions of data collection. It does this while requiring minimal user intervention, with good scalability on computers ranging from laptops to high-performance computing clusters. C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> is suitable for two-photon and one-photon imaging, and also enables real-time analysis on streaming data. To benchmark the performance of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> we collected and combined a corpus of manual annotations from multiple labelers on nine mouse two-photon datasets. We demonstrate that C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> achieves near-human performance in detecting locations of active neurons.</p></abstract><abstract abstract-type="executive-summary"><object-id pub-id-type="doi">10.7554/eLife.38173.002</object-id><title>eLife digest</title><p>The human brain contains billions of cells called neurons that rapidly carry information from one part of the brain to another. Progress in medical research and healthcare is hindered by the difficulty in understanding precisely which neurons are active at any given time. New brain imaging techniques and genetic tools allow researchers to track the activity of thousands of neurons in living animals over many months. However, these experiments produce large volumes of data that researchers currently have to analyze manually, which can take a long time and generate irreproducible results.</p><p>There is a need to develop new computational tools to analyze such data. The new tools should be able to operate on standard computers rather than just specialist equipment as this would limit the use of the solutions to particularly well-funded research teams. Ideally, the tools should also be able to operate in real-time as several experimental and therapeutic scenarios, like the control of robotic limbs, require this. To address this need, Giovannucci et al. developed a new software package called CaImAn to analyze brain images on a large scale.</p><p>Firstly, the team developed algorithms that are suitable to analyze large sets of data on laptops and other standard computing equipment. These algorithms were then adapted to operate online in real-time. To test how well the new software performs against manual analysis by human researchers, Giovannucci et al. asked several trained human annotators to identify active neurons that were round or donut-shaped in several sets of imaging data from mouse brains. Each set of data was independently analyzed by three or four researchers who then discussed any neurons they disagreed on to generate a ‘consensus annotation’. Giovannucci et al. then used CaImAn to analyze the same sets of data and compared the results to the consensus annotations. This demonstrated that CaImAn is nearly as good as human researchers at identifying active neurons in brain images.</p><p>CaImAn provides a quicker method to analyze large sets of brain imaging data and is currently used by over a hundred laboratories across the world. The software is open source, meaning that it is freely-available and that users are encouraged to customize it and collaborate with other users to develop it further.</p></abstract><kwd-group kwd-group-type="author-keywords"><kwd>calcium imaging</kwd><kwd>open source</kwd><kwd>software</kwd><kwd>two-photon</kwd><kwd>one-photon</kwd><kwd>data analysis</kwd></kwd-group><kwd-group kwd-group-type="research-organism"><title>Research organism</title><kwd>Mouse</kwd><kwd>Zebrafish</kwd></kwd-group><funding-group><award-group id="fund1"><funding-source><institution-wrap><institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100000002</institution-id><institution>National Institutes of Health</institution></institution-wrap></funding-source><award-id>F32NS077840-01</award-id><principal-award-recipient><name><surname>Gauthier</surname><given-names>Jeffrey L</given-names></name></principal-award-recipient></award-group><award-group id="fund2"><funding-source><institution-wrap><institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100000893</institution-id><institution>Simons Foundation</institution></institution-wrap></funding-source><award-id>FI-CCB</award-id><principal-award-recipient><name><surname>Giovannucci</surname><given-names>Andrea</given-names></name><name><surname>Friedrich</surname><given-names>Johannes</given-names></name><name><surname>Gunn</surname><given-names>Pat</given-names></name><name><surname>Kalfon</surname><given-names>Jeremie</given-names></name><name><surname>Chklovskii</surname><given-names>Dmitri B</given-names></name><name><surname>Pnevmatikakis</surname><given-names>Eftychios A</given-names></name></principal-award-recipient></award-group><award-group id="fund3"><funding-source><institution-wrap><institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100000893</institution-id><institution>Simons Foundation</institution></institution-wrap></funding-source><award-id>SCGB</award-id><principal-award-recipient><name><surname>Koay</surname><given-names>Sue Ann</given-names></name><name><surname>Najafi</surname><given-names>Farzaneh</given-names></name><name><surname>Gauthier</surname><given-names>Jeffrey L</given-names></name><name><surname>Tank</surname><given-names>David W</given-names></name></principal-award-recipient></award-group><award-group id="fund4"><funding-source><institution-wrap><institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100000002</institution-id><institution>National Institutes of Health</institution></institution-wrap></funding-source><award-id>5U01NS090541</award-id><principal-award-recipient><name><surname>Koay</surname><given-names>Sue Ann</given-names></name><name><surname>Gauthier</surname><given-names>Jeffrey L</given-names></name><name><surname>Tank</surname><given-names>David W</given-names></name></principal-award-recipient></award-group><award-group id="fund5"><funding-source><institution-wrap><institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100000002</institution-id><institution>National Institutes of Health</institution></institution-wrap></funding-source><award-id>1U19NS104648</award-id><principal-award-recipient><name><surname>Koay</surname><given-names>Sue Ann</given-names></name><name><surname>Gauthier</surname><given-names>Jeffrey L</given-names></name><name><surname>Tank</surname><given-names>David W</given-names></name></principal-award-recipient></award-group><award-group id="fund6"><funding-source><institution-wrap><institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100000002</institution-id><institution>National Institutes of Health</institution></institution-wrap></funding-source><award-id>NIBIB R01EB022913</award-id><principal-award-recipient><name><surname>Zhou</surname><given-names>Pengcheng</given-names></name></principal-award-recipient></award-group><award-group id="fund7"><funding-source><institution-wrap><institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100000001</institution-id><institution>National Science Foundation</institution></institution-wrap></funding-source><award-id>NeuroNex DBI-1707398</award-id><principal-award-recipient><name><surname>Zhou</surname><given-names>Pengcheng</given-names></name></principal-award-recipient></award-group><award-group id="fund8"><funding-source><institution-wrap><institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/501100000324</institution-id><institution>Gatsby Charitable Foundation</institution></institution-wrap></funding-source><principal-award-recipient><name><surname>Zhou</surname><given-names>Pengcheng</given-names></name></principal-award-recipient></award-group><award-group id="fund9"><funding-source><institution-wrap><institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100000002</institution-id><institution>National Institutes of Health</institution></institution-wrap></funding-source><award-id>R01-MH101198</award-id><principal-award-recipient><name><surname>Taxidis</surname><given-names>Jiannis</given-names></name></principal-award-recipient></award-group><award-group id="fund10"><funding-source><institution-wrap><institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100000875</institution-id><institution>Pew Charitable Trusts</institution></institution-wrap></funding-source><principal-award-recipient><name><surname>Najafi</surname><given-names>Farzaneh</given-names></name></principal-award-recipient></award-group><funding-statement>The funders had no role in study design, data collection and interpretation, or the decision to submit the work for publication.</funding-statement></funding-group><custom-meta-group><custom-meta specific-use="meta-only"><meta-name>Author impact statement</meta-name><meta-value>CaImAn is an open-software package that equips the neuroscience community with a set of turnkey, fast and scalable solutions to pre-processing problems arising in single cell calcium imaging data analysis.</meta-value></custom-meta></custom-meta-group></article-meta></front><body><sec id="s1" sec-type="intro"><title>Introduction</title><p>Understanding the function of neural circuits is contingent on the ability to accurately record and modulate the activity of large neural populations. Optical methods based on the fluorescence activity of genetically encoded calcium binding indicators (<xref ref-type="bibr" rid="bib9">Chen et al., 2013</xref>) have become a standard tool for this task, due to their ability to monitor in vivo targeted neural populations from many different brain areas over extended periods of time (weeks or months). Advances in microscopy techniques facilitate imaging larger brain areas with finer time resolution, producing an ever-increasing amount of data. A typical resonant scanning two-photon microscope produces data at a rate greater than 50 GB/Hr (calculation performed on a 512 <inline-formula><mml:math id="inf1"><mml:mo>×</mml:mo></mml:math></inline-formula> 512 Field of View imaged at 30 Hz producing an unsigned 16-bit integer for each measurement), a number that can be significantly higher (up to more than 1TB/Hour) with other custom recording technologies (<xref ref-type="bibr" rid="bib41">Sofroniew et al., 2016</xref>; <xref ref-type="bibr" rid="bib1">Ahrens et al., 2013</xref>; <xref ref-type="bibr" rid="bib13">Flusberg et al., 2008</xref>; <xref ref-type="bibr" rid="bib7">Cai et al., 2016</xref>; <xref ref-type="bibr" rid="bib37">Prevedel et al., 2014</xref>; <xref ref-type="bibr" rid="bib19">Grosenick et al., 2017</xref>; <xref ref-type="bibr" rid="bib5">Bouchard et al., 2015</xref>).</p><p>This increasing availability and volume of calcium imaging data calls for automated analysis methods and reproducible pipelines to extract the relevant information from the recorded movies, that is the locations of neurons in the imaged Field of View (FOV) and their activity in terms of raw fluorescence and/or neural activity (spikes). The typical steps arising in the processing pipelines are the following (<xref ref-type="fig" rid="fig1">Figure 1a</xref>): (i) Motion correction, where the FOV at each data frame (image or volume) is registered against a template to correct for motion artifacts due to the finite scanning rate and existing brain motion, (ii) source extraction where the different active and possibly overlapping sources are extracted and their signals are demixed from each other and from the background neuropil signals (<xref ref-type="fig" rid="fig1">Figure 1b</xref>), and (iii) activity deconvolution, where the neural activity of each identified source is deconvolved from the dynamics of the calcium indicator.</p><fig id="fig1" position="float"><object-id pub-id-type="doi">10.7554/eLife.38173.003</object-id><label>Figure 1.</label><caption><title>Processing pipeline of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> for calcium imaging data.</title><p>(<bold>a</bold>) The typical pre-processing steps include (i) correction for motion artifacts, (ii) extraction of the spatial footprints and fluorescence traces of the imaged components, and (iii) deconvolution of the neural activity from the fluorescence traces. (<bold>b</bold>) Time average of 2000 frames from a two-photon microscopy dataset (left) and magnified illustration of three overlapping neurons (right), as detected by the CNMF algorithm. (<bold>c</bold>) Denoised temporal components of the three neurons in (<bold>b</bold>) as extracted by CNMF and matched by color (in relative fluorescence change, <inline-formula><mml:math id="inf2"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi><mml:mi>F</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>F</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula>). (<bold>d</bold>) Intuitive depiction of CNMF. The algorithm represents the movie as the sum of spatially localized rank-one spatio-temporal components capturing neurons and processes, plus additional non-sparse low-rank terms for the background fluorescence and neuropil activity. (<bold>e</bold>) Flow-chart of the C<sc>a</sc>I<sc>m</sc>A<sc>n </sc><sc>batch</sc> processing pipeline. From left to right: Motion correction and generation of a memory efficient data format. Initial estimate of somatic locations in parallel over FOV patches using CNMF. Refinement and merging of extracted components via seeded CNMF. Removal of low quality components. Final domain dependent processing stages. (<bold>f</bold>) Flow-chart of the C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> algorithm. After a brief mini-batch initialization phase, each frame is processed in a streaming fashion as it becomes available. From left to right: Correction for motion artifacts. Estimation of activity from existing neurons, identification and incorporation of new neurons. The spatial footprints of inferred neurons are also updated periodically (dashed lines).</p></caption><graphic mime-subtype="tiff" mimetype="image" xlink:href="elife-38173-fig1-v1.tif"/></fig><sec id="s1-1"><title>Related work</title><sec id="s1-1-1"><title>Source extraction</title><p>Some source extraction methods attempt the detection of neurons in static images using supervised or unsupervised learning methods. Examples of unsupervised methods on summary images include graph-cut approaches applied to the correlation image (<xref ref-type="bibr" rid="bib21">Kaifosh et al., 2014</xref>; <xref ref-type="bibr" rid="bib42">Spaen et al., 2017</xref>), and dictionary learning (<xref ref-type="bibr" rid="bib26">Pachitariu et al., 2013</xref>). Supervised learning methods based on boosting (<xref ref-type="bibr" rid="bib46">Valmianski et al., 2010</xref>), or, more recently, deep neural networks have also been applied to the problem of neuron detection (<xref ref-type="bibr" rid="bib2">Apthorpe et al., 2016</xref>; <xref ref-type="bibr" rid="bib23">Klibisz et al., 2017</xref>). While these methods can be efficient in detecting the locations of neurons, they cannot infer the underlying activity nor do they readily offer ways to deal with the spatial overlap of different components.</p><p>To extract temporal traces jointly with the spatial footprints of the components one can use methods that directly represent the full spatio-temporal data using matrix factorization approaches for example independent component analysis (ICA) (<xref ref-type="bibr" rid="bib25">Mukamel et al., 2009</xref>), constrained nonnegative matrix factorization (CNMF) (<xref ref-type="bibr" rid="bib33">Pnevmatikakis et al., 2016</xref>) (and its adaptation to one-photon data (<xref ref-type="bibr" rid="bib52">Zhou et al., 2018</xref>)), clustering based approaches (<xref ref-type="bibr" rid="bib27">Pachitariu et al., 2017</xref>), dictionary learning (<xref ref-type="bibr" rid="bib30">Petersen et al., 2017</xref>), or active contour models (<xref ref-type="bibr" rid="bib38">Reynolds et al., 2017</xref>). Such spatio-temporal methods are unsupervised, and focus on detecting active neurons by considering the spatio-temporal activity of a component as a contiguous set of pixels within the FOV that are correlated in time. While such methods tend to offer a direct decomposition of the data in a set of sources with activity traces in an unsupervised way, in principle they require processing of the full dataset, and thus are quickly rendered intractable. Possible approaches to deal with the data size include distributed processing in High Performance Computing (HPC) clusters (<xref ref-type="bibr" rid="bib14">Freeman et al., 2014</xref>), spatio-temporal decimation (<xref ref-type="bibr" rid="bib15">Friedrich et al., 2017a</xref>), and dimensionality reduction (<xref ref-type="bibr" rid="bib27">Pachitariu et al., 2017</xref>). Recently, <xref ref-type="bibr" rid="bib17">Giovannucci et al., 2017</xref> prototyped an online algorithm (O<sc>n</sc>ACID), by adapting matrix factorization setups (<xref ref-type="bibr" rid="bib33">Pnevmatikakis et al., 2016</xref>; <xref ref-type="bibr" rid="bib24">Mairal et al., 2010</xref>), to operate on calcium imaging streaming data and thus natively deal with large data rates. For a full review see (<xref ref-type="bibr" rid="bib35">Pnevmatikakis, 2018</xref>).</p></sec><sec id="s1-1-2"><title>Deconvolution</title><p>For the problem of predicting spikes from fluorescence traces, both supervised and unsupervised methods have been explored. Supervised methods rely on the use of labeled data to train or fit biophysical or neural network models (<xref ref-type="bibr" rid="bib44">Theis et al., 2016</xref>), although semi-supervised that jointly learn a generative model for fluorescence traces have also been proposed (<xref ref-type="bibr" rid="bib43">Speiser et al., 2017</xref>). Unsupervised methods can be either deterministic, such as sparse non-negative deconvolution (<xref ref-type="bibr" rid="bib48">Vogelstein et al., 2010</xref>; <xref ref-type="bibr" rid="bib33">Pnevmatikakis et al., 2016</xref>) that give a single estimate of the deconvolved neural activity, or probabilistic, that aim to also characterize the uncertainty around these estimates (e.g., (<xref ref-type="bibr" rid="bib32">Pnevmatikakis et al., 2013</xref>; <xref ref-type="bibr" rid="bib12">Deneux et al., 2016</xref>)). A recent community benchmarking effort (<xref ref-type="bibr" rid="bib3">Berens et al., 2017</xref>) characterizes the similarities and differences of various available methods.</p></sec></sec><sec id="s1-2"><title>C<sc>a</sc>I<sc>m</sc>A<sc>n</sc></title><p>Here we present C<sc>a</sc>I<sc>m</sc>A<sc>n</sc>, an open source pipeline for the analysis of both two-photon and one-photon calcium imaging data. C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> includes algorithms for both offline analysis (C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc>) where all the data is processed at once at the end of each experiment, and online analysis on streaming data (C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc>). Moreover, C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> requires very moderate computing infrastructure (e.g., a personal laptop or workstation), thus providing automated, efficient, and reproducible large-scale analysis on commodity hardware.</p></sec><sec id="s1-3"><title>Contributions</title><p>Our contributions can be roughly grouped in three different directions:</p><p><bold>Methods</bold>: C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> improves on the scalability of the source extraction problem by employing a MapReduce framework for parallel processing and memory mapping which allows the analysis of datasets larger than would fit in RAM on most computer systems. It also improves on the qualitative performance by introducing automated routines for component evaluation and classification, better handling of neuropil contamination, and better initialization methods. While these benefits are here presented in the context of the widely used CNMF algorithm of <xref ref-type="bibr" rid="bib33">Pnevmatikakis et al. (2016)</xref>, they are in principle applicable to any matrix factorization approach.</p><p>C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> improves and extends the O<sc>n</sc>ACID prototype algorithm (<xref ref-type="bibr" rid="bib17">Giovannucci et al., 2017</xref>) by introducing, among other advances, new initialization methods and a convolutional neural network (CNN) based approach for detecting new neurons on streaming data. Our analysis on in vivo two-photon and light-sheet imaging datasets shows that C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> approaches human-level performance and enables novel types of closed-loop experiments. Apart from these significant algorithmic improvements C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> includes several useful analysis tools such as, a MapReduce and memory-mapping compatible implementation of the CNMF-E algorithm for one-photon microendoscopic data (<xref ref-type="bibr" rid="bib52">Zhou et al., 2018</xref>), a novel efficient algorithm for registration of components across multiple days, and routines for segmentation of structural (static) channel information which can be used for component seeding.</p><p><bold>Software</bold>: C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> is a complete open source software suite implemented primarily in Python, and is already widely used by, and has received contributions from, its community. It contains efficient implementations of the standard analysis pipeline steps (motion correction - source extraction - deconvolution - registration across different sessions), as well as numerous other features. Much of the functionality is also available in a separate MATLAB implementation.</p><p><bold>Data</bold>: We benchmark the performance of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> against a previously unreleased corpus of manually annotated data. The corpus consists of 9 mouse in vivo two-photon datasets. Each dataset is manually annotated by 3–4 independent labelers that were instructed to select active neurons in a principled and consistent way. In a subsequent stage, the annotations were combined to create a ‘consensus’ annotation, that is used to benchmark C<sc>a</sc>I<sc>m</sc>A<sc>n</sc>, to train supervised learning based classifiers, and to quantify the limits of human performance. The manual annotations are released to the community, providing a valuable tool for benchmarking and training purposes.</p><sec id="s1-3-1"><title>Paper organization</title><p>The paper is organized as follows: We first give a brief presentation of the analysis methods and features provided by C<sc>a</sc>I<sc>m</sc>A<sc>n</sc>. In the <italic>Results</italic> section we benchmark C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> and C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> against a corpus of manually annotated data. We apply C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> to a zebrafish whole brain lightsheet imaging recording, and demonstrate how such large datasets can be processed efficiently in real time. We also present applications of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> to one-photon data, as well as examples of component registration across multiple days. We conclude by discussing the utility of our tools, the relationship between C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> and C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> and outline future directions. Detailed descriptions of the introduced methods are presented in Materials and methods.</p></sec></sec><sec id="s1-4"><title>Methods</title><p>Before presenting the new analysis features introduced with this work, we overview the analysis pipeline that C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> uses and builds upon.</p><sec id="s1-4-1"><title>Overview of analysis pipeline</title><p>The standard analysis pipeline for calcium imaging data used in C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> is depicted in <xref ref-type="fig" rid="fig1">Figure 1a</xref>. The data is first processed to remove motion artifacts. Subsequently the active components (neurons and background) are extracted as individual pairs of a spatial footprint that describes the shape of each component projected to the imaged FOV, and a temporal trace that captures its fluorescence activity (<xref ref-type="fig" rid="fig1">Figure 1b–d</xref>). Finally, the neural activity of each fluorescence trace is deconvolved from the dynamics of the calcium indicator. These operations can be challenging because of limited axial resolution of 2-photon microscopy (or the much larger integration volume in one-photon imaging). This results in spatially overlapping fluorescence from different sources and neuropil activity. Before presenting the new features of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> in more detail, we briefly review how it incorporates existing tools in the pipeline.</p><sec id="s1-4-1-1"><title>Motion correction</title><p>C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> uses the N<sc>o</sc>RMC<sc>orre</sc> algorithm (<xref ref-type="bibr" rid="bib34">Pnevmatikakis and Giovannucci, 2017</xref>) that corrects non-rigid motion artifacts by estimating motion vectors with subpixel resolution over a set of overlapping patches within the FOV. These estimates are used to infer a smooth motion field within the FOV for each frame. For two-photon imaging data this approach is directly applicable, whereas for one-photon micro-endoscopic data the motion is estimated on high pass spatially filtered data, a necessary operation to remove the smooth background signal and create enhanced spatial landmarks. The inferred motion fields are then applied to the original data frames.</p></sec><sec id="s1-4-1-2"><title>Source extraction</title><p>Source extraction is performed using the constrained non-negative matrix factorization (CNMF) framework of <xref ref-type="bibr" rid="bib33">Pnevmatikakis et al. (2016)</xref> which can extract components with overlapping spatial footprints (<xref ref-type="fig" rid="fig1">Figure 1b</xref>). After motion correction the spatio-temporal activity of each source can be expressed as a rank one matrix given by the outer product of two components: a component in space that describes the spatial footprint (location and shape) of each source, and a component in time that describes the activity trace of the source (<xref ref-type="fig" rid="fig1">Figure 1c</xref>). The data can be described by the sum of all the resulting rank one matrices together with an appropriate term for the background and neuropil signal and a noise term (<xref ref-type="fig" rid="fig1">Figure 1d</xref>). For two-photon data the neuropil signal can be modeled as a low rank matrix (<xref ref-type="bibr" rid="bib33">Pnevmatikakis et al., 2016</xref>). For microendoscopic data the larger integration volume leads to more complex background contamination (<xref ref-type="bibr" rid="bib52">Zhou et al., 2018</xref>). Therefore, a more descriptive model is required (see Materials and methods (Mathemathical model of the CNMF framework) for a mathematical description). C<sc>a</sc>I<sc>m</sc>A<sc>n </sc><sc>batch</sc> embeds these approaches into a general algorithmic framework that enables scalable automated processing with improved results versus the original CNMF and other popular algorithms, in terms of quality and processing speed.</p></sec><sec id="s1-4-1-3"><title>Deconvolution</title><p>Neural activity deconvolution is performed using sparse non-negative deconvolution (<xref ref-type="bibr" rid="bib48">Vogelstein et al., 2010</xref>; <xref ref-type="bibr" rid="bib33">Pnevmatikakis et al., 2016</xref>) and implemented using the near-online OASIS algorithm (<xref ref-type="bibr" rid="bib16">Friedrich et al., 2017b</xref>). The algorithm is competitive to the state of the art according to recent benchmarking studies (<xref ref-type="bibr" rid="bib3">Berens et al., 2017</xref>). Prior to deconvolution, the traces are detrended to remove non-stationary effects, for example photo-bleaching.</p></sec><sec id="s1-4-1-4"><title>Online processing</title><p>The three processing steps described above can be implemented in an online fashion using the <sc>OnACID</sc> algorithm (<xref ref-type="bibr" rid="bib17">Giovannucci et al., 2017</xref>). The method extends the online dictionary learning framework presented in <xref ref-type="bibr" rid="bib24">Mairal et al. (2010)</xref> for source extraction, by introducing spatial constraints, adding the capability of finding new components as they appear and also incorporating the steps of motion correction and deconvolution (<xref ref-type="fig" rid="fig1">Figure 1e</xref>). C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> extends and improves the O<sc>n</sc>ACID prototype algorithm by introducing a number of algorithmic features and a CNN based component detection approach, leading to a major performance improvement.</p><p>We now present the new methods introduced by C<sc>a</sc>I<sc>m</sc>A<sc>n</sc>. More details are given in Materials and methods and pseudocode descriptions of the main routines are given in the <italic>Appendix</italic>.</p></sec></sec><sec id="s1-4-2"><title>Batch processing of large scale datasets on standalone machines</title><p>The batch processing pipeline mentioned above represents a computational bottleneck. For instance, a naive first step might be to load in-memory the full dataset; this approach is non-scalable as datasets typically exceed available RAM (and extra memory is required by any analysis pipeline). To limit memory usage, as well as computation time, C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> relies on a MapReduce approach (<xref ref-type="bibr" rid="bib11">Dean and Ghemawat, 2008</xref>). Unlike previous work (<xref ref-type="bibr" rid="bib14">Freeman et al., 2014</xref>), C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> assumes minimal computational infrastructure (down to a standard laptop computer), is not tied to a particular parallel computation framework, and is compatible with HPC scheduling systems like SLURM (<xref ref-type="bibr" rid="bib51">Yoo et al., 2003</xref>).</p><p>Naive implementations of motion correction algorithms need to either load in memory the full dataset or are constrained to process one frame at a time, therefore preventing parallelization. Motion correction is parallelized in C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>without significant memory overhead by processing temporal chunks of movie data on different CPUs. First, each chunk is registered with its own template and a new template is formed by the registered data of each chunk. C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> then broadcasts to each CPU a meta-template, obtained as the median between all templates, which is used to align all the frames in each chunk. Each process writes in parallel to the target file containing motion-corrected data, which is stored as a memory mapped array. This allows arithmetic operations to be performed against data stored on the hard drive with minimal memory use, and data slices to be indexed and accessed without loading the full file in memory. More details are given in Materials and methods (Memory mapping).</p><p>Similarly, the source extraction problem, especially in the case of detecting cell bodies, is inherently local with a neuron typically appearing in a neighborhood within a small radius from its center of mass (<xref ref-type="fig" rid="fig2">Figure 2a</xref>). Exploiting this locality, C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> splits the FOV into a set of spatially overlapping patches which enables the parallelization of the CNMF (or any other) algorithm to extract the corresponding set of local spatial and temporal components. The user specifies the size of the patch, the amount of overlap between neighboring patches and the initialization parameters for each patch (number of components and rank background for CNMF, average size of each neuron, stopping criteria for CNMF-E). Subsequently the patches are processed in parallel by the CNMF/CNMF-E algorithm to extract the components and neuropil signals from each patch.</p><fig id="fig2" position="float"><object-id pub-id-type="doi">10.7554/eLife.38173.004</object-id><label>Figure 2.</label><caption><title>Parallelized processing and component quality assessment for C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc>.</title><p>(<bold>a</bold>) Illustration of the parallelization approach used by C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> for source extraction. The data movie is partitioned into overlapping sub-tensors, each of which is processed in an embarrassingly parallel fashion using CNMF, either on local cores or across several machines in a HPC. The results are then combined. (<bold>b</bold>) Refinement after combining the results can also be parallelized both in space and in time. Temporal traces of spatially non-overlapping components can be updated in parallel (top) and the contribution of the spatial footprints for each pixel can be computed in parallel (bottom). Parallelization in combination with memory mapping enable large scale processing with moderate computing infrastructure. (<bold>c</bold>) Quality assessment in space: The spatial footprint of each real component is correlated with the data averaged over time, after removal of all other activity. (<bold>d</bold>) Quality assessment in time: A high SNR is typically maintained over the course of a calcium transient. (<bold>e</bold>) CNN based assessment. <italic>Top</italic>: A 4-layer CNN based classifier is used to classify the spatial footprint of each component into neurons or not, see Materials and methods (<italic>Classification through CNNs</italic>) for a description. <italic>Bottom</italic>: Positive and negative examples for the CNN classifier, during training (left) and evaluation (right) phase. The CNN classifier can accurately classify shapes and generalizes across datasets from different brain areas.</p></caption><graphic mime-subtype="tiff" mimetype="image" xlink:href="elife-38173-fig2-v1.tif"/></fig><p>Apart from harnessing memory and computational benefits due to parallelization, processing in patches intrinsically equalizes dynamic range and enables C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> to detect neurons across the whole FOV, a feature absent in the original CNMF, where areas with high absolute fluorescence variation tend to be favored. This results in better source extraction performance. After all the patches have been processed, the results are embedded within the FOV (<xref ref-type="fig" rid="fig2">Figure 2a</xref>), and the overlapping regions between neighboring patches are processed so that components corresponding to the same neuron are merged. The process is summarized in algorithmic format in Algorithm 1 and more details are given in Materials and methods (Combining results from different patches).</p></sec><sec id="s1-4-3"><title>Initialization methods</title><p>Due to the non-convex nature of the objective function for matrix factorization, the choice of the initialization method can severely impact the final results. C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> provides an extension of the G<sc>reedy</sc>ROI method used in <xref ref-type="bibr" rid="bib33">Pnevmatikakis et al. (2016)</xref>, that detects neurons based on localized spatiotemporal activity. C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> can also be seeded with binary masks that are obtained from different sources, for example through manual annotation or segmentation of structural channel (<sc>SeededInitialization</sc>, Algorithm 3). More details are given in Materials and methods (Initialization strategies).</p></sec><sec id="s1-4-4"><title>Automated component evaluation and classification</title><p>A common limitation of matrix factorization algorithms is that the number of components that the algorithm seeks during its initialization must be pre-determined by the user. For example, <xref ref-type="bibr" rid="bib33">Pnevmatikakis et al. (2016)</xref> suggest detecting a large number of components which are then ordered according to their size and activity pattern, with the user deciding on a cut-off threshold. When processing large datasets in patches the target number of components is passed on to every patch implicitly assuming a uniform density of (active) neurons within the entire FOV. This assumption does not hold in the general case and can produce many spurious components. C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> introduces tests, based on unsupervised and supervised learning, to assess the quality of the detected components and eliminate possible false positives. These tests are based on the observation that active components are bound to have a distinct localized spatio-temporal signature within the FOV. In C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc>, these tests are initially applied after the processing of each patch is completed, and additionally as a post-processing step after the results from the patches have been merged and refined, whereas in C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> they are used to screen new candidate components. We briefly present these tests below and refer to Materials and methods (Details of quality assessment tests) for more details:</p><p><bold>Spatial footprint consistency</bold>: To test whether a detected component is spurious, we correlate the spatial footprint of this component with the average frame of the data, taken over the intervals when the component, with no other overlapping component, was active (<xref ref-type="fig" rid="fig2">Figure 2c</xref>). The component is rejected if the correlation coefficient is below a certain threshold <inline-formula><mml:math id="inf3"><mml:msub><mml:mi>θ</mml:mi><mml:mi>sp</mml:mi></mml:msub></mml:math></inline-formula> (e.g., <inline-formula><mml:math id="inf4"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">p</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>&lt;</mml:mo><mml:mspace width="thinmathspace"/><mml:mn>0.5</mml:mn></mml:mrow></mml:mstyle></mml:math></inline-formula>).</p><p><bold>Trace SNR</bold>: For each component we computed the peak SNR of its temporal trace averaged over the duration of a typical transient (<xref ref-type="fig" rid="fig2">Figure 2d</xref>). The component is rejected if the computed SNR is below a certain threshold <inline-formula><mml:math id="inf5"><mml:msub><mml:mi>θ</mml:mi><mml:mi>SNR</mml:mi></mml:msub></mml:math></inline-formula> (e.g., <inline-formula><mml:math id="inf6"><mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mi>SNR</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>).</p><p><bold>CNN based classification</bold>: We also trained a 4-layer convolutional neural network (CNN) to classify spatial footprints into true or false components (<xref ref-type="fig" rid="fig2">Figure 2e</xref>), where a true component here corresponds to a spatial footprint that resembles the soma of a neuron. The classifier, which we call batch classifier, was trained on a small corpus of manually annotated datasets (full description given in section <italic>Benchmarking against consensus annotation</italic>) and exhibited similar high classification performance on test samples from different datasets.</p><p>While C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> uses the CNMF algorithm, the tests described above can be applied to results obtained from any source extraction algorithm, highlighting the modularity of our tools.</p></sec><sec id="s1-4-5"><title>Online analysis with C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc></title><p>C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> supports online analysis on streaming data building on the core of the prototype algorithm of <xref ref-type="bibr" rid="bib17">Giovannucci et al., 2017</xref>, and extending it in terms of qualitative performance and computational efficiency:</p><p><bold>Initialization:</bold> Apart from initializing C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> with C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> on a small time interval, C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> can also be initialized in a bare form over an even smaller time interval, where only the background components are estimated and all the components are determined during the online analysis. This process, named <sc>BareInitialization</sc>, can be achieved by running the CNMF algorithm (<xref ref-type="bibr" rid="bib33">Pnevmatikakis et al., 2016</xref>) over the small interval to estimate the background components and possibly a small number of components. The <sc>SeededInitialization</sc> of Algorithm 3 can also be used.</p><p><bold>Deconvolution:</bold> Instead of a separate step after demixing as in <xref ref-type="bibr" rid="bib17">Giovannucci et al., 2017</xref>, deconvolution here can be performed simultaneously with the demixing online, leading to more stable traces especially in cases of low-SNR, as also observed in <xref ref-type="bibr" rid="bib33">Pnevmatikakis et al. (2016)</xref>. Online deconvolution can also be performed for models that assume second order calcium dynamics, bringing the full power of <xref ref-type="bibr" rid="bib16">Friedrich et al., 2017b</xref> to processing of streaming data.</p><p><bold>Epochs:</bold> C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> supports multiple passes over the data, a process that can detect early activity of neurons that were not picked up during the initial pass, as well as smooth the activity of components that were detected at late stages during the first epoch.</p><p><bold>New component detection using a CNN:</bold> To search for new components in a streaming setup, O<sc>nACID</sc> keeps a buffer of the residual frames, computed by subtracting the activity of already found components and background signals. Candidate components are determined by looking for points of maximum energy in this residual signal, after some smoothing and dynamic range equalization. For each such point identified, a candidate shape and trace are constructed using a rank-1 NMF in a local neighborhood around this point. In its original formulation (<xref ref-type="bibr" rid="bib17">Giovannucci et al., 2017</xref>), the shape of the component was evaluated using the space correlation test described above. Here, we use a CNN classifier approach that tests candidate components by examining their spatial footprint as obtained by the average of the residual buffer across time. This online classifier (different from the batch classifier for quality assessment described above), is trained to be strict, minimizing the number of false positive components that enter the online processing pipeline. It can test multiple components in parallel, and it achieves better performance with no hyper-parameter tuning compared to the previous approach. More details on the architecture and training procedure are given in Materials and methods (Classification through CNNs). The identification of candidate components is further improved by performing spatial high pass filtering on the average residual buffer to enhance its contrast. The new process for detecting neurons is described in Algorithm 4 and 5. See <xref ref-type="video" rid="video1">Videos 1</xref> and <xref ref-type="video" rid="video2">2</xref> on a detailed graphic description of the new component detection step.</p><p>Distributed update of spatial footprints: A time limiting step in <sc>OnACID</sc> (<xref ref-type="bibr" rid="bib17">Giovannucci et al., 2017</xref>) is the periodic update of all spatial footprints at given frames. This constraint is lifted with <sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> that distributes the update of spatial footprints among all frames ensuring a similar processing speed for each frame. See Materials and methods (Distributed shape update) for more details.</p></sec><sec id="s1-4-6"><title>Component registration across multiple sessions</title><p> C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> provides a method to register components from the same FOV across different sessions. The method uses an intersection over union metric to calculate the distance between different cells in different sessions and solves a linear assignment problem to perform the registration in a fully automated way (<sc>RegisterPair</sc>, Algorithm 7). To register the components between more than two sessions (<sc>RegisterMulti</sc>, Algorithm 8), we order the sessions chronologically and register the components of the current session against the union of components of all the past sessions aligned to the current FOV. This allows for the tracking of components across multiple sessions without the need of pairwise registration between each pair of sessions. More details as well as discussion of other methods (<xref ref-type="bibr" rid="bib39">Sheintuch et al., 2017</xref>) are given in Materials and methods (Component registration).</p></sec><sec id="s1-4-7"><title>Benchmarking against manual annotations</title><p>To quantitatively evaluate C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> we benchmarked its results against manual annotations.</p><sec id="s1-4-7-1"><title>Creating consensus labels through manual annotation</title><p>We collected manual annotations from multiple independent labelers who were instructed to find round or donut shaped (since proteins expressing the calcium indicator are confined outside the cell nuclei, neurons will appear as ring shapes, with a dark disk in the center) <italic>active</italic> neurons on nine two-photon in vivo mouse brain datasets. To distinguish between active and inactive neurons, the annotators were given the max-correlation image for each dataset (the value of the correlation image for each pixel represent the average correlation (across time) between the pixel and its neighbors (<xref ref-type="bibr" rid="bib40">Smith and Häusser, 2010</xref>). This summarization can enhance active neurons and suppress neuropil for two photon datasets (<xref ref-type="fig" rid="fig3s1">Figure 3—figure supplement 1a</xref>). See Materials and methods (Collection of manual annotations) for more information). In addition, the annotators were given a temporally decimated background subtracted movie of each dataset. The datasets were collected at various labs and from various brain areas (hippocampus, visual cortex, parietal cortex) using several GCaMP variants. A summary of the features of all the annotated datasets is given in Table 2.</p><p>To address human variability in manual annotation each dataset was labeled by 3 or 4 independent labelers, and the final consensus annotation dataset was created by having the different labelers reaching a <italic>consensus</italic> over their disagreements (<xref ref-type="fig" rid="fig3">Figure 3a</xref>). The consensus annotation was taken as ‘ground truth’ for the purpose of benchmarking C<sc>a</sc>I<sc>m</sc>A<sc>n </sc>and each individual labeler (<xref ref-type="fig" rid="fig3">Figure 3b</xref>). More details are given in Materials and methods (Collection of manual annotations). We believe that the current database, which is publicly available at <ext-link ext-link-type="uri" xlink:href="https://users.flatironinstitute.org/~neuro/caiman_paper">https://users.flatironinstitute.org/~neuro/caiman_paper</ext-link>, presents an improvement over the existing <sc>Neurofinder</sc> database (<ext-link ext-link-type="uri" xlink:href="http://neurofinder.codeneuro.org/">http://neurofinder.codeneuro.org/</ext-link>) in several aspects:</p><fig-group><fig id="fig3" position="float"><object-id pub-id-type="doi">10.7554/eLife.38173.005</object-id><label>Figure 3.</label><caption><title>Consensus annotation generation.</title><p>(<bold>a</bold>) <italic>Top:</italic> Individual manual annotations on the dataset K53 (only part of the FOV is shown) for labelers L1 (left), L2 (middle), L3(right). Contour plots are plotted against the max-correlation image of the dataset. <italic>Bottom:</italic> Disagreements between L1 and L2 (left), and consensus labels (right). In this example, consensus considerably reduced the number of initially selected neurons. (<bold>b</bold>) Matches (top) and mismatches (bottom) between each individual labeler and consensus annotation. Red contours on the mismatches panels denote false negative contours, that is components in the consensus not selected by the corresponding labeler, whereas yellow contours indicate false positive contours. Performance of each labeler is given in terms of precision/recall and <inline-formula><mml:math id="inf7"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> score and indicates an unexpected level of variability between individual labelers.</p></caption><graphic mime-subtype="tiff" mimetype="image" xlink:href="elife-38173-fig3-v1.tif"/></fig><fig id="fig3s1" position="float" specific-use="child-fig"><object-id pub-id-type="doi">10.7554/eLife.38173.006</object-id><label>Figure 3—figure supplement 1.</label><caption><title>Construction of components obtained from consensus annotation.</title><p>(<bold>a</bold>) Correlation image can efficiently display active neurons. Comparison of median across time (top) and max-correlation (bottom) image for annotated datasets J115 (left), K53 (middle) and YST (right). In all cases, the correlation image aids in manual annotation by providing an efficient way to remove neuropil contamination and visualize the footprints of active neurons. (<bold>b</bold>) Contour plots of manual annotations (left) vs spatial footprints obtained after running SeededInitialization (right), for dataset J115 overlaid against the mean image. Manual annotations are restricted to be of ellipsoid shape whereas pre-processing with SeededInitialization allows the spatial footprints to adapt to the footprint of each neuron in the FOV. (<bold>c</bold>) Thresholding of spatial footprints selects the most prominent part of each neuron for comparison against ground truth. Left. Four examples of non thresholded components overlaid to their corresponding contours. Right. Same as left, but including all neurons within a small region. Finding an optimal threshold to generate consistent binary masks can be challenging.</p></caption><graphic mime-subtype="tiff" mimetype="image" xlink:href="elife-38173-fig3-figsupp1-v1.tif"/></fig></fig-group><p><bold>Consistency</bold>: The datasets are annotated using exactly the same procedure (see Materials and methods), and in all datasets the goal is to detect only active cells. In contrast, the annotation of the various <sc>Neurofinder</sc> datasets is performed either manually or automatically by segmenting an image of a static (structural) indicator. Even though structural indicators could be used for ground truth extraction, the segmentation of such images is not a straightforward problem in the case of dense expression, and the stochastic expression of indicators can lead to mismatches between functional and structural indicators.</p><p><bold>Uncertainty quantification</bold>: By employing more than one human labeler we discovered a surprising level of disagreement between different annotators (see <xref ref-type="table" rid="table1">Table 1</xref>, <xref ref-type="fig" rid="fig3">Figure 3b</xref> for details). This result indicates that individual annotations can be unreliable for benchmarking purposes and that unreproducible scientific results might ensue. The combination of the various annotations leads to more reliable set of labels and also quantifies the limits of human performance.</p><table-wrap id="table1" position="float"><object-id pub-id-type="doi">10.7554/eLife.38173.007</object-id><label>Table 1.</label><caption><title>Results of each labeler, C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> and C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> algorithms against consensus annotation.</title><p>Results are given in the form <inline-formula><mml:math id="inf8"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mtable columnalign="left left" columnspacing="1em" rowspacing="4pt"><mml:mtr><mml:mtd><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mtext> score</mml:mtext></mml:mtd><mml:mtd><mml:mi mathvariant="normal">#</mml:mi><mml:mtext>\ of\ active\ neurons</mml:mtext></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo stretchy="false">(</mml:mo><mml:mtext>precision,</mml:mtext></mml:mtd><mml:mtd><mml:mtext>recall</mml:mtext><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mstyle></mml:math></inline-formula>, and empty entries correspond to datasets not manually annotated by the specific labeler. The number of frames for each dataset, as well as the number of neurons that each labeler and algorithm found are also given. In <italic>italics</italic> the datasets used to train the CNN classifiers.</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Name <break/># of frames</th><th align="center">L1</th><th align="center">L2</th><th align="center">L3</th><th align="center">L4</th><th align="center"> C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc></th><th> C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc></th></tr></thead><tbody><tr><td><italic>N.01.01</italic> <break/>1825</td><td align="center">0.80 241(0.95, 0.69)⁢⁢</td><td align="center">⁢0.89 287(0.96, 0.83)⁢</td><td align="center">0.78 386(0.73, 0.84)⁢</td><td align="center">0.75 289(0.80, 0.70)⁢</td><td align="center">0.76 317(0.76, 0.77)⁢</td><td>0.75 298⁢(0.81, 0.70)⁢</td></tr><tr><td><italic>N.03.00.t</italic> <break/>2250</td><td align="center">X</td><td align="center">0.90 188(0.88, 0.92)⁢</td><td align="center">0.85 215⁢(0.78, 0.93)</td><td align="center">0.78 206(0.73, 0.83)⁢</td><td align="center">0.78 154(0.76, 0.80)</td><td>0.74 150(0.79, 0.70)</td></tr><tr><td><italic>N.00.00</italic> <break/>2936</td><td align="center">X</td><td align="center">0.92 425(0.93, 0.91)⁢</td><td align="center">⁢0.83 402(0.86, 0.80)⁢</td><td align="center">0.87 358(0.96, 0.80)⁢</td><td align="center">0.72 366(0.79, 0.67)⁢</td><td>0.69 259(0.87, 0.58)⁢</td></tr><tr><td>YST <break/>3000</td><td align="center">⁢0.78 431(0.76, 0.81)</td><td align="center">0.90 465(0.85, 0.97)⁢</td><td align="center">0.82 505(0.75, 0.92)</td><td align="center">0.79 285(0.96, 0.67)⁢</td><td align="center">0.77 332(0.85, 0.70)⁢</td><td>0.77 330(0.84, 0.70)⁢</td></tr><tr><td>N.04.00.t <break/>3000</td><td align="center">X</td><td align="center">0.69 471(0.54, 0.97)⁢</td><td align="center">0.75 411(0.61, 0.97)⁢</td><td align="center">0.87 326(0.78, 0.98)⁢</td><td align="center">0.69 218(0.69, 0.70)⁢</td><td>0.7 260(0.68, 0.72)</td></tr><tr><td>N.02.00 <break/>8000</td><td align="center">0.89 430(0.86, 0.93)</td><td align="center">0.87 382(0.88, 0.85)⁢</td><td align="center">0.84 332(0.92, 0.77)⁢</td><td align="center">0.82 278(1.00, 0.70)⁢</td><td align="center">0.78 351(0.78, 0.78)⁢</td><td>0.78 334(0.85, 0.73)⁢</td></tr><tr><td>J123 <break/>41000</td><td align="center">X</td><td align="center">0.83 241(0.73, 0.96)⁢</td><td align="center">0.90 181(0.91, 0.90)</td><td align="center">0.91 177(0.92, 0.89)⁢</td><td align="center">0.73 157(0.88, 0.63)⁢</td><td>0.82 172(0.85, 0.80)⁢</td></tr><tr><td>J115 <break/>90000</td><td align="center">⁢0.85 708(0.96, 0.76)</td><td align="center">0.93 869(0.94, 0.91)</td><td align="center">0.94 880(0.95, 0.93)⁢</td><td align="center">0.83 635(1.00, 0.71)⁢</td><td align="center">0.78 738(0.87, 0.71)⁢</td><td>⁢0.79 1091(0.71, 0.89)</td></tr><tr><td>K53 <break/>116043</td><td align="center">0.89 795(0.96, 0.83)⁢</td><td align="center">0.92 928(0.92, 0.92)⁢</td><td align="center">0.93 875(0.95, 0.91)</td><td align="center">0.83 664(1.00, 0.72)⁢</td><td align="center">0.76 809(0.80, 0.72)⁢</td><td>0.81 1025(0.77, 0.87)⁢</td></tr><tr><td>mean ± std</td><td align="center">0.84±0.05(0.9±0.08, 0.8±0.08)</td><td align="center">0.87±0.07(0.85±0.13, 0.92±0.05)</td><td align="center">0.85±0.06(0.83±0.11, 0.88±0.06)⁢</td><td align="center">0.83±0.09(0.91±0.1, 0.78±0.1)⁢</td><td align="center">0.754±0.03(0.8±0.06, 0.72±0.05)⁢</td><td>⁢0.762±0.05(0.82±0.06, 0.73±0.1)</td></tr></tbody></table></table-wrap></sec><sec id="s1-4-7-2"><title>Comparing C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> against manual annotations</title><p>To compare C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> against the consensus annotation, the manual annotations were used as binary masks to construct the consensus spatial and temporal components, using the <sc>SeededInitialization</sc> procedure (Algorithm 3) of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc>. This step is necessary to adapt the manual annotations to the shapes of the actual spatial footprints of each neuron in the FOV (<xref ref-type="fig" rid="fig3s1">Figure 3—figure supplement 1</xref>), as manual annotations primarily produced elliptical shapes. The set of spatial footprints obtained from C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> is registered against the set of consensus spatial footprints (derived as described above) using our component registration algorithm <sc>RegisterPair</sc> (Algorithm 7). Performance is then quantified using a precision/recall framework similar to other studies (<xref ref-type="bibr" rid="bib2">Apthorpe et al., 2016</xref>; <xref ref-type="bibr" rid="bib17">Giovannucci et al., 2017</xref>).</p></sec></sec><sec id="s1-4-8"><title>Software</title><p>C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> is developed by and for the community. Python open source code for the above-described methods is available at <ext-link ext-link-type="uri" xlink:href="https://github.com/flatironinstitute/CaImAn">https://github.com/flatironinstitute/CaImAn</ext-link> (<xref ref-type="bibr" rid="bib18">Giovannucci et al., 2018</xref>; copy archived at <ext-link ext-link-type="uri" xlink:href="https://github.com/elifesciences-publications/CaImAn">https://github.com/elifesciences-publications/CaImAn</ext-link>). The repository contains documentation, several demos, and Jupyter notebook tutorials, as well as visualization tools, and a message/discussion board. The code, which is compatible with Python 3, uses several open-source libraries, such as OpenCV (<xref ref-type="bibr" rid="bib6">Bradski, 2000</xref>), scikit-learn (<xref ref-type="bibr" rid="bib29">Pedregosa et al., 2011</xref>), and scikit-image (<xref ref-type="bibr" rid="bib47">van der Walt et al., 2014</xref>). Most routines are also available in MATLAB at <ext-link ext-link-type="uri" xlink:href="https://github.com/flatironinstitute/CaImAn-MATLAB">https://github.com/flatironinstitute/CaImAn-MATLAB</ext-link> (<xref ref-type="bibr" rid="bib36">Pnevmatikakis et al., 2018</xref>; copy archived at <ext-link ext-link-type="uri" xlink:href="https://github.com/elifesciences-publications/CaImAn-MATLAB">https://github.com/elifesciences-publications/CaImAn-MATLAB</ext-link>). We provide tips for efficient data analysis at <ext-link ext-link-type="uri" xlink:href="https://github.com/flatironinstitute/CaImAn/wiki/CaImAn-Tips">https://github.com/flatironinstitute/CaImAn/wiki/CaImAn-Tips</ext-link>. All the annotated datasets together with the individual and consensus annotation are available at <ext-link ext-link-type="uri" xlink:href="https://users.flatironinstitute.org/~neuro/caiman_paper">https://users.flatironinstitute.org/~neuro/caiman_paper</ext-link>. All the material is also available from the Zenodo repository at <ext-link ext-link-type="uri" xlink:href="https://zenodo.org/record/1659149/export/hx#.XC_Rms9Ki9t">https://zenodo.org/record/1659149/export/hx#.XC_Rms9Ki9t</ext-link></p></sec></sec></sec><sec id="s2" sec-type="results"><title>Results</title><sec id="s2-1"><title>Manual annotations show a high degree of variability</title><p>We compared the performance of each human annotator against a consensus annotation. The performance was quantified with a precision/recall framework and the results of the performance of each individual labeler against the consensus annotation for each dataset is given in <xref ref-type="table" rid="table1">Table 1</xref>. The range of human performance in terms of <inline-formula><mml:math id="inf9"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> score was 0.69–0.94. All annotators performed similarly on average (0.84 <inline-formula><mml:math id="inf10"><mml:mo>±</mml:mo></mml:math></inline-formula> 0.05, 0.87 <inline-formula><mml:math id="inf11"><mml:mo>±</mml:mo></mml:math></inline-formula> 0.07, 0.85 <inline-formula><mml:math id="inf12"><mml:mo>±</mml:mo></mml:math></inline-formula> 0.06, 0.83 <inline-formula><mml:math id="inf13"><mml:mo>±</mml:mo></mml:math></inline-formula> 0.08). We also ensured that the performance of labelers was stable across time (i.e. their learning curve plateaued, data not shown). As shown in <xref ref-type="table" rid="table1">Table 1</xref> (see also <xref ref-type="fig" rid="fig4">Figure 4b</xref>) the <inline-formula><mml:math id="inf14"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> score was never 1, and in most cases it was less or equal to 0.9, demonstrating significant variability between annotators. <xref ref-type="fig" rid="fig3">Figure 3</xref> (bottom) shows an example of matches and mismatches between individual labelers and consensus annotation for dataset K53, where the level of agreement was relatively high. The high degree of variability between human responses indicates the challenging nature of the source extraction problem and raises reproducibility concerns in studies relying heavily on manual ROI selection.</p><fig-group><fig id="fig4" position="float"><object-id pub-id-type="doi">10.7554/eLife.38173.008</object-id><label>Figure 4.</label><caption><title>Evaluation of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> performance against manually annotated data.</title><p>(<bold>a</bold>) Comparison of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> (top) and C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> (bottom) when benchmarked against consensus annotation for dataset K53. For a portion of the FOV, correlation image overlaid with matches (left panels, red: consensus, yellow: C<sc>a</sc>I<sc>m</sc>A<sc>n</sc>) and mismatches (right panels, red: false negatives, yellow: false positives). (<bold>b</bold>) Performance of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc>, and C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> vs average human performance (blue). For each algorithm the results with both the same parameters for each dataset and with the optimized per dataset parameters are shown. C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> and C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> reach near-human accuracy for neuron detection. Complete results with precision and recall for each dataset are given in <xref ref-type="table" rid="table1">Table 1</xref>. (<bold>c–e</bold>) Performance of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> increases with peak SNR. (<bold>c</bold>) Example of scatter plot between SNRs of matched traces between C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> and consensus annotation for dataset K53. False negative/positive pairs are plotted in green along the x- and y-axes respectively, perturbed as a point cloud to illustrate the density. Most false positive/negative predictions occur at low SNR values. Shaded areas represent thresholds above which components are considered for matching (blue for C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> and red for consensus selected components) (<bold>d</bold>) <inline-formula><mml:math id="inf15"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> score and upper/lower bounds of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> for all datasets as a function of various peak SNR thresholds. Performance of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> increases significantly for neurons with high peak SNR traces (see text for definition of metrics and the bounds). (<bold>e</bold>) Precision and recall of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> as a function of peak SNR for all datasets. The same trend is observed for both precision and recall.</p></caption><graphic mime-subtype="tiff" mimetype="image" xlink:href="elife-38173-fig4-v1.tif"/></fig><fig id="fig4s1" position="float" specific-use="child-fig"><object-id pub-id-type="doi">10.7554/eLife.38173.009</object-id><label>Figure 4—figure supplement 1.</label><caption><title>Performance of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> over different choices of parameters.</title><p>Performance of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> over different choices of three parameters: <inline-formula><mml:math id="inf16"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>θ</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mspace width="thinmathspace"/><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi><mml:mspace width="thinmathspace"/><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">h</mml:mi><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">h</mml:mi><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">l</mml:mi><mml:mi mathvariant="normal">d</mml:mi><mml:mo>,</mml:mo><mml:mspace width="thinmathspace"/><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mspace width="thinmathspace"/><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">h</mml:mi><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">h</mml:mi><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">l</mml:mi><mml:mi mathvariant="normal">d</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:mi mathvariant="normal">#</mml:mi><mml:mrow><mml:mspace width="thinmathspace"/><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">f</mml:mi><mml:mspace width="thinmathspace"/><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">d</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">d</mml:mi><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mspace width="thinmathspace"/><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">p</mml:mi><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">s</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula> scores (top), Precision (middle) and Recall (bottom) are shown for all labeled datasets for four different cases: low threshold/large number setting (red) where <inline-formula><mml:math id="inf17"><mml:mrow><mml:mi>θ</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1.2</mml:mn><mml:mo>,</mml:mo><mml:mn>0.65</mml:mn><mml:mo>,</mml:mo><mml:mn>10</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, high threshold/low number setting where <inline-formula><mml:math id="inf18"><mml:mrow><mml:mi>θ</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>0.6</mml:mn><mml:mo>,</mml:mo><mml:mn>5</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, and setting that maximizes performance averaged over all datasets (green) <inline-formula><mml:math id="inf19"><mml:mrow><mml:mi>θ</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1.2</mml:mn><mml:mo>,</mml:mo><mml:mn>0.65</mml:mn><mml:mo>,</mml:mo><mml:mn>10</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. The maximum <inline-formula><mml:math id="inf20"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> score (and corresponding precision/recall) for each dataset is also shown (magenta). Lower threshold settings are more desirable for shorter datasets (N.03.00.t, N.04.00.t, N.00.00, N.01.01, YST) because they achieve high recall rates without a big penalty in precision. On the contrary, higher threshold settings are more desirable for longer datasets (J115, J123, K53) because they achieve high precision without a big penalty in recall.</p></caption><graphic mime-subtype="tiff" mimetype="image" xlink:href="elife-38173-fig4-figsupp1-v1.tif"/></fig><fig id="fig4s2" position="float" specific-use="child-fig"><object-id pub-id-type="doi">10.7554/eLife.38173.010</object-id><label>Figure 4—figure supplement 2.</label><caption><title>C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> outperforms the Suite2p algorithm in all datasets when benchmarked against the consensus annotation.</title><p>(<bold>a</bold>) Contour plots of selected components against consensus annotation (CA) for (left) and Suite2p with the use of a classifier (middle) and direct comparison between the algorithms (right) for the test dataset N.00.00. identifies better components with a weak footprint in the summary correlation image. (<bold>b</bold>) Performance metrics <inline-formula><mml:math id="inf21"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> score (top), precision (middle) and recall (bottom), for Suite2p (with and the without the use of the classifier) and for the eight test datasets. consistently outperforms Suite2p, which can have significant variations between precision and recall. See Materials and methods (<italic>Comparison with Suite2p</italic>) for more details on the comparison.</p></caption><graphic mime-subtype="tiff" mimetype="image" xlink:href="elife-38173-fig4-figsupp2-v1.tif"/></fig></fig-group><p>This process may have generated slightly biased results in favor of each individual annotator as the consensus annotation is always a subset of the union of the individual annotations. We also used an alternative cross-validation approach, where the labels of each annotator were compared with the combined results of the remaining annotators. The combination was constructed using a majority vote when a dataset was labeled from 4 annotators, or an intersection of selections when a dataset was labeled by 3. The results (see Table 3 in Materials and methods) indicate an even higher level of disagreement between the annotators with lower average <inline-formula><mml:math id="inf22"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> score 0.82 <inline-formula><mml:math id="inf23"><mml:mo>±</mml:mo></mml:math></inline-formula> 0.06 (mean <inline-formula><mml:math id="inf24"><mml:mo>±</mml:mo></mml:math></inline-formula> STD) and range of values <inline-formula><mml:math id="inf25"><mml:mrow><mml:mn>0.68</mml:mn><mml:mo>-</mml:mo><mml:mn>0.90</mml:mn></mml:mrow></mml:math></inline-formula>. More details are given in Materials and methods (Cross-Validation analysis of manual annotations).</p></sec><sec id="s2-2"><title>C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> and C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> detect neurons with near-human accuracy</title><p>We first benchmarked C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> and C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> against consensus annotation for the task of identifying neurons locations and their spatial footprints, using the same precision recall framework (<xref ref-type="table" rid="table1">Table 1</xref>). <xref ref-type="fig" rid="fig4">Figure 4a</xref> shows an example dataset (K53) along with neuron-wise matches and mismatches between C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> vs consensus annotation (top) and C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> vs consensus annotation (bottom).</p><p>The results indicate a similar performance between C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> and C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc>; C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> has <inline-formula><mml:math id="inf26"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> scores in the range 0.69–0.78 and average performance 0.75 <inline-formula><mml:math id="inf27"><mml:mo>±</mml:mo></mml:math></inline-formula> 0.03 (mean <inline-formula><mml:math id="inf28"><mml:mo>±</mml:mo></mml:math></inline-formula> STD). On the other hand C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> had <inline-formula><mml:math id="inf29"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> scores in the range 0.70–0.82 and average performance 0.76 <inline-formula><mml:math id="inf30"><mml:mo>±</mml:mo></mml:math></inline-formula> 0.05. While the two algorithms performed similarly on average, C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> tends to perform better for longer datasets (e.g., datasets J115, J123, K53 that all have more than 40000 frames; see also <xref ref-type="table" rid="table2">Table 2</xref> for characteristics of the various datasets). C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> operates on the entire dataset at once, representing each spatial footprint with a constant in time vector. In contrast, C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> operates at a local level looking at a short window over time to detect new components, while adaptively changing their spatial footprint based on new data. This enables C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> to adapt to slow non-stationarities that can appear in long experiments.</p><table-wrap id="table2" position="float"><object-id pub-id-type="doi">10.7554/eLife.38173.011</object-id><label>Table 2.</label><caption><title>Properties of manually annotated datasets.</title><p>For each dataset the duration, imaging rate and calcium indicator are given, as well as the number of active neurons selected after consensus between the manual annotators.</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Name</th><th>Area brain</th><th>Lab</th><th>Rate (Hz)</th><th>Size (T<inline-formula><mml:math id="inf31"><mml:mo>×</mml:mo></mml:math></inline-formula>X<inline-formula><mml:math id="inf32"><mml:mo>×</mml:mo></mml:math></inline-formula>Y)</th><th>Indicator</th><th><inline-formula><mml:math id="inf33"><mml:mi mathvariant="normal">#</mml:mi></mml:math></inline-formula>Labelers</th><th><inline-formula><mml:math id="inf34"><mml:mi mathvariant="normal">#</mml:mi></mml:math></inline-formula>Neurons CA</th></tr></thead><tbody><tr><td>NF.01.01</td><td>Visual Cortex</td><td>Hausser</td><td>7</td><td>1825 × 512 × 512</td><td>GCaMP6s</td><td>4</td><td>333</td></tr><tr><td>NF.03.00.t</td><td>Hippocampus</td><td>Losonczy</td><td>7</td><td>2250 × 498 × 467</td><td>GCaMP6f</td><td>3</td><td>178</td></tr><tr><td>NF.00.00</td><td>Cortex</td><td>Svoboda</td><td>7</td><td>2936 × 512 × 512</td><td>GCaMP6s</td><td>3</td><td>425</td></tr><tr><td>YST</td><td>Visual Cortex</td><td>Yuste</td><td>10</td><td>3000 × 200 × 256</td><td>GCaMP3</td><td>4</td><td>405</td></tr><tr><td>NF.04.00.t</td><td>Cortex</td><td>Harvey</td><td>7</td><td>3000 × 512 × 512</td><td>GCaMP6s</td><td>3</td><td>257</td></tr><tr><td>NF.02.00</td><td>Cortex</td><td>Svoboda</td><td>30</td><td>8000 × 512 × 512</td><td>GCaMP6s</td><td>4</td><td>394</td></tr><tr><td>J123</td><td>Hippocampus</td><td>Tank</td><td>30</td><td>41000 × 458 × 477</td><td>GCaMP5</td><td>3</td><td>183</td></tr><tr><td>J115</td><td>Hippocampus</td><td>Tank</td><td>30</td><td>90000 × 463 × 472</td><td>GCaMP5</td><td>4</td><td>891</td></tr><tr><td>K53</td><td>Parietal Cortex</td><td>Tank</td><td>30</td><td>116043 × 512 × 512</td><td>GCaMP6f</td><td>4</td><td>920</td></tr></tbody></table></table-wrap><p>C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> approaches but is in most cases below the accuracy levels of human annotators (<xref ref-type="fig" rid="fig4">Figure 4b</xref>). We attribute this to two primary factors: First, CNMF detects active components regardless of their shape, and can detect non-somatic structures with significant transients. While non-somatic components can be filtered out to some extent using the CNN classifier, their existence degrades performance compared to the manual annotations that consist only of neurons. Second, to demonstrate the generality and ease of use of our tools, the results presented here are obtained by running C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> and C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> with <italic>exactly</italic> the same parameters for each dataset (see Materials and methods (Implementation details)): fine-tuning to each individual dataset can significantly increase performance (<xref ref-type="fig" rid="fig4">Figure 4b</xref>).</p><p>To test the later point we measured the performance of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> on the nine datasets, as a function of 3 parameters: (i) the trace SNR threshold for testing the traces of candidate components, (ii) the CNN threshold for testing the shapes of candidate components, and (iii) the number of candidate components to be tested at each frame (more details can be found in Materials and methods (Implementation details for C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc>)). By choosing a parameter combination that maximizes the value for each dataset, the performance generally increases across the datasets with <inline-formula><mml:math id="inf35"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> scores in the range 0.72–0.85 and average performance <inline-formula><mml:math id="inf36"><mml:mrow><mml:mn>0.78</mml:mn><mml:mo>±</mml:mo><mml:mn>0.05</mml:mn></mml:mrow></mml:math></inline-formula> (see <xref ref-type="fig" rid="fig4">Figure 4</xref> (orange) and <xref ref-type="fig" rid="fig4s1">Figure 4—figure supplement 1</xref> (magenta)). This analysis also shows that in general a strategy of testing a large number of components per timestep but with stricter criteria, achieves better results than testing fewer components with looser criteria (at the expense of increased computational cost). The results also indicate different strategies for parameter choice depending on the length of a dataset: Lower threshold values and/or larger number of candidate components (<xref ref-type="fig" rid="fig4s1">Figure 4—figure supplement 1</xref> (red)), lead to better values for shorter datasets, but can decrease precision and overall performance for longer datasets. The opposite also holds for higher threshold values and/or smaller number of candidate components (<xref ref-type="fig" rid="fig4s1">Figure 4—figure supplement 1</xref> (blue)), where C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> for shorter datasets can suffer from lower recall values, whereas in longer datasets C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> can add neurons over a longer period of time while maintaining high precision values and thus achieve better performance. A similar grid search was also performed for the C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> algorithm where four parameters of the component evaluation step (space correlation, trace SNR, min/max CNN thresholds) were optimized individually to filter out false positives. This procedure led to <inline-formula><mml:math id="inf37"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> scores in in the range 0.71–0.81 and average performance <inline-formula><mml:math id="inf38"><mml:mrow><mml:mn>0.774</mml:mn><mml:mo>±</mml:mo><mml:mn>0.034</mml:mn></mml:mrow></mml:math></inline-formula> (<xref ref-type="fig" rid="fig4">Figure 4</xref> (red)).</p><p>We also compared the performance of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> against Suite2p (<xref ref-type="bibr" rid="bib27">Pachitariu et al., 2017</xref>), another popular calcium imaging data analysis package. By using a small grid search around some default parameters of Suite2p we extracted the set of parameters that worked better in the eight datasets where the algorithm converged (in the dataset J123 Suite2p did not converge). C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> outperformed Suite2p in all datasets with the latter obtaining <inline-formula><mml:math id="inf39"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> scores in the range 0.41–0.75, with average performance <inline-formula><mml:math id="inf40"><mml:mrow><mml:mn>0.55</mml:mn><mml:mo>±</mml:mo><mml:mn>0.12</mml:mn></mml:mrow></mml:math></inline-formula>. More details about the comparison are shown in <xref ref-type="fig" rid="fig4s2">Figure 4—figure supplement 2</xref> and Materials and methods (Comparison with Suite2p).</p><sec id="s2-2-1"><title>Neurons with higher SNR transients are detected more accurately</title><p>For the parameters that yielded on average the best results (see <xref ref-type="table" rid="table1">Table 1</xref>), both C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> and C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> exhibited higher precision than recall (<inline-formula><mml:math id="inf41"><mml:mrow><mml:mn>0.8</mml:mn><mml:mo>±</mml:mo><mml:mn>0.06</mml:mn></mml:mrow></mml:math></inline-formula> vs <inline-formula><mml:math id="inf42"><mml:mrow><mml:mn>0.72</mml:mn><mml:mo>±</mml:mo><mml:mn>0.05</mml:mn></mml:mrow></mml:math></inline-formula> for C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc>, and <inline-formula><mml:math id="inf43"><mml:mrow><mml:mn>0.82</mml:mn><mml:mo>±</mml:mo><mml:mn>0.06</mml:mn></mml:mrow></mml:math></inline-formula> vs <inline-formula><mml:math id="inf44"><mml:mrow><mml:mn>0.73</mml:mn><mml:mo>±</mml:mo><mml:mn>0.1</mml:mn></mml:mrow></mml:math></inline-formula> for C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc>, respectively). This can be partially explained by the component evaluation steps at the end of patch processing (<xref ref-type="fig" rid="fig1">Figure 1e</xref>) for C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> (and the end of each frame for C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc>) which aim to filter out false positive components, thus increasing precision while leaving recall intact (or in fact lowering it in case where true positive components are filtered out). To better understand this behavior, we analyzed the C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> performance as a function of the SNR of the inferred and consensus traces (<xref ref-type="fig" rid="fig4">Figure 4c–e</xref>). The SNR measure of a trace corresponds to the peak-SNR averaged over the length of a typical trace (see Materials and methods (Detecting fluorescence traces with high SNR)). An example is shown in <xref ref-type="fig" rid="fig4">Figure 4c</xref> where the scatter plot of SNR between matched consensus and inferred traces is shown (false negative/positive components are shown along the x- and y- axis, respectively). To evaluate the performance we computed a precision metric as the fraction of inferred components above a certain SNR threshold that are matched with a consensus component (<xref ref-type="fig" rid="fig4">Figure 4c</xref>, shaded blue). Similarly we computed a recall metric as the fraction of consensus components above a SNR threshold that are detected by C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> (<xref ref-type="fig" rid="fig4">Figure 4c</xref>, shaded red), and an <inline-formula><mml:math id="inf45"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> score as the harmonic mean of the two (<xref ref-type="fig" rid="fig4">Figure 4d</xref>). The results indicate that the performance significantly improves as a function of the SNR for all datasets considered, improving on average from 0.73 when all neurons are considered to 0.92 when only neurons with traces having SNR <inline-formula><mml:math id="inf46"><mml:mrow><mml:mi/><mml:mo>≥</mml:mo><mml:mn>9</mml:mn></mml:mrow></mml:math></inline-formula> are considered (<xref ref-type="fig" rid="fig4">Figure 4d</xref>). This increase in the <inline-formula><mml:math id="inf47"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> score resulted increase in both the precision and the recall as a function of the SNR (<xref ref-type="fig" rid="fig4">Figure 4e</xref>)(these precision and recall metrics are computed on different sets of neurons, and therefore strictly speaking one cannot combine them to form an <inline-formula><mml:math id="inf48"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> score. However, they can be bound from above by being evaluated on the set of matched and non-matched components where at least one trace is above the threshold (union of blue and pink zones in <xref ref-type="fig" rid="fig4">Figure 4c</xref>) or below by considering only matched and non-matched components where both consensus and inferred traces have SNR above the threshold (intersection of blue and pink zones in <xref ref-type="fig" rid="fig4">Figure 4c</xref>). In practice these bounds were very tight for all but one dataset (<xref ref-type="fig" rid="fig4">Figure 4d</xref>). More details can be found in Materials and methods (Performance quantification as a function of SNR)). A similar trend is also observed for C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> (data not shown).</p></sec></sec><sec id="s2-3"><title>C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> reproduces the consensus traces with high fidelity</title><p>Testing the quality of the inferred traces is more challenging due to the unavailability of ground truth data in the context of large scale in vivo recordings. As mentioned above, we defined as ‘ground truth’ the traces obtained by running the CNMF algorithm seeded with the binary masks obtained by consensus annotation procedure. After spatial alignment with the results of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> , the matched traces were compared both for C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> and for C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc>. <xref ref-type="fig" rid="fig5">Figure 5a</xref>, shows an example of 5 of these traces for the dataset K53, showing very similar behavior of the traces in these three different cases.</p><fig id="fig5" position="float"><object-id pub-id-type="doi">10.7554/eLife.38173.012</object-id><label>Figure 5.</label><caption><title>Evaluation of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> extracted traces against traces derived from consensus annotation.</title><p>(<bold>a</bold>) Examples of shapes (left) and traces (right) are shown for five matched components extracted from dataset K53 for consensus annotation (CA, black), C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> (yellow) and C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> (red) algorithms. The dashed gray portion of the traces is also shown magnified (bottom-right). Consensus spatial footprints and traces were obtained by seeding C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> with the consensus binary masks. The traces extracted from both versions of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> match closely the consensus traces. (<bold>b</bold>) Slope graph for the average correlation coefficient for matches between consensus and C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc>, and between consensus and C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc>. Batch processing produces traces that match more closely the traces extracted from the consensus labels. (<bold>c</bold>) Empirical cumulative distribution functions of correlation coefficients aggregated over all the tested datasets. Both distributions exhibit a sharp derivative close to 1 (last bin), with the batch approach giving better results.</p></caption><graphic mime-subtype="tiff" mimetype="image" xlink:href="elife-38173-fig5-v1.tif"/></fig><p>To quantify the similarity we computed the correlation coefficients of the traces (consensus vs C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc>, and consensus vs C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc>) for all the nine datasets (<xref ref-type="fig" rid="fig5">Figure 5b–c</xref>). Results indicated that for all but one dataset (<xref ref-type="fig" rid="fig5">Figure 5b</xref>) C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>reproduced the traces with higher fidelity, and in all cases the mean correlation coefficients was higher than 0.9, and the empirical histogram of correlation coefficients peaked at the maximum bin 0.99–1 (<xref ref-type="fig" rid="fig5">Figure 5c</xref>). The results indicate that the batch approach extracts traces closer to the consensus traces. This can be attributed to a number of reasons: By processing all the time points simultaneously, the batch approach can smooth the trace estimation over the entire time interval as opposed to the online approach where at each timestep only the information up to that point is considered. Moreover, C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> might not detect a neuron until it becomes strongly active. This neuron’s activity before detection is unknown and has a default value of zero, resulting in a lower correlation coefficient. While this can be ameliorated to a great extent with additional passes over the data, the results indicate the trade-offs inherent between online and batch algorithms.</p></sec><sec id="s2-4"><title>Online analysis of a whole brain zebrafish dataset</title><p>We tested C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> with a 380 GB whole brain dataset of larval zebrafish (<italic>Danio rerio</italic>) acquired with a light-sheet microscope (<xref ref-type="bibr" rid="bib22">Kawashima et al., 2016</xref>). The imaged transgenic fish (Tg(elavl3:H2B-GCaMP6f)jf7) expressed the genetically encoded calcium indicator GCaMP6f in almost all neuronal nuclei. Data from 45 planes (FOV 820 × 410 <inline-formula><mml:math id="inf49"><mml:mi>μ</mml:mi></mml:math></inline-formula>m<inline-formula><mml:math id="inf50"><mml:msup><mml:mi/><mml:mn>2</mml:mn></mml:msup></mml:math></inline-formula>, spaced at 5.5 <inline-formula><mml:math id="inf51"><mml:mi>μ</mml:mi></mml:math></inline-formula>m intervals along the dorso-ventral axis) was collected at 1 Hz for 30 min (for details about preparation, equipment and experiment refer to <xref ref-type="bibr" rid="bib22">Kawashima et al. (2016)</xref>). With the goal of simulating real-time analysis of the data, we run all the 45 planes in parallel on a computing cluster with nine nodes (each node is equipped with 24 CPUs and 128–256 GB RAM, Linux CentoOS). Data was not stored locally in each machine but directly accessed from a network drive.</p><p>The algorithm was initialized with C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>run on 200 initial frames and looking for 500 components. The small number of frames (1885) and the large FOV size (<inline-formula><mml:math id="inf52"><mml:mrow><mml:mn>2048</mml:mn><mml:mo>×</mml:mo><mml:mn>1188</mml:mn></mml:mrow></mml:math></inline-formula> pixels) for this dataset motivated this choice of increased number of components during initialization. In <xref ref-type="fig" rid="fig6">Figure 6</xref> we report the results of the analysis for plane number 11 of 45. For plane 11, C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> found 1524 neurons after processing 1685 frames. Since no ground truth was available for this dataset, it was only possible to evaluate the performance of this algorithm by visual inspection. C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> identified all the neurons with a clear footprint in the underlying correlation image (higher SNR, <xref ref-type="fig" rid="fig6">Figure 6a</xref>) and missed a small number of the fainter ones (low SNR). By visual inspection of the components the authors could find very few false positives. Given that the parameters were not tuned and that the classifier was not trained on zebrafish neurons, we hypothesize that the algorithm is biased towards a high precision result. Spatial components displayed the expected morphological features of neurons (<xref ref-type="fig" rid="fig6">Figure 6b–c</xref>). Considering all the planes (<xref ref-type="fig" rid="fig6">Figure 6e</xref> and <xref ref-type="fig" rid="fig6s1">Figure 6—figure supplement 1</xref>) C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> was able to identify in a single pass of the data a total of 66108 neurons. See <xref ref-type="video" rid="video1">Video 1</xref> for a summary across all planes. The analysis was performed in 21 min, with the first three minutes spent in initialization, and the remaining 18 in processing the data in streaming mode (and in parallel for each plane). This demonstrates the ability of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> to process large amounts of data in real-time (see also Figure 8 for a discussion of computational performance).</p><fig-group><fig id="fig6" position="float"><object-id pub-id-type="doi">10.7554/eLife.38173.013</object-id><label>Figure 6.</label><caption><title>Online analysis of a 30 min long whole brain recording of the zebrafish brain.</title><p>(<bold>a</bold>) Correlation image overlaid with the spatial components (in red) found by the algorithm (portion of plane 11 out of 45 planes in total). (<bold>b</bold>) Correlation image (left) and mean image (right) for the dashed region in panel (<bold>a</bold>) with superimposed the contours of the neurons marked in (<bold>a</bold>). (<bold>c</bold>) Spatial (left) and temporal (right) components associated to the ten example neurons marked in panel (<bold>a</bold>). (<bold>d</bold>) Temporal traces for all the neurons found in the FOV in (<bold>a</bold>); the initialization on the first 200 frames contained 500 neurons (present since time 0). (<bold>e</bold>) Number of neurons found per plane (See also <xref ref-type="fig" rid="fig6s1">Figure 6—figure supplement 1</xref> for a summary of the results from all planes).</p></caption><graphic mime-subtype="tiff" mimetype="image" xlink:href="elife-38173-fig6-v1.tif"/></fig><fig id="fig6s1" position="float" specific-use="child-fig"><object-id pub-id-type="doi">10.7554/eLife.38173.014</object-id><label>Figure 6—figure supplement 1.</label><caption><title>Spatial and temporal components for all planes.</title><p>Profile of spatial (left) and temporal (right) components found in each plane of the whole brain zebrafish recording. (Left) Components are extracted with C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> and then max-thresholded. (Right) See Results section for a complete discussion. .</p></caption><graphic mime-subtype="tiff" mimetype="image" xlink:href="elife-38173-fig6-figsupp1-v1.tif"/></fig><media id="fig6video1" mime-subtype="mp4" mimetype="video" xlink:href="elife-38173-fig6-video1.mp4"><object-id pub-id-type="doi">10.7554/eLife.38173.015</object-id><label>Figure 6—video 1.</label><caption><title>Results of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> initialized by C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> on a whole brain zebrafish dataset.</title><p>Each panel shows the active neurons in a given plane (top-to-bottom) without any background activity. See the text for more details.</p></caption></media></fig-group><media id="video1" mime-subtype="mp4" mimetype="video" xlink:href="elife-38173-video1.mp4"><object-id pub-id-type="doi">10.7554/eLife.38173.016</object-id><label>Video 1.</label><caption><title>Depiction of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> on a small patch of in vivo cortex data.</title><p>Top left: Raw data. Bottom left: Footprints of identified components. Top right: Mean residual buffer and proposed regions for new components (in white squares). Enclosings of accepted regions are shown in magenta. Several regions are proposed multiple times before getting accepted. This is due to the strict behavior of the classifier to ensure a low number of false positives. Bottom right: Reconstructed activity.</p></caption></media><media id="video2" mime-subtype="mp4" mimetype="video" xlink:href="elife-38173-video2.mp4"><object-id pub-id-type="doi">10.7554/eLife.38173.017</object-id><label>Video 2.</label><caption><title>Depiction of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> on a single plane of mesoscope data courtesy of E. Froudarakis, J. Reimers and A. Tolias (Baylor College of Medicine).</title><p>Top left: Raw data. Top right: Inferred activity (without neuropil). Bottom left: Mean residual buffer and accepted regions for new components (magenta squares). Bottom right: Reconstructed activity.</p></caption></media></sec><sec id="s2-5"><title>Analyzing 1p microendoscopic data using C<sc>a</sc>I<sc>m</sc>A<sc>n</sc></title><p>We tested the CNMF-E implementation of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>on in vivo microendosopic data from mouse dorsal striatum, with neurons expressing GCaMP6f. 6000 frames were acquired at 30 frames per second while the mouse was freely moving in an open field arena (for further details refer to <xref ref-type="bibr" rid="bib52">Zhou et al., 2018</xref>). In <xref ref-type="fig" rid="fig7">Figure 7</xref> we report the results of the analysis using C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>with patches and compare to the results of the MATLAB implementation of <xref ref-type="bibr" rid="bib52">Zhou et al. (2018)</xref>. Both implementations detect similar components (<xref ref-type="fig" rid="fig7">Figure 7a</xref>) with an <inline-formula><mml:math id="inf53"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula>-score of 0.89. 573 neurons were found in common by both implementations. 106 and 31 additional components were detected by <xref ref-type="bibr" rid="bib52">Zhou et al. (2018)</xref> and C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>respectively. The median correlation between the temporal traces of neurons detected by both implementations was 0.86. Similar results were also obtained by running C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc> without patches. Ten example temporal traces are plotted in <xref ref-type="fig" rid="fig7">Figure 7b</xref>.</p><fig id="fig7" position="float"><object-id pub-id-type="doi">10.7554/eLife.38173.018</object-id><label>Figure 7.</label><caption><title>Analyzing microendoscopic 1 p data with the CNMF-E algorithm using C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>.</title><p>(<bold>a</bold>) Contour plots of all neurons detected by the CNMF-E (white) implementation of <xref ref-type="bibr" rid="bib52">Zhou et al. (2018)</xref> and C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>(red) using patches. Colors match the example traces shown in (<bold>b</bold>), which illustrate the temporal components of 10 example neurons detected by both implementations C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>. reproduces with reasonable fidelity the results of <xref ref-type="bibr" rid="bib52">Zhou et al. (2018)</xref>.</p></caption><graphic mime-subtype="tiff" mimetype="image" xlink:href="elife-38173-fig7-v1.tif"/></fig></sec><sec id="s2-6"><title>Computational performance of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc></title><p>We examined the performance of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> in terms of processing time for the various analyzed datasets presented above (<xref ref-type="fig" rid="fig8">Figure 8</xref>). The processing time discussed here excludes motion correction, which is highly efficient and primarily depends on the level of the FOV discretization for non-rigid motion correction (<xref ref-type="bibr" rid="bib34">Pnevmatikakis and Giovannucci, 2017</xref>). For C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>, each dataset was analyzed using three different computing architectures: (i) a single laptop (MacBook Pro) with 8 CPUs (Intel Core i7) and 16 GB of RAM (blue in <xref ref-type="fig" rid="fig8">Figure 8a</xref>), (ii) a linux-based workstation (CentOS) with 24 CPUs (Intel Xeon CPU E5-263 v3 at 3.40 GHz) and 128 GB of RAM (magenta), and (iii) a linux-based HPC cluster (CentOS) where 112 CPUs (Intel Xeon Gold 6148 at 2.40 GHz, four nodes, 28 CPUs each) were allocated for the processing task (yellow). <xref ref-type="fig" rid="fig8">Figure 8a</xref> shows the processing of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>as a function of dataset size on the four longest datasets, whose size exceeded 8 GB, on log-log plot.</p><fig id="fig8" position="float"><object-id pub-id-type="doi">10.7554/eLife.38173.019</object-id><label>Figure 8.</label><caption><title>Time performance of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> and C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> for four of the analyzed datasets (small, medium, large and very large).</title><p>(<bold>a</bold>) Log-log plot of total processing time as a function of data size for C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> two-photon datasets using different processing infrastructures: (i) a desktop with three allocated CPUs (green), (ii) a desktop with 24 CPUs allocated (orange), and (iii) a HPC where 112 CPUs are allocated (blue). The results indicate a near linear scaling of the processing time with the size of dataset, with additional dependence on the number of found neurons (size of each point). Large datasets (<inline-formula><mml:math id="inf54"><mml:mrow><mml:mi/><mml:mo>&gt;</mml:mo><mml:mn>100</mml:mn></mml:mrow></mml:math></inline-formula> GB) can be seamlessly processed with moderately sized desktops or laptops, but access to a HPC enables processing with speeds faster than the acquisition time (considered 30 Hz for a 512<inline-formula><mml:math id="inf55"><mml:mo>×</mml:mo></mml:math></inline-formula>512 FOV here). However, for smaller datasets the advantages of adopting a cluster vanishes, because of the inherent overhead. The results of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> using the laptop, using the ‘strict’ parameter setting (<xref ref-type="fig" rid="fig4s1">Figure 4—figure supplement 1</xref>), are also plotted in red indicating near real-time processing speed. (<bold>b</bold>) Break down of processing time for C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> (excluding motion correction). Processing with CNMF in patches and refinement takes most of the time for C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc>. (<bold>c</bold>) Computational gains for C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> due to parallelization for three datasets with different sizes. The parallelization gains are computed by using the same 24 CPU workstation and utilizing a different number of CPUs for each run. The different parts of the algorithm exhibit the same qualitative characteristics (data not shown). (<bold>d</bold>) Cost analysis of CNMF-E implementation for processing a 6000 frames long 1p dataset. Processing in patches in parallel induces a time/memory tradeoff and can lead to speed gains (patch size in legend). (<bold>e</bold>) Computational cost per frame for analyzing dataset J123 with C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>onlne</sc>. Tracking existing activity and detecting new neurons are the most expensive steps, whereas udpating spatial footprints can be efficiently distributed among all frames. (<bold>f</bold>) Processing speed of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>onlne</sc> for all annotated datasets. Overall speed depends on the number of detected neurons and the size of the FOV (<inline-formula><mml:math id="inf56"><mml:msub><mml:mi>N</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:math></inline-formula> stands for number of pixels). Spatial downsampling can speed up processing. (<bold>g</bold>) Cost of neural activity online tracking for the whole brain zebrafish dataset (maximum time over all planes per volume). Tracking can be done in real-time using parallel processing.</p></caption><graphic mime-subtype="tiff" mimetype="image" xlink:href="elife-38173-fig8-v1.tif"/></fig><p>Results show that, as expected, employing more processing power results in faster processing. C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>on a HPC cluster processes data faster than acquisition time (<xref ref-type="fig" rid="fig8">Figure 8a</xref>) even for very large datasets. Processing of an hour long dataset was feasible within 3 hr on a single laptop, even though the size of the dataset is several times the available RAM. Here, acquisition time is computed based on the assumption of imaging a FOV discretized over a <inline-formula><mml:math id="inf57"><mml:mrow><mml:mn>512</mml:mn><mml:mo>×</mml:mo><mml:mn>512</mml:mn></mml:mrow></mml:math></inline-formula> grid at a 30 Hz rate (a typical two-photon imaging setup with resonant scanning microscopes). Dataset size is computed by representing each measurement using single precision arithmetic, which is the minimum precision required for standard algebraic processing. These assumptions lead to a data rate of <inline-formula><mml:math id="inf58"><mml:mo>∼</mml:mo></mml:math></inline-formula>105 GB/hr. In general performance scales linearly with the number of frames (and hence, the size of the dataset), but we also observe a dependency on the number of components, which during the solution refinement step can be quadratic. This is expected from the properties of the matrix factorization approach as also noted by past studies (<xref ref-type="bibr" rid="bib33">Pnevmatikakis et al., 2016</xref>). The majority of the time (<xref ref-type="fig" rid="fig8">Figure 8b</xref>) required for C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> processing is taken by CNMF algorithmic processing either during the initialization in patches (orange bar) or during merging and refining the results of the individual patches (green bar).</p><p>To study the effects of parallelization we ran C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>several times on the same hardware (linux-based workstation with 24CPUs), limiting the runs to different numbers of CPUs each time (<xref ref-type="fig" rid="fig8">Figure 8c</xref>). In all cases we saw significant performance gains from parallel processing, with the gains being similar for all stages of processing (patch processing, refinement, and quality testing, data not shown). We saw the most effective scaling with our 50 G dataset (J123). For the largest datasets (J115, <inline-formula><mml:math id="inf59"><mml:mrow><mml:mi/><mml:mo>∼</mml:mo><mml:mn>100</mml:mn></mml:mrow></mml:math></inline-formula>GB), the speedup reaches a plateau due to limited available RAM, suggesting that more RAM can lead to better scaling. For small datasets (<inline-formula><mml:math id="inf60"><mml:mrow><mml:mi/><mml:mo>∼</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula> GB) the speedup factor is limited by increased communications overhead (indicative of <italic>weak scaling</italic> in the language of high performance computing).</p><p>The cost of processing 1p data in C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>using the CNMF-E algorithm (<xref ref-type="bibr" rid="bib52">Zhou et al., 2018</xref>) is shown (<xref ref-type="fig" rid="fig8">Figure 8d</xref>) for our workstation-class hardware. Splitting in patches and processing in parallel can lead to computational gains at the expense of increased memory usage. This is because the CNMF-E introduces a background term that has the size of the dataset and needs to be loaded and updated in memory in two copies. This leads to processing times that are slower compared to the standard processing of 2 p datasets, and higher memory requirements. However ( 8 c), memory usage can be controlled enabling scalable inference at the expense of slower processing speeds.</p><p><xref ref-type="fig" rid="fig8">Figure 8a</xref> also shows the performance of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> (red markers). Because of the low memory requirements of the streaming algorithm, this performance only mildly depends on the computing infrastructure, allowing for near real-time processing speeds on a standard laptop (<xref ref-type="fig" rid="fig8">Figure 8a</xref>). As discussed in <xref ref-type="bibr" rid="bib17">Giovannucci et al., 2017</xref> processing time of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> depends primarily on (i) the computational cost of tracking the temporal activity of discovered neurons, (ii) the cost of detecting and incorporating new neurons, and (iii) the cost of periodic updates of spatial footprints. <xref ref-type="fig" rid="fig8">Figure 8e</xref> shows the cost of each of these steps for each frame, for one epoch of processing of the dataset J123. Distributing the spatial footprint update more uniformly among all frames removes the computational bottleneck appearing in <xref ref-type="bibr" rid="bib17">Giovannucci et al., 2017</xref>, where all the footprints where updated periodically at the same frame. The cost of detecting and incorporating new components remains approximately constant across time, and is dependent on the number of candidate components at each timestep. In this example five candidate components were used per frame resulting in a relatively low cost (<inline-formula><mml:math id="inf61"><mml:mo>∼</mml:mo></mml:math></inline-formula>7 ms per frame). A higher number of candidate components can lead to higher recall in shorter datasets but at a computational cost. This step can benefit by the use of a GPU for running the online CNN on the footprints of the candidate components. Finally, as noted in <xref ref-type="bibr" rid="bib17">Giovannucci et al., 2017</xref>, the cost of tracking components can be kept low, and increases mildly over time as more components are found by the algorithm (the analysis here excludes the cost of motion correction, because the files where motion corrected before hand to ensure that manual annotations and the algorithms where operating on the same FOV. This cost depends on whether rigid or pw-rigid motion correction is being used. Rigid motion correction taking on average 3–5 ms per frame for a <inline-formula><mml:math id="inf62"><mml:mrow><mml:mn>512</mml:mn><mml:mo>×</mml:mo><mml:mn>512</mml:mn></mml:mrow></mml:math></inline-formula> pixel FOV, whereas pw-rigid motion correction with patch size <inline-formula><mml:math id="inf63"><mml:mrow><mml:mn>128</mml:mn><mml:mo>×</mml:mo><mml:mn>128</mml:mn></mml:mrow></mml:math></inline-formula> pixel is typically 3–4 times slower).</p><p><xref ref-type="fig" rid="fig8">Figure 8f</xref> shows the overall processing speed (in frames per second) for C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> for the nine annotated datasets. Apart from the number of neurons, the processing speed also depends on the size of the imaged FOV and the use of spatial downsampling. Datasets with smaller FOV (e.g., YST) or datasets where spatial downsampling is used can achieve higher processing speeds for the same amount of neurons (blue dots in <xref ref-type="fig" rid="fig8">Figure 8f</xref>) as opposed to datasets where no spatial downsampling is used (orange dots in <xref ref-type="fig" rid="fig8">Figure 8f</xref>). In most cases, spatial downsampling can be used to increase processing speed without significantly affecting the quality of the results, an observation consistent with previous studies (<xref ref-type="bibr" rid="bib15">Friedrich et al., 2017a</xref>).</p><p>In <xref ref-type="fig" rid="fig8">Figure 8g</xref> the cost per frame is plotted for the analysis of the whole brain zebrafish recording. The lower imaging rate (1 Hz) allows for tracing of neural activity with computational costs significantly lower than the 1 s between volume imaging time (<xref ref-type="fig" rid="fig8">Figure 8e</xref>), even in the presence of a large number of components (typically more than 1000 per plane, <xref ref-type="fig" rid="fig6">Figure 6</xref>) and the significantly larger FOV (<inline-formula><mml:math id="inf64"><mml:mrow><mml:mn>2048</mml:mn><mml:mo>×</mml:mo><mml:mn>1188</mml:mn></mml:mrow></mml:math></inline-formula> pixels).</p></sec><sec id="s2-7"><title>C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> successfully tracks neurons across multiple days</title><p><xref ref-type="fig" rid="fig9">Figure 9</xref> shows an example of tracking neurons across six different sessions corresponding to six different days of mouse cortex in vivo data using our multi-day registration algorithm <sc>RegisterMulti</sc> (see Materials and methods, Algorithm 8). 453, 393, 375, 378, 376, and 373 active components were found in the six sessions, respectively. Our tracking method detected a total of 686 distinct active components. Of these, 172, 108, 70, 92, 82, and 162 appeared in exactly 1, 2, 3, 4, 5, and all six sessions respectively. Contour plots of the 162 components that appeared in all sessions are shown in <xref ref-type="fig" rid="fig9">Figure 9a</xref>, and parts of the FOV are highlighted in <xref ref-type="fig" rid="fig9">Figure 9d</xref> showing that components can be tracked in the presence of non-rigid deformations of the FOV between the different sessions.</p><fig-group><fig id="fig9" position="float"><object-id pub-id-type="doi">10.7554/eLife.38173.020</object-id><label>Figure 9.</label><caption><title>Components registered across six different sessions (days).</title><p>(<bold>a</bold>) Contour plots of neurons that were detected to be active in all six imaging sessions overlaid on the correlation image of the sixth imaging session. Each color corresponds to a different session. (<bold>b</bold>) Stability of multiday registration method. Comparisons of forward and backward registrations in terms of <inline-formula><mml:math id="inf65"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> scores for all possible subsets of sessions. The comparisons agree to a very high level, indicating the stability of the proposed approach. (<bold>c</bold>) Comparison (in terms of <inline-formula><mml:math id="inf66"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> score) of pair-wise alignments using readouts from the union vs direct alignment. The comparison is performed for both the forward and the backwards alignment. For all pairs of sessions the alignment using the proposed method gives very similar results compared to direct pairwise alignment. (<bold>d</bold>) Magnified version of the tracked neurons corresponding to the squares marked in panel (<bold>a</bold>). Neurons in different parts of the FOV exhibit different shift patterns over the course of multiple days, but can nevertheless be tracked accurately by the proposed multiday registration method.</p></caption><graphic mime-subtype="tiff" mimetype="image" xlink:href="elife-38173-fig9-v1.tif"/></fig><fig id="fig9s1" position="float" specific-use="child-fig"><object-id pub-id-type="doi">10.7554/eLife.38173.021</object-id><label>Figure 9—figure supplement 1.</label><caption><title>Tracking neurons across days; step-by-step description of multi session registration.</title><p>(<bold>a</bold>) Correlation image overlaid to contour plots of the neurons identified by in day 1 (top, 453 neurons), 2 (middle, 393 neurons) and 3 (bottom, 375 neurons). (<bold>b</bold>) Result of the pairwise registration between session 1 and 2. The union of distinct active components consists of the components that were active in i) both sessions (yellow - where only the components of session two are displayed), ii) only in session 2 (green), and iii) only in session 1 (red), aligned to the FOV of session 2. (<bold>c</bold>) At the next step the union of sessions 1 and 2 is registered with the results of session three to produce the union of all distinct components aligned to the FOV of session 3. (<bold>d</bold>) Registration of non-consecutive sessions (session 1 vs session 3) without pairwise registration. Keeping track of which session each component was active in enables efficient and stable comparisons.</p></caption><graphic mime-subtype="tiff" mimetype="image" xlink:href="elife-38173-fig9-figsupp1-v1.tif"/></fig></fig-group><p>To test the stability of <sc>RegisterMulti</sc> for each subset of sessions, we repeated the same procedure running backwards in time starting from day 6 and ending at day 1, a process that also generated a total of 686 distinct active components. We identified the components present in <italic>at least</italic> a given subset of sessions when using the forward pass, and separately when using the backwards pass, and compared them against each other (<xref ref-type="fig" rid="fig9">Figure 9b</xref>) for all possible subsets. Results indicate a very high level of agreement between the two approaches with many of the disagreements arising near the boundaries (data not shown). Disagreements near the boundaries can arise because the forward pass aligns the union with the FOV of the last session, whereas the backwards pass with the FOV of the first session, potentially leading to loss of information near the boundaries.</p><p>A step by step demonstration of the tracking algorithm for the first three sessions is shown in <xref ref-type="fig" rid="fig9s1">Figure 9—figure supplement 1</xref>. Our approach allows for the comparison of two non-consecutive sessions through the union of components without the need of a direct pairwise registration (<xref ref-type="fig" rid="fig9s1">Figure 9—figure supplement 1f</xref>), where it is shown that registering sessions 1 and 3 directly and through the union leads to nearly identical results. <xref ref-type="fig" rid="fig9">Figure 9c</xref> compares the registrations for all pairs of sessions using the forward (red) or the backward (blue) approach, with the direct pairwise registrations. Again, the results indicate a very high level of agreement, indicating the stability and effectiveness of the proposed approach.</p><p>A different approach for multiple day registration was recently proposed by <xref ref-type="bibr" rid="bib39">Sheintuch et al. (2017)</xref> (<sc>CellReg</sc>). While a direct comparison of the two methods is not feasible in the absence of ground truth, we tested our method against the same publicly available datasets from the Allen Brain Observatory visual coding database. (<ext-link ext-link-type="uri" xlink:href="http://observatory.brain-map.org/visualcoding">http://observatory.brain-map.org/visualcoding</ext-link>). Similarly to <xref ref-type="bibr" rid="bib39">Sheintuch et al. (2017)</xref> the same experiment performed over the course of different days produced very different populations of active neurons. To measure performance of <sc>RegisterPair</sc> for pairwise registration, we computed the transitivity index proposed in <xref ref-type="bibr" rid="bib39">Sheintuch et al. (2017)</xref>. The transitivity property requires that if cell 'a’ from session one matches with cell 'b’ from session 2, and cell 'b’ from session two matches with cell 'c’ from session 3, then cell 'a’ from session one should match with cell 'c’ from session 3 when sessions 1 and 3 are registered directly. For all ten tested datasets the transitivity index was very high, with values ranging from 0.976 to 1 (<inline-formula><mml:math id="inf67"><mml:mrow><mml:mn>0.992</mml:mn><mml:mo>±</mml:mo><mml:mn>0.006</mml:mn></mml:mrow></mml:math></inline-formula>, data not shown). A discussion between the similarities and differences of the two methods is given in Materials and methods.</p></sec></sec><sec id="s3" sec-type="discussion"><title>Discussion</title><sec id="s3-1"><title>Reproducible and scalable analysis for the 99%</title><p>Significant advances in the reporting fidelity of fluorescent indicators, and the ability to simultaneously record and modulate neurons granted by progress in optical technology, have made calcium imaging one of the two most prominent experimental methods in systems neuroscience alongside electrophysiology recordings. Increasing adoption has led to an unprecedented wealth of imaging data which poses significant analysis challenges. C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> is designed to provide the experimentalist with a complete suite of tools for analyzing this data in a formal, scalable, and reproducible way. The goal of this paper is to present the features of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> and examine its performance in detail. C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> embeds existing methods for preprocessing calcium imaging data into a MapReduce framework and augments them with supervised learning algorithms and validation metrics. It builds on the CNMF algorithm of <xref ref-type="bibr" rid="bib33">Pnevmatikakis et al. (2016)</xref> for source extraction and deconvolution, extending it along the lines of (i) reproducibility and performance improvement, by automating quality assessment through the use of unsupervised and supervised learning algorithms for component detection and classification, and (ii) scalability, by enabling fast large scale processing with standard computing infrastructure (e.g., a commodity laptop or workstation). Scalability is achieved by either using a MapReduce batch approach, which employs parallel processing of spatially overlapping, memory mapped, data patches; or by integrating the online processing framework of <xref ref-type="bibr" rid="bib17">Giovannucci et al., 2017</xref> within our pipeline. Apart from computational gains both approaches also result in improved performance. Towards our goal of providing a single package for dealing with standard problems arising in analysis of imaging data, C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> also includes an implementation of the CNMF-E algorithm of <xref ref-type="bibr" rid="bib52">Zhou et al. (2018)</xref> for the analysis of microendoscopic data, as well as a novel method for registering analysis results across multiple days.</p></sec><sec id="s3-2"><title>Towards surpassing human neuron detection performance</title><p>To evaluate the performance of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>and C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc>, we used a number of distinct labelers to generate a corpus of nine annotated two-photon imaging datasets. The results indicated a surprising level of disagreement between individual labelers, highlighting both the difficulty of the problem, and the non-reproducibility of the laborious task of human annotation. C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> reached near-human performance with respect to this consensus annotation, by using the <italic>same</italic> parameters for all the datasets without dataset dependent parameter tweaking. Such tweaking can include setting the SNR threshold based on the noise level of the recording, the complexity of the neuropil signal based on the level of background activity, or specialized treatment around the boundaries of the FOV to compensate for eventual imaging artifacts, and as shown can significantly improve the results on individual datasets. As demonstrated in our results, optimal parameter setting for C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> can also depend on the length of the experiment with stricter parameters being more suitable for longer datasets. We plan to investigate parameter schemes that increase in strictness over the course of an experiment.</p><p> C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> has higher precision than recall when run on most datasets. While more balanced results can be achieved by appropriately relaxing the relevant quality evaluation thresholds, we prefer to maintain a higher precision as we believe that the inclusion of false positive traces can be more detrimental in any downstream analysis compared to the exclusion of, typically weak, true positive traces. This is true especially in experiments with low task dimensionality where a good signal from few neurons can be sufficient for the desired hypothesis testing.</p><p>Apart from being used as a benchmarking tool, the set of manual annotations can also be used as labeled data for supervised learning algorithms. C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> uses two CNN based classifiers trained on (a subset of) this data, one for post processing component classification in C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc>, and the other for detecting new neurons in residual images in the C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc>. The deployment of these classifiers resulted in significant gains in terms of performance, and we expect further advances in the future. The annotations are made freely available to the community for benchmarking and training purposes.</p></sec><sec id="s3-3"><title>C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> vs C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc></title><p>Our results suggest similar performance between C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>and C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>onine</sc> when evaluated on the basis of processing speed and quality of results, with C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> outperforming C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>on longer datasets in terms of neuron detection, possibly due to its inherent ability to adapt to non-stationarities arising during the course of a large experiment. By contrast, C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>extracts better traces compared to C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> with respect to the traces derived from the consensus annotations. While multiple passes over the data with C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> can mitigate these shortcomings, this still depends on good initialization with C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc>, as the analysis of the whole brain zebrafish dataset indicates. In offline setups, C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>onine</sc> could also benefit from the post processing component evaluation tools used in batch mode. for example using the batch classifier for detecting false positive components at the end of the experiment.</p><p> C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> differs from C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> in that the former has lower memory requirements and it can support novel types of closed-loop all-optical experiments (<xref ref-type="bibr" rid="bib28">Packer et al., 2015</xref>; <xref ref-type="bibr" rid="bib8">Carrillo-Reid et al., 2017</xref>). As discussed in <xref ref-type="bibr" rid="bib17">Giovannucci et al., 2017</xref>, typical all-optical closed-loop experiments require the pre-determination of ROIs that are monitored/modulated. Indeed, C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> allows identification and modulation of new neurons on the fly, greatly expanding the space of possible experiments. Even though our simulated online processing setup is not integrated with hardware to an optical experimental setup, our results indicate thatC<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> performed close to real-time in most cases. Real time can be potentially achieved by using parallel computational streams for the three steps of frame processing (motion correction and tracking, detecting new neurons, updating shapes), since these steps can be largely run in an asynchronous mode independently. This suggests that large scale closed-loop experiments with single cell resolution are feasible by combining existing all-optical technology and our proposed analysis method.</p></sec><sec id="s3-4"><title>Future directions</title><p>While C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> uses a highly scalable processing pipeline for two-photon datasets, processing of one-photon microendoscopic imaging data is less scalable due to the more complex background model that needs to be retained in memory during processing. Adapting C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> to the one-photon data processing algorithm of <xref ref-type="bibr" rid="bib52">Zhou et al. (2018)</xref> is a promising way for scaling up efficient processing in this case. The continuing development and quality improvement of neural activity indicators has enabled direct imaging of neural processes (axons/dendrites), imaging of synaptic activity (<xref ref-type="bibr" rid="bib50">Xie et al., 2016</xref>), or direct imaging of voltage activity in vivo conditions (<xref ref-type="bibr" rid="bib31">Piatkevich et al., 2018</xref>). While the approach presented here is tuned for somatic imaging through the use of various assumptions (space localized activity, CNN classifiers trained on images of somatic activity), the technology of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> is largely transferable to these domains as well. We will pursue these extensions in future work.</p></sec></sec><sec id="s4" sec-type="materials|methods"><title>Materials and methods</title><sec id="s4-1"><title>Memory mapping</title><p> C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>uses memory mapping for efficient parallel data access. With memory mapped arrays, arithmetic operations can be performed on data residing on the hard drive without explicitly loading it to RAM, and slices of data can be indexed and accessed without loading the full file in memory, enabling out-of-core processing (<xref ref-type="bibr" rid="bib45">Toledo, 1999</xref>). On modern computers tensors are stored in linear format, no matter the number of the array dimensions. Therefore, one has to decide which elements of an array are contiguous in memory: in <italic>row-major order</italic>, consecutive elements of a row (first-dimension) are next to each other, whereas in <italic>column-major order</italic> consecutive elements of a column (last dimension) are contiguous. Such decisions significantly affect the speed at which data is read or written on spinning disks (and to a lesser degree on solid state drives): in <italic>column-major order</italic> reading a full column is fast because memory is read in a single sequential block, whereas reading a row is inefficient since only one element can be read at a time and all the data needs to be accessed.</p><p>In the context of calcium imaging datasets, C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>represents the datasets in a matrix form <inline-formula><mml:math id="inf68"><mml:mi>Y</mml:mi></mml:math></inline-formula>, where each row corresponds to a different imaged pixel, and each column to a different frame. As a result, a <italic>column-major order</italic> mmap file enables the fast access of individual frames at a given time, whereas a <italic>row-major order</italic> files enables the fast access of an individual pixel at all times. To facilitate processing in patches C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>stores the data in <italic>row-major order</italic>. In practice, this is opposite to the order with which the data appears, one frame at a time. In order to reduce memory usage and speed up computation C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>employs a MapReduce approach, where either multiple files or multiple chunks of a big file composing the original datasets are processed and saved in mmap format in parallel. This operation includes two phases, first the chunks/files are saved (possibly after motion correction, if required) in multiple row-major mmap format, and then chunks are simultaneously combined into a single large row-major mmap file.</p></sec><sec id="s4-2"><title>Mathematical model of the CNMF framework</title><p>The CNMF framework (<xref ref-type="fig" rid="fig1">Figure 1d</xref>) for calcium imaging data representation can be expressed in mathematical terms as (<xref ref-type="bibr" rid="bib33">Pnevmatikakis et al., 2016</xref>)<disp-formula id="equ1"><label>(1)</label><mml:math id="m1"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>Y</mml:mi><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:mi>C</mml:mi><mml:mo>+</mml:mo><mml:mi>B</mml:mi><mml:mo>+</mml:mo><mml:mi>E</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:mstyle></mml:math></disp-formula></p><p>Here, <inline-formula><mml:math id="inf69"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>Y</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>×</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mstyle></mml:math></inline-formula> denotes the observed data written in matrix form, where <inline-formula><mml:math id="inf70"><mml:mi>d</mml:mi></mml:math></inline-formula> is the total number of observed pixels/voxels, and <inline-formula><mml:math id="inf71"><mml:mi>T</mml:mi></mml:math></inline-formula> is the total number of observed timesteps (frames). <inline-formula><mml:math id="inf72"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>A</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>×</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mstyle></mml:math></inline-formula> denotes the matrix of the <inline-formula><mml:math id="inf73"><mml:mi>N</mml:mi></mml:math></inline-formula> spatial footprints, <inline-formula><mml:math id="inf74"><mml:mrow><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi mathvariant="bold">𝐚</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold">𝐚</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="normal">…</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold">𝐚</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, with <inline-formula><mml:math id="inf75"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>×</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mstyle></mml:math></inline-formula> being the spatial footprint of component <inline-formula><mml:math id="inf76"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>i</mml:mi><mml:mo>.</mml:mo><mml:mspace width="thinmathspace"/><mml:mi>C</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mstyle></mml:math></inline-formula> denotes the matrix of temporal components, <inline-formula><mml:math id="inf77"><mml:mrow><mml:mi>C</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi mathvariant="bold">𝐜</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold">𝐜</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="normal">…</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold">𝐜</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>⊤</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, with <inline-formula><mml:math id="inf78"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mo>×</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mstyle></mml:math></inline-formula> being the temporal trace of component <inline-formula><mml:math id="inf79"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula>. <italic>B</italic> is the background/neuropil activity matrix. For two-photon data it is modeled as a low rank matrix <inline-formula><mml:math id="inf80"><mml:mrow><mml:mi>B</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="bold">𝐛𝐟</mml:mi></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="inf81"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>×</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mstyle></mml:math></inline-formula> correspond to the matrices of spatial and temporal background components, and <inline-formula><mml:math id="inf82"><mml:msub><mml:mi>n</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:math></inline-formula> is the number of background components. For the case of micro-endoscopic data the integration volume is much larger and the low rank model is inadequate. For this we use the CNMF-E algorithm of <xref ref-type="bibr" rid="bib52">Zhou et al. (2018)</xref> where the background is modeled as<disp-formula id="equ2"><label>(2)</label><mml:math id="m2"><mml:mrow><mml:mrow><mml:mi>B</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mi>W</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>Y</mml:mi><mml:mo>-</mml:mo><mml:mrow><mml:mi>A</mml:mi><mml:mo>⁢</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <inline-formula><mml:math id="inf83"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>W</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>×</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mstyle></mml:math></inline-formula> is an appropriate weight matrix, where the <inline-formula><mml:math id="inf84"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> entry models the influence of the neuropil signal of pixel <inline-formula><mml:math id="inf85"><mml:mi>j</mml:mi></mml:math></inline-formula> to the neuropil signal at pixel <inline-formula><mml:math id="inf86"><mml:mi>i</mml:mi></mml:math></inline-formula>.</p></sec><sec id="s4-3"><title>Combining results from different patches</title><p>To combine results from different patches we first need to account for the overlap at the boundaries. Neurons lying close to the boundary between neighboring patches can appear multiple times and must be merged. With this goal, we optimized the merging approach used in <xref ref-type="bibr" rid="bib33">Pnevmatikakis et al. (2016)</xref>: Groups of components with spatially overlapping footprints whose temporal traces are correlated above a threshold are replaced with a single component, that tries to explain as much of the variance already explained by the ‘local’ components (as opposed to the variance of the data as performed in <xref ref-type="bibr" rid="bib33">Pnevmatikakis et al. (2016)</xref>). If <inline-formula><mml:math id="inf87"><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mi>old</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>old</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are the matrices of components to be merged, then the merged component <inline-formula><mml:math id="inf88"><mml:mrow><mml:msub><mml:mi mathvariant="bold">𝐚</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold">𝐜</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are given by the solution of the rank-1 NMF problem:<disp-formula id="equ3"><label>(3)</label><mml:math id="m3"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:munder><mml:mo form="prefix" movablelimits="true">min</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:munder><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">l</mml:mi><mml:mi mathvariant="normal">d</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">l</mml:mi><mml:mi mathvariant="normal">d</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">⊤</mml:mi></mml:mrow></mml:msubsup><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:mstyle></mml:math></disp-formula></p><p>Prior to merging, the value of each component at each pixel is normalized by the number of patches that overlap in this pixel, to avoid counting the activity of each pixel multiple times.</p><p>We follow a similar procedure for the background/neuropil signals from the different patches. When working with two-photon data, the spatial background/neuropil components for each patch can be updated by keeping their spatial extent intact to retain a local neuropil structure, or they can be merged when they are sufficiently correlated in time as described above to promote a more global structure. For the case of one-photon data, CNMF-E estimates the background using a local autoregressive process (see <xref ref-type="disp-formula" rid="equ2">Equation 2</xref>) (<xref ref-type="bibr" rid="bib52">Zhou et al., 2018</xref>), a setup that cannot be immediately propagated when combining the different patches. To combine backgrounds from the different patches, we first approximate the backgrounds <inline-formula><mml:math id="inf89"><mml:msup><mml:mi>B</mml:mi><mml:mi>i</mml:mi></mml:msup></mml:math></inline-formula> from all the patches <inline-formula><mml:math id="inf90"><mml:mi>i</mml:mi></mml:math></inline-formula> with a low rank matrix using non-negative matrix factorization of rank <inline-formula><mml:math id="inf91"><mml:msub><mml:mi>g</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:math></inline-formula> to obtain global spatial, and temporal background components.<disp-formula id="equ4"><label>(4)</label><mml:math id="m4"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">F</mml:mi></mml:mrow><mml:mspace width="thinmathspace"/><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>B</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:mstyle></mml:math></disp-formula></p><p>The resulting components are embedded into a large matrix <inline-formula><mml:math id="inf92"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>B</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>×</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mstyle></mml:math></inline-formula> that retains a low rank structure. After the components and backgrounds from all the patches have been combined, they are further refined by running CNMF iteration of updating spatial footprints, temporal traces, and neuropil activity. C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> implements these steps in parallel (as also described in <xref ref-type="bibr" rid="bib33">Pnevmatikakis et al. (2016)</xref>): Temporal traces whose corresponding spatial traces do not overlap can be updated in parallel. Similarly, the rows of the matrix of spatial footprints <inline-formula><mml:math id="inf93"><mml:mi>A</mml:mi></mml:math></inline-formula> can also be updated in parallel (<xref ref-type="fig" rid="fig2">Figure 2b</xref>). The process is summarized in algorithmic format in Algorithms 1–2. When working with one-photon data, instead of producing a low-rank approximation of <inline-formula><mml:math id="inf94"><mml:mi>B</mml:mi></mml:math></inline-formula> that would underfit the background, we increase patch overlap and run the full pipeline on each patch. In the final phase, when neurons overlap we retain only the variant with the highest quality rather than merging them.</p></sec><sec id="s4-4"><title>Initialization strategies</title><p>Source extraction using matrix factorization requires solving a bi-convex problem where initialization plays a critical role. The CNMF/CNMF-E algorithms use initialization methods that exploit the locality of the spatial footprints to efficiently identify the locations of candidate components (<xref ref-type="bibr" rid="bib33">Pnevmatikakis et al., 2016</xref>; <xref ref-type="bibr" rid="bib52">Zhou et al., 2018</xref>). C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> incorporates these methods, extending them by using the temporal locality of the calcium transient events. The available initialization methods for C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> include:</p><p><bold>G<sc>reedy</sc>ROI</bold>: This approach, introduced in <xref ref-type="bibr" rid="bib33">Pnevmatikakis et al. (2016)</xref>, first spatially smooths the data with a Gaussian kernel of size comparable to the average neuron radius, and then initializes candidate components around locations where maximum variance (of the smoothed data) is explained. This initialization strategy is fast but requires manual specification of the number of components by the user.</p><p><bold>R<sc>olling</sc>G<sc>reedy</sc>ROI</bold>: The approach, introduced in this paper, operates like G<sc>reedy</sc>ROI by spatially smoothing the data and looking for points of maximum variance. Instead of working across all the data, R<sc>olling</sc>G<sc>reedy</sc>ROI looks for points of maximum variance on a rolling window of a fixed duration, for example 3 s, and initializes components by performing a rank one NMF on a local spatial neighborhood. By focusing into smaller rolling windows, R<sc>olling</sc>G<sc>reedy</sc>ROI can better isolate single transient events, and as a result detect better neurons with sparse activity. R<sc>olling</sc>G<sc>reedy</sc>ROI is the default choice for processing of 2-photon data.</p><p><bold>G<sc>reedy</sc>C<sc>orr</sc></bold>: This approach, introduced in <xref ref-type="bibr" rid="bib52">Zhou et al. (2018)</xref>, initializes candidate components around locations that correspond to the local maxima of an image formed by the pointwise product between the correlation image and the peak signal-to-noise ratio image. A threshold for acceptance of candidate neurons is used, making it unnecessary to pre-specify the neuron count. This comes at the expense of a higher computational cost. G<sc>reedy</sc>C<sc>orr</sc> is the default choice for processing of one-photon data.</p><p><bold>S<sc>parse</sc>NMF</bold>: Sparse NMF approaches, when ran in small patches, can be effective for quickly uncovering spatial structure in the imaging data, especially for neural processes (axons/dendrites) whose shape cannot be easily parametrized and/or localized.</p><p><bold>S<sc>eeded</sc>I<sc>nitialization</sc></bold>: Often locations of components are known either from manual annotation or from labeled data obtained in a different way, such as data from a static structural channel recorded concurrently with the functional indicator. C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> can be seeded with binary (or real valued) masks for the spatial footprints. Apart from <inline-formula><mml:math id="inf95"><mml:mi>A</mml:mi></mml:math></inline-formula>, these masks can be used to initialize all the other relevant matrices <inline-formula><mml:math id="inf96"><mml:mi>C</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="inf97"><mml:mi>B</mml:mi></mml:math></inline-formula> as well. This is performed by (i) first estimating the temporal background components <inline-formula><mml:math id="inf98"><mml:mi mathvariant="bold">𝐟</mml:mi></mml:math></inline-formula> using only data from parts of the FOV not covered by any masks and, (ii) then estimating the spatial background components <inline-formula><mml:math id="inf99"><mml:mi mathvariant="bold">𝐛</mml:mi></mml:math></inline-formula>, and then estimating <inline-formula><mml:math id="inf100"><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:math></inline-formula> (with <inline-formula><mml:math id="inf101"><mml:mi>A</mml:mi></mml:math></inline-formula> restricted to be non-zero only at the locations of the binary masks), using a simple NMF approach. Details are given in Algorithm 3.</p></sec><sec id="s4-5"><title>Details of quality assessment tests</title><p>Here we present the unsupervised and supervised quality assessment tests in more detail (<xref ref-type="fig" rid="fig2">Figure 2</xref>).</p><sec id="s4-5-1"><title>Matching spatial footprints to the raw data</title><p>Let <inline-formula><mml:math id="inf102"><mml:mrow><mml:msub><mml:mi mathvariant="bold">𝐚</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold">𝐜</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> denote the spatial footprint and temporal trace of component <inline-formula><mml:math id="inf103"><mml:mi>i</mml:mi></mml:math></inline-formula>, and the let <inline-formula><mml:math id="inf104"><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mi/><mml:mo>\</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi/><mml:mo>\</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> denote the matrices <inline-formula><mml:math id="inf105"><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:math></inline-formula> when the component <inline-formula><mml:math id="inf106"><mml:mi>i</mml:mi></mml:math></inline-formula> has been removed. Similarly, let <inline-formula><mml:math id="inf107"><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mi>Y</mml:mi><mml:mo>-</mml:mo><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mi/><mml:mo>\</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>⁢</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi/><mml:mo>\</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>-</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> denote the entire dataset when the background and the contribution of all components except <inline-formula><mml:math id="inf108"><mml:mi>i</mml:mi></mml:math></inline-formula> have been removed. If component <inline-formula><mml:math id="inf109"><mml:mi>i</mml:mi></mml:math></inline-formula> is real then <inline-formula><mml:math id="inf110"><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> and <inline-formula><mml:math id="inf111"><mml:mrow><mml:msub><mml:mi mathvariant="bold">𝐚</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:msubsup><mml:mi mathvariant="bold">𝐜</mml:mi><mml:mi>i</mml:mi><mml:mo>⊤</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> will look similar during the time intervals when the component <inline-formula><mml:math id="inf112"><mml:mi>i</mml:mi></mml:math></inline-formula> is active. As a first test C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> finds the first <inline-formula><mml:math id="inf113"><mml:msub><mml:mi>N</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:math></inline-formula> local peaks of <inline-formula><mml:math id="inf114"><mml:msub><mml:mi>c</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> (e.g., <inline-formula><mml:math id="inf115"><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula>), constructs intervals around these peaks, (e.g., 50 ms in the past and 300 ms in the future, to cover the main part of a possible calcium transient around that point), and then averages <inline-formula><mml:math id="inf116"><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> across time over the union of these intervals to obtain a spatial image <inline-formula><mml:math id="inf117"><mml:mrow><mml:mo>&lt;</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&gt;</mml:mo></mml:mrow></mml:math></inline-formula> (<xref ref-type="fig" rid="fig2">Figure 2c</xref>). The Pearson’s correlation over space between <inline-formula><mml:math id="inf118"><mml:mrow><mml:mo>&lt;</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&gt;</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf119"><mml:msub><mml:mi mathvariant="bold">𝐚</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> (both restricted on a small neighborhood around the centroid of <inline-formula><mml:math id="inf120"><mml:msub><mml:mi mathvariant="bold">𝐚</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula>) is then computed, and component <inline-formula><mml:math id="inf121"><mml:mi>i</mml:mi></mml:math></inline-formula> is rejected if the correlation coefficient is below a threshold value <inline-formula><mml:math id="inf122"><mml:msub><mml:mi>θ</mml:mi><mml:mi>sp</mml:mi></mml:msub></mml:math></inline-formula>, (e.g., <inline-formula><mml:math id="inf123"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">p</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>&lt;</mml:mo><mml:mspace width="thinmathspace"/><mml:mn>0.5</mml:mn></mml:mrow></mml:mstyle></mml:math></inline-formula>). Note that a similar test is used in the online approach of <xref ref-type="bibr" rid="bib17">Giovannucci et al., 2017</xref> to accept for possible new components.</p></sec><sec id="s4-5-2"><title>Detecting fluorescence traces with high SNR</title><p>For a candidate component to correspond to an active neuron its trace must exhibit dynamics reminiscent of the calcium indicator’s transient. A criterion for this can be obtained by requiring the average SNR of trace <inline-formula><mml:math id="inf124"><mml:msub><mml:mi mathvariant="bold">𝐜</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> over the course a transient to be above a certain threshold <inline-formula><mml:math id="inf125"><mml:msub><mml:mi>θ</mml:mi><mml:mi>SNR</mml:mi></mml:msub></mml:math></inline-formula>, for example <inline-formula><mml:math id="inf126"><mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mi>SNR</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>, (<xref ref-type="fig" rid="fig2">Figure 2d</xref>). The average SNR can be seen as a measure of how unlikely it is for the transients of <inline-formula><mml:math id="inf127"><mml:msub><mml:mi mathvariant="bold">𝐜</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> (after some appropriate z-scoring) to have been the result of a white noise process.</p><p>To compute the SNR of a trace, let <inline-formula><mml:math id="inf128"><mml:mrow><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mi>Y</mml:mi><mml:mo>-</mml:mo><mml:mrow><mml:mi>A</mml:mi><mml:mo>⁢</mml:mo><mml:mi>C</mml:mi></mml:mrow><mml:mo>-</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> be the residual spatiotemporal signal. We can obtain the residual signal for each component <inline-formula><mml:math id="inf129"><mml:mi>i</mml:mi></mml:math></inline-formula>, <inline-formula><mml:math id="inf130"><mml:msub><mml:mi mathvariant="bold">𝐫</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula>, by projecting <inline-formula><mml:math id="inf131"><mml:mi>R</mml:mi></mml:math></inline-formula> into the spatial footprint <inline-formula><mml:math id="inf132"><mml:msup><mml:mi mathvariant="bold">𝐚</mml:mi><mml:mi>i</mml:mi></mml:msup></mml:math></inline-formula>:<disp-formula id="equ5"><label>(5)</label><mml:math id="m5"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mfrac><mml:mn>1</mml:mn><mml:msup><mml:mrow><mml:mo symmetric="true">‖</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo symmetric="true">‖</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mfrac></mml:mstyle><mml:msup><mml:mi>R</mml:mi><mml:mrow><mml:mi mathvariant="normal">⊤</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></disp-formula></p><p>Then the trace <inline-formula><mml:math id="inf133"><mml:mrow><mml:msub><mml:mi mathvariant="bold">𝐜</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi mathvariant="bold">𝐫</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> corresponds to the non-denoised trace of component <inline-formula><mml:math id="inf134"><mml:mi>i</mml:mi></mml:math></inline-formula>. To calculate its SNR we first compute a type of z-score:<disp-formula id="equ6"><label>(6)</label><mml:math id="m6"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">z</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mrow><mml:mi mathvariant="normal">B</mml:mi><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mspace width="thinmathspace"/><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">N</mml:mi><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mspace width="thinmathspace"/><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:mstyle></mml:math></disp-formula></p><p>The B<sc>aseline</sc><inline-formula><mml:math id="inf135"><mml:mrow><mml:mo mathvariant="normal" stretchy="false">(</mml:mo><mml:mo mathvariant="normal">⋅</mml:mo><mml:mo mathvariant="normal" stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> function determines the baseline of the trace, which can be varying in the case of long datasets exhibiting baseline trends, for example due to bleaching. The function N<sc>oise</sc><inline-formula><mml:math id="inf136"><mml:mrow><mml:mo mathvariant="normal" stretchy="false">(</mml:mo><mml:mo mathvariant="normal">⋅</mml:mo><mml:mo mathvariant="normal" stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> estimates the noise level of the trace. Since calcium transients around the baseline can only be positive, we estimate the noise level by restricting our attention only to the points <inline-formula><mml:math id="inf137"><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:math></inline-formula> where <inline-formula><mml:math id="inf138"><mml:mrow><mml:msub><mml:mi mathvariant="bold">𝐜</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi mathvariant="bold">𝐫</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is below the baseline value, that is <inline-formula><mml:math id="inf139"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>t</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mrow><mml:mi mathvariant="normal">B</mml:mi><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mspace width="thinmathspace"/><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo fence="false" stretchy="false">}</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula>, and compute the noise level as the scale parameter of a half-normal distribution (<xref ref-type="fig" rid="fig2">Figure 2b</xref>):<disp-formula id="equ7"><label>(7)</label><mml:math id="m7"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mi mathvariant="normal">N</mml:mi><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mspace width="thinmathspace"/><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">d</mml:mi></mml:mrow><mml:mspace width="thinmathspace"/><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:msqrt><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mfrac><mml:mn>2</mml:mn><mml:mi>π</mml:mi></mml:mfrac></mml:msqrt><mml:mo>.</mml:mo></mml:mrow></mml:mstyle></mml:math></disp-formula></p><p>We then determine how likely is that the positive excursions of <inline-formula><mml:math id="inf140"><mml:msub><mml:mi mathvariant="bold">𝐳</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> can be attributed just to noise. We compute the probabilities <inline-formula><mml:math id="inf141"><mml:mrow><mml:mrow><mml:msub><mml:mi mathvariant="bold">𝐩</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo>-</mml:mo><mml:mrow><mml:msub><mml:mi mathvariant="bold">𝐳</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="inf142"><mml:mrow><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>⋅</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> denotes the cumulative distribution function of a standard normal distribution, and compute the most unlikely excursion over a window of <inline-formula><mml:math id="inf143"><mml:msub><mml:mi>N</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:math></inline-formula> timesteps that corresponds to the length of a typical transient, for example <inline-formula><mml:math id="inf144"><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">⌈</mml:mo><mml:mrow><mml:mrow><mml:mn>0.4</mml:mn><mml:mo>⁢</mml:mo><mml:mi>s</mml:mi></mml:mrow><mml:mo>×</mml:mo><mml:mi>F</mml:mi></mml:mrow><mml:mo stretchy="false">⌉</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="inf145"><mml:mn>0.4</mml:mn></mml:math></inline-formula>s could correspond to the typical length of a GCaMP6f transient, and <inline-formula><mml:math id="inf146"><mml:mi>F</mml:mi></mml:math></inline-formula> is the imaging rate.<disp-formula id="equ8"><label>(8)</label><mml:math id="m8"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mi>min</mml:mi><mml:mi>i</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:munder><mml:mi>min</mml:mi><mml:mi>t</mml:mi></mml:munder><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:munderover><mml:mo largeop="true" movablelimits="false" symmetric="true">∏</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="bold">𝐩</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:msup><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p>The (averaged peak) SNR of component <inline-formula><mml:math id="inf147"><mml:mi>i</mml:mi></mml:math></inline-formula> can then be defined as<disp-formula id="equ9"><label>(9)</label><mml:math id="m9"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mi mathvariant="normal">Φ</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mo form="prefix" movablelimits="true">min</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:msup><mml:mi mathvariant="normal">Φ</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mo form="prefix" movablelimits="true">min</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mstyle></mml:math></disp-formula>where <inline-formula><mml:math id="inf148"><mml:msup><mml:mi mathvariant="normal">Φ</mml:mi><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:math></inline-formula> is the quantile function for the standard normal distribution (logit function) and a component is accepted if <inline-formula><mml:math id="inf149"><mml:mrow><mml:msub><mml:mi>SNR</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>≥</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mi>SNR</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Note that for numerical stability we compute <inline-formula><mml:math id="inf150"><mml:msubsup><mml:mi>p</mml:mi><mml:mi>min</mml:mi><mml:mi>i</mml:mi></mml:msubsup></mml:math></inline-formula> in the logarithmic domain and check the condition <inline-formula><mml:math id="inf151"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mi>min</mml:mi><mml:mi>i</mml:mi></mml:msubsup><mml:mo>≤</mml:mo><mml:mrow><mml:mi mathvariant="normal">Φ</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo>-</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mi>SNR</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p>We can also use a similar test for the significance of the time traces in the spike domain after performing deconvolution. In this case, traces are considered to spike if their maximum height due to a spike transient exceeds a threshold. If we assume that the shape of each calcium transient has been normalized to have maximum amplitude 1, then this corresponds to testing <inline-formula><mml:math id="inf152"><mml:mrow><mml:msub><mml:mrow><mml:mo>∥</mml:mo><mml:msub><mml:mi mathvariant="bold">𝐬</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∥</mml:mo></mml:mrow><mml:mi mathvariant="normal">∞</mml:mi></mml:msub><mml:mo>≥</mml:mo><mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mi>SNR</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="inf153"><mml:msub><mml:mi mathvariant="bold">𝐬</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> represents the deconvolved activity trace for component <inline-formula><mml:math id="inf154"><mml:mi>i</mml:mi></mml:math></inline-formula>, and <inline-formula><mml:math id="inf155"><mml:msub><mml:mi>θ</mml:mi><mml:mi>SNR</mml:mi></mml:msub></mml:math></inline-formula> is again an appropriate SNR threshold, for example <inline-formula><mml:math id="inf156"><mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mi>SNR</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="inf157"><mml:msub><mml:mi>σ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> is the noise level for trace <inline-formula><mml:math id="inf158"><mml:mi>i</mml:mi></mml:math></inline-formula>.</p></sec><sec id="s4-5-3"><title>Classification through convolutional neural networks (CNNs)</title><p>The tests described above are unsupervised but require fine-tuning of two threshold parameters <inline-formula><mml:math id="inf159"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mo>⁢</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mi>SNR</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> that might be dataset dependent and might be sensitive to strong non-stationarities. As a third test we trained a 4-layer CNN to classify the spatial footprints into true or false components, where a true component here corresponds to a spatial footprint that resembles a neuron soma (See <xref ref-type="fig" rid="fig2">Figure 2e</xref> and section <italic>Classification through convolutional networks</italic> for details). A simple threshold <inline-formula><mml:math id="inf160"><mml:msub><mml:mi>θ</mml:mi><mml:mi>CNN</mml:mi></mml:msub></mml:math></inline-formula> can be used to tune the classifier (e.g., <inline-formula><mml:math id="inf161"><mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mi>CNN</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn></mml:mrow></mml:math></inline-formula>).</p></sec></sec><sec id="s4-6"><title>Collection of manual annotations and consensus</title><p>We collected manual annotations from four independent labelers who were instructed to find round or donut shaped neurons of similar size using the ImageJ Cell Magic Wand tool (<xref ref-type="bibr" rid="bib49">Walker, 2014</xref>). We focused on manually annotating only cells that were active within each dataset and for that reason the labelers were provided with two summary statistics: (i) A movie obtained by removing a running 20th percentile (as a crude background approximation) and downsampling in time by a factor of 10, and (ii) the max-correlation image. The correlation image (CI) at every pixel is equal to the average temporal correlation coefficient between that pixel and its neighbors (<xref ref-type="bibr" rid="bib40">Smith and Häusser, 2010</xref>) (eight neighbors were used for our analysis). The max-correlation image is obtained by computing the CI for each batch of 33 s (1000 frames for a 30 Hz acquisition rate), and then taking the maximum over all these images (<xref ref-type="fig" rid="fig3s1">Figure 3—figure supplement 1a</xref>). Neurons that are inactive during the course of the dataset will be suppressed both from the baseline removed video (since their activity will always be around their baseline), and from the max-correlation image since the variation around this baseline will mostly be due to noise leading to practically uncorrelated neighboring pixels (<xref ref-type="fig" rid="fig3s1">Figure 3—figure supplement 1a</xref>). Nine different mouse in vivo datasets were used from various brain areas and labs. A description is given in <xref ref-type="table" rid="table2">Table 2</xref>. To create the final consensus, the labelers were asked to jointly resolve the inconsistencies between their annotations. To this end, every ROI selected by at least one but not all labelers was re-considered by a group of at least two labelers that decided whether it corresponds to an active neuron or not.</p><p>The annotation procedure provides a binary mask per selected component. On the other hand, the output of for each component is a non-negatively valued vector over the FOV (a real-valued mask). The two sets of masks differ not only in their variable type but also in their general shape: Manual annotation through the Cell Magic Wand tool tends to produce circular shapes, whereas the output of C<sc>aI</sc><sc>m</sc>A<sc>n</sc> will try to accurately estimate the shape of each active component (<xref ref-type="fig" rid="fig3s1">Figure 3—figure supplement 1b</xref>). To construct the consensus components that can be directly used for comparison, the binary masks from the manual annotations were used to seed the CNMF algorithm (Algorithm 3). This produced a set of real valued components with spatial footprints restricted to the areas provided by the annotations, and a corresponding set of temporal components that can be used to evaluate the performance of C<sc>aI</sc><sc>m</sc>A<sc>n</sc> (<xref ref-type="fig" rid="fig4">Figure 4</xref>). Registration was performed using the <sc>RegisterPair</sc> algorithm (Algorithm 7) and match was counted as a true positive when the (modified) Jaccard distance (<xref ref-type="disp-formula" rid="equ11">Equation 11</xref>) was below 0.7. Details of the registration procedure are given below (see <italic>Component registration</italic>).</p></sec><sec id="s4-7"><title>Cross-Validation analysis of manual annotations</title><p>As mentioned in the results section, comparing each manual annotation with the consensus annotation can create slightly biased results in favor of individual annotators since the consensus annotation is chosen from the union of individual annotations. To correct for this we performed a cross-validation analysis where the annotations of each labeler were compared against an automatically generated combination of the rest of the labelers. To create the combined annotations we first used the R<sc>egister</sc>M<sc>ulti</sc> procedure to construct the union of each subset of <inline-formula><mml:math id="inf162"><mml:mrow><mml:mi>N</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> labelers (where <inline-formula><mml:math id="inf163"><mml:mi>N</mml:mi></mml:math></inline-formula> is the total number of labelers for each dataset). When <inline-formula><mml:math id="inf164"><mml:mrow><mml:mi>N</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> then the combined annotation consisted of the components that were selected by at least two labelers. When <inline-formula><mml:math id="inf165"><mml:mrow><mml:mi>N</mml:mi><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula> a stricter intersection approach was used; the combined annotation consisted of the components that were selected by both remaining labelers. The procedure was repeated for all subsets of labelers and all datasets. The results are shown in <xref ref-type="table" rid="table3">Table 3</xref> While individual scores for specific annotators and datasets vary significantly compared to using the consensus annotation as ground truth (<xref ref-type="table" rid="table1">Table 1</xref>), the decrease in average performance was modest indicating a low bias level.</p><table-wrap id="table3" position="float"><object-id pub-id-type="doi">10.7554/eLife.38173.022</object-id><label>Table 3.</label><caption><title>Cross-validated results of each labeler, where each labeler’s performance is compared against the annotations of the rest of the labelers using a majority vote.</title><p>Results are given in the form <inline-formula><mml:math id="inf166"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> score (precision, recall), and empty entries correspond to datasets not manually annotated by the specific labeler. The results indicate decreased performance compared to the consensus annotation annotations.</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Name</th><th align="center">L1</th><th align="center">L2</th><th align="center">L3</th><th align="center">L4</th><th align="center">Mean</th></tr></thead><tbody><tr><td>N.01.01</td><td align="center">0.75 <break/>(0.73, 0.77)</td><td align="center">0.70 <break/>(0.58, 0.88)</td><td align="center">0.86 <break/>(0.81, 0.90)</td><td align="center">0.84 <break/>(0.92, 0.77)</td><td align="center">0.79 <break/>(0.76, 0.83)</td></tr><tr><td><italic>N.03.00.t</italic></td><td align="center">X</td><td align="center">0.75 <break/>(0.69, 0.82)</td><td align="center">0.79 <break/>(0.67, 0.97)</td><td align="center">0.85 <break/>(0.76,0.97)⁢</td><td align="center">0.8 <break/>(0.71,0.92)</td></tr><tr><td>N.00.00</td><td align="center">X</td><td align="center">0.87 <break/>(0.84,0.90)⁢</td><td align="center">0.82 <break/>(0.75,0.91)</td><td align="center">⁢0.72 <break/>(0.71,0.97)⁢</td><td align="center">0.83 <break/>(0.76,0.93)</td></tr><tr><td>YST</td><td align="center">⁢0.7 <break/>(0.93,0.56)⁢</td><td align="center">0.79 <break/>(0.7,0.9)⁢</td><td align="center">⁢0.81 <break/>(0.76,0.86)⁢</td><td align="center">⁢0.77 <break/>(0.75,0.78)⁢</td><td align="center">0.77 <break/>(0.78,0.78)⁢</td></tr><tr><td><italic>N.04.00.t</italic></td><td align="center">X</td><td align="center">0.79 <break/>⁢(0.76,0.83)⁢</td><td align="center">0.72 <break/>⁢(0.60,0.89)⁢</td><td align="center">0.68 <break/>(0.53,0.96)⁢</td><td align="center">0.73 <break/>(0.63,0.89)⁢</td></tr><tr><td><italic>N.02.00</italic></td><td align="center">0.84 <break/>(0.97,0.75)</td><td align="center">⁢0.88 <break/>⁢(0.89,0.87)⁢</td><td align="center">0.86 <break/>(0.79,0.94)⁢</td><td align="center">⁢0.81 <break/>(0.7,0.95)</td><td align="center">0.85 <break/>(0.83,0.88)</td></tr><tr><td>J123</td><td align="center">X</td><td align="center">0.9 <break/>(0.86,0.93)⁢</td><td align="center">0.89 <break/>(0.84,0.93)⁢</td><td align="center">0.77 <break/>(0.63,0.96)⁢</td><td align="center">⁢0.87 <break/>(0.88,0.88)</td></tr><tr><td>J115</td><td align="center">0.85 <break/>(0.98,0.76)⁢</td><td align="center">0.87 <break/>(0.80,0.97)</td><td align="center">0.88 <break/>(0.80,0.97)</td><td align="center">0.87 <break/>(0.93,0.82)⁢</td><td align="center">0.85 <break/>(0.78,0.94)⁢</td></tr><tr><td>K53</td><td align="center">0.86 <break/>(0.98,0.77)⁢</td><td align="center">0.9 <break/>(0.85,0.96)</td><td align="center">0.88 <break/>(0.8,0.96)</td><td align="center">0.89 <break/>(0.9,0.88)⁢</td><td align="center">0.88 <break/>(0.88,0.89)⁢</td></tr><tr><td>mean <inline-formula><mml:math id="inf167"><mml:mo>±</mml:mo></mml:math></inline-formula> std</td><td align="center">0.8±0.06 <break/>(0.92±0.09,0.72±0.08)</td><td align="center">0.83±0.07 <break/>(0.77±0.1,0.9±0.05)⁢</td><td align="center">0.83±0.05 <break/>(0.76±0.07,0.92±0.04)⁢</td><td align="center">0.81±0.06 <break/>(0.76±0.13,0.9±0.08)</td><td align="center">0.82±0.06 <break/>(0.77±0.12,0889±0.06)</td></tr></tbody></table></table-wrap></sec><sec id="s4-8"><title>Classification through convolutional neural networks (CNNs)</title><p> C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> uses two CNN classifiers; one for post processing component screening in C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc>, and a different one for screening candidate components in C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc>. In both cases a four layer CNN was used, with architecture as described in <xref ref-type="fig" rid="fig2">Figure 2e</xref>. The first two convolutional layers consist of 32 3<inline-formula><mml:math id="inf168"><mml:mo>×</mml:mo></mml:math></inline-formula>3 filters each, whereas each of the latter two layers consist of 64 <inline-formula><mml:math id="inf169"><mml:mrow><mml:mn>3</mml:mn><mml:mo>×</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula> filters, all followed by a rectifier linear unit (ReLU). Every two layers a <inline-formula><mml:math id="inf170"><mml:mrow><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> max-pool filter is included. A two layer dense network with 512 hidden units is used to compute the predictions (<xref ref-type="fig" rid="fig2">Figure 2e</xref>).</p><sec id="s4-8-1"><title>C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>classifier for post processing classification</title><p>The purpose of the batch classifier is to classify the components detected by C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> into neuron somas or other shapes, by examining their spatial footprints. Only three annotated datasets (NF.03.00.t, NF.04.00.t, NF.02.00) were used to train the batch classifier. The set of estimated footprints from running C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>initialized with the consensus annotation was matched to the set of consensus footprints. Footprints matched to consensus components were considered positive examples, whereas the remaining components were labeled as negatives. The two sets were enriched using data augmentation (rotations, reflections, contrast manipulation etc.) through the Keras library (keras.io) and the CNN was trained on 60% of the data, leaving 20% for validation and 20% for testing. The CNN classifier reached an accuracy of 97% on test data; this generalized to the rest of the datasets (<xref ref-type="fig" rid="fig2">Figure 2e</xref>) without any parameter change.</p></sec><sec id="s4-8-2"><title>Online classifier for new component detection</title><p>The purpose of the C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> classifier is to detect new components based on their spatial footprints by looking at the mean across time of the residual buffer. To construct the labeled data for the online classifier, C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> was run on the first five annotated datasets seeded with the masks obtained through the manual annotations. Subsequently the activity of random subsets of found components and the background was removed from contiguous frames of the raw datasets to construct residual buffers, which were averaged across time. From the resulting images patches were extracted corresponding to positive examples (patches around a neuron that was active during the buffer) and negative examples (patches around other positions within the FOV). A neuron was considered active if its trace attained an average peak-SNR value of 4 or higher during the buffer interval. Similarly to the batch classifier, the two sets were augmented and split into training, validation and testing sets. The resulting classifier reached a 98% accuracy on the testing set, and also generalized well when applied to different datasets.</p></sec><sec id="s4-8-3"><title>Differences between the two classifiers</title><p>Although both classifiers examine the spatial footprints of candidate components, their required performance characteristics are different which led us to train them separately. Firstly, the two classifiers are trained on separate data: The batch classifier is trained on spatial footprints extracted from C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc>, whereas the online classifier is trained on residual signals that are generated as C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> operates. The batch classifier examines each component as a post-processing step to determine whether its shape corresponds to a neural cell body. As such, false positive and false negative examples are treated equally and possible mis-classifications do not directly affect the traces of the other components. By contrast, the online classifier operates as part of the online processing pipeline. In this case, a new component that is not detected in a residual buffer is likely to be detected later should it become more active. On the other hand, a component that is falsely detected and incorporated in the online processing pipeline will continue to affect the future buffer residuals and the detection of future components. As such the online algorithm is more sensitive to false positives than false negatives. To ensure a small number of false positive examples under testing conditions, only components with average peak-SNR value at least four were considered as positive examples during training of the online classifier.</p></sec></sec><sec id="s4-9"><title>Distributed update of spatial footprints</title><p>To efficiently distribute the cost of updating shapes across all frames we derived a simple algorithm that (i) ensures that every spatial footprint is updated at least once every <inline-formula><mml:math id="inf171"><mml:msub><mml:mi>T</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:math></inline-formula> steps, where <inline-formula><mml:math id="inf172"><mml:msub><mml:mi>T</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:math></inline-formula> is a user defined parameter, for example <inline-formula><mml:math id="inf173"><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>200</mml:mn></mml:mrow></mml:math></inline-formula>, and (ii) no spatial component is updated during a step when new components were added. The latter property is used to compensate for the additional computational cost that comes with introducing new components. Whenever a new component is added the algorithm collects the components with overlapping spatial footprints and makes sure they are updated at the next frame. This property ensures that the footprints of all required components adapt quickly whenever a new neighbor is introduced. The procedure is described in algorithmic form in Algorithm 6.</p></sec><sec id="s4-10"><title>Component registration</title><p>Fluorescence microscopy methods enable imaging the same brain region across different sessions that can span multiple days or weeks. While the microscope can visit the same location in the brain with reasonably high precision, the FOV might might not precisely match due to misalignments or deformations in the brain medium. C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> provides routines for FOV alignment and component registration across multiple sessions/days. Let <inline-formula><mml:math id="inf174"><mml:mrow><mml:msubsup><mml:mi mathvariant="bold">𝐚</mml:mi><mml:mn>1</mml:mn><mml:mn>1</mml:mn></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mi mathvariant="bold">𝐚</mml:mi><mml:mn>2</mml:mn><mml:mn>1</mml:mn></mml:msubsup><mml:mo>,</mml:mo><mml:mi mathvariant="normal">…</mml:mi><mml:mo>,</mml:mo><mml:msubsup><mml:mi mathvariant="bold">𝐚</mml:mi><mml:msub><mml:mi>N</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mn>1</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf175"><mml:mrow><mml:msubsup><mml:mi mathvariant="bold">𝐚</mml:mi><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mi mathvariant="bold">𝐚</mml:mi><mml:mn>2</mml:mn><mml:mn>2</mml:mn></mml:msubsup><mml:mo>,</mml:mo><mml:mi mathvariant="normal">…</mml:mi><mml:mo>,</mml:mo><mml:msubsup><mml:mi mathvariant="bold">𝐚</mml:mi><mml:msub><mml:mi>N</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula> the sets of spatial components from sessions 1 and 2 respectively, where <inline-formula><mml:math id="inf176"><mml:msub><mml:mi>N</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> and <inline-formula><mml:math id="inf177"><mml:msub><mml:mi>N</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math></inline-formula> denote the total number of components from each session. We first compute the FOV displacement by aligning some summary images from the two sessions (e.g., mean or correlation image), using a non-rigid registration method, for example N<sc>o</sc>RMC<sc>orre</sc> (<xref ref-type="bibr" rid="bib34">Pnevmatikakis and Giovannucci, 2017</xref>). We apply the estimated displacement field to the components of <inline-formula><mml:math id="inf178"><mml:msub><mml:mi>A</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> to align them with the FOV of session 2. To perform the registration, we construct a pairwise distance matrix <inline-formula><mml:math id="inf179"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>D</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:mstyle></mml:math></inline-formula> with <inline-formula><mml:math id="inf180"><mml:mrow><mml:mrow><mml:mi>D</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mi>d</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi mathvariant="bold">𝐚</mml:mi><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mi mathvariant="bold">𝐚</mml:mi><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="inf181"><mml:mrow><mml:mi>d</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>⋅</mml:mo><mml:mo>,</mml:mo><mml:mo>⋅</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> denotes a distance metric between two components. The chosen distance corresponds to the Jaccard distance between the binarized versions of the components. A real valued component <inline-formula><mml:math id="inf182"><mml:mi mathvariant="bold">𝐚</mml:mi></mml:math></inline-formula> is converted into its binary version <inline-formula><mml:math id="inf183"><mml:mrow><mml:mi>m</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold">𝐱</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> by setting to one only the values of <inline-formula><mml:math id="inf184"><mml:mi mathvariant="bold">𝐚</mml:mi></mml:math></inline-formula> that are above the maximum value of <inline-formula><mml:math id="inf185"><mml:mi mathvariant="bold">𝐚</mml:mi></mml:math></inline-formula> times a threshold <inline-formula><mml:math id="inf186"><mml:msub><mml:mi>θ</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:math></inline-formula>, for example <inline-formula><mml:math id="inf187"><mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mi>b</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0.2</mml:mn></mml:mrow></mml:math></inline-formula>:<disp-formula id="equ10"><label>(10)</label><mml:math id="m10"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo mathvariant="bold" stretchy="false">(</mml:mo></mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mtable columnalign="left left" columnspacing="1em" rowspacing="4pt"><mml:mtr><mml:mtd><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mtd><mml:mtd><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo mathvariant="bold" stretchy="false">(</mml:mo></mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>≥</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow><mml:msub><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mrow><mml:mi mathvariant="normal">∞</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn><mml:mo>,</mml:mo></mml:mtd><mml:mtd><mml:mtext>otherwise</mml:mtext></mml:mtd></mml:mtr></mml:mtable><mml:mo fence="true" stretchy="true" symmetric="true"/></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:mstyle></mml:math></disp-formula></p><p>To compute the distance between two binary masks <inline-formula><mml:math id="inf188"><mml:mrow><mml:msub><mml:mi>m</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, we use the Jaccard index (intersection over union) which is defined as<disp-formula id="equ11"><label>(11)</label><mml:math id="m11"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:mstyle></mml:math></disp-formula>and use it to define the distance metric as <disp-formula id="equ12"><label>(12)</label><mml:math id="m12"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mtable columnspacing="1em" rowspacing="4pt"><mml:mtr><mml:mtd><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>⊆</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mtext>OR</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>⊆</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi mathvariant="normal">∞</mml:mi></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">h</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">w</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable><mml:mo fence="true" stretchy="true" symmetric="true"/></mml:mrow></mml:mrow></mml:mstyle></mml:math></disp-formula>where <inline-formula><mml:math id="inf189"><mml:msub><mml:mi>θ</mml:mi><mml:mi>d</mml:mi></mml:msub></mml:math></inline-formula> is a distance threshold, for example 0.5 above which two components are considered non-matching and their distance is set to infinity. This is done to prevent false matchings between only marginally overlapping components.</p><p>After the distance matrix <inline-formula><mml:math id="inf190"><mml:mi>D</mml:mi></mml:math></inline-formula> has been completed, an optimal matching between the components of the two sessions is computed using the Hungarian algorithm to solve the linear assignment problem. As infinite distances are allowed, it is possible to have components from both sessions that are not matched with any other component, preventing false assignments and enabling the registration of sessions with different number of neurons. Moreover, the use of infinite distances speeds up the Hungarian algorithm as it significantly restricts the space of possible pairings. This process of registering components across two sessions (R<sc>egister</sc>P<sc>air</sc>) is summarized in Algorithm 7.</p><p>To register components across multiple sessions, we first order the sessions chronologically and register session 1 against session 2. From this registration we construct the union of the distinct components between the two sessions by keeping the matched components from session two as well as the non-matched components from both sessions aligned to the FOV of session 2. We then register this union of components to the components of session three and repeat the procedure until all sessions are have been registered. This process of multi session registration (R<sc>egister</sc>M<sc>ulti</sc>) is summarized in Algorithm 8. At the end of the process the algorithm produces a list of matches between the components of each session and the union of all active distinct components, allowing for efficient tracking of components across multiple days (<xref ref-type="fig" rid="fig9">Figure 9</xref>), and the comparison of non-consecutive sessions through the union without the need of direct pairwise registration (<xref ref-type="fig" rid="fig9s1">Figure 9—figure supplement 1</xref>). An alternative approach to the problem of multiple session registration (CellReg) was presented recently by <xref ref-type="bibr" rid="bib39">Sheintuch et al. (2017)</xref> where the authors register neurons across multiple days by first constructing a similar union set of all the components which is then refined using a clustering procedure. R<sc>egisterMulti</sc> differs from the CellReg method of <xref ref-type="bibr" rid="bib39">Sheintuch et al. (2017)</xref> along the following dimensions:</p><list list-type="bullet"><list-item><p>R<sc>egister</sc>M<sc>ulti</sc> uses a simple intersection over union metric to estimate the distance between two neighboring neurons after the FOV alignment. Cells that have a distance above a given threshold are considered distinct by default and are not tested for matching. This parameter has an intuitive interpretation and can be set a-priori for each dataset. By contrast, C<sc>ell</sc>R<sc>eg</sc> uses a probabilistic framework based on the joint probability distribution between the distance of two cells and the correlation of their shapes. Such choice makes specific parametric assumptions about the distributions of centroid distances between the same and different cells, as well as their shape correlations. This model must be re-evaluated for every different set of sessions to be registered and can require considerable data to learn the appropriate distance metric.</p></list-item><list-item><p>R<sc>egister</sc>M<sc>ulti</sc> uses the Hungarian algorithm to register two different set of components, solving the linear assignment problem optimally under the assumed distance function. In contrast C<sc>ell</sc>R<sc>eg</sc> uses a greedy method for initializing the assignment of cells to the union superset relying on the following clustering step to refine these estimates, adding extra computational burden to the registration procedure.</p></list-item></list></sec><sec id="s4-11"><title>Implementation details for C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc></title><p>Each dataset was processed using the same set of parameters, apart from the expected size of neurons (estimated by inspecting the correlation image), the size of patches and expected number of neurons per patch (estimated by inspecting the correlation image). For the dataset N.01.01, where optical modulation was induced, the threshold for merging neurons was slightly higher (the stimulation caused clustered synchronous activity). For shorter datasets, rigid motion correction was sufficient; for longer datasets K53, J115 we applied non-rigid motion correction. Parameters for the automatic selection of components were optimized using a grid search approach.</p><p>The global default parameters for all datasets were obtained by performing a grid search on the nine datasets over the following values: trace peak SNR threshold on the set <inline-formula><mml:math id="inf191"><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>1.75</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>2.25</mml:mn><mml:mo>,</mml:mo><mml:mn>2.5</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula>, spatial correlation threshold on the set <inline-formula><mml:math id="inf192"><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>0.75</mml:mn><mml:mo>,</mml:mo><mml:mn>0.8</mml:mn><mml:mo>,</mml:mo><mml:mn>0.85</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula>, lower threshold on CNN classifier (reject if prediction is below a certain value) on the set <inline-formula><mml:math id="inf193"><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>0.05</mml:mn><mml:mo>,</mml:mo><mml:mn>0.1</mml:mn><mml:mo>,</mml:mo><mml:mn>0.15</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula>, and upper threshold on classifier (accept if prediction is above a certain value) on the set <inline-formula><mml:math id="inf194"><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>0.9</mml:mn><mml:mo>,</mml:mo><mml:mn>.95</mml:mn><mml:mo>,</mml:mo><mml:mn>0.99</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula>. The best overall parameters (used for the results reported in <xref ref-type="table" rid="table1">Table 1</xref>) were given for the choice <inline-formula><mml:math id="inf195"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>0.85</mml:mn><mml:mo>,</mml:mo><mml:mn>0.1</mml:mn><mml:mo>,</mml:mo><mml:mn>0.99</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. For all datasets the background neuropil activity was modeled as a rank two matrix, and calcium dynamics were modeled as a first order autoregressive process. The remaining parameters were optimized so that all the datasets could be run on a machine with less than 128 GB RAM.</p></sec><sec id="s4-12"><title>Implementation details for C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc></title><p>Datasets were processed for two epochs with the exception of the longer datasets <monospace>J115, K53</monospace> where only one pass of the data was performed to limit computational cost. For all datasets the background neuropil activity was modeled as a rank two matrix, and calcium dynamics were modeled as a first order autoregressive process. For each dataset, C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> was initialized on the first 200 frames, using the B<sc>are</sc>I<sc>nitialization</sc> on the entire FOV with only two neurons, so in practice all the neurons were detected during the online mode. We did not post-process the results (which could have further enhanced performance) in order to demonstrate performance levels with fully online practices. As in batch processing, the expected size of neurons was chosen separately for each dataset after inspecting the correlation image. Several datasets (<monospace>N.03.00.t, N.02.00, J123, J115, K53</monospace>) were spatially decimated by a factor of 2 to enhance processing speed, a step that did not lead to changes in detection performance.</p><p>To select global parameters for all datasets we performed a grid search on all nine datasets by varying the following parameters: The peak SNR threshold for accepting a candidate component on the set <inline-formula><mml:math id="inf196"><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>0.6</mml:mn><mml:mo>,</mml:mo><mml:mn>0.8</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>1.2</mml:mn><mml:mo>,</mml:mo><mml:mn>1.4</mml:mn><mml:mo>,</mml:mo><mml:mn>1.6</mml:mn><mml:mo>,</mml:mo><mml:mn>1.8</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula>, the online CNN classifier threshold for accepting candidate components on the set <inline-formula><mml:math id="inf197"><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>0.5</mml:mn><mml:mo>,</mml:mo><mml:mn>0.55</mml:mn><mml:mo>,</mml:mo><mml:mn>0.6</mml:mn><mml:mo>,</mml:mo><mml:mn>0.65</mml:mn><mml:mo>,</mml:mo><mml:mn>0.7</mml:mn><mml:mo>,</mml:mo><mml:mn>0.75</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula>, and the number of candidate components per frame on the set <inline-formula><mml:math id="inf198"><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mn>7</mml:mn><mml:mo>,</mml:mo><mml:mn>10</mml:mn><mml:mo>,</mml:mo><mml:mn>14</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula>. The best overall parameters (reported in <xref ref-type="table" rid="table1">Table 1</xref>) were given for the choice <inline-formula><mml:math id="inf199"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1.2</mml:mn><mml:mo>,</mml:mo><mml:mn>0.65</mml:mn><mml:mo>,</mml:mo><mml:mn>10</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. This parameter choice was also the best when conditioning on the shorter six datasets. For the three longer datasets, the best parameter choice was <inline-formula><mml:math id="inf200"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>0.6</mml:mn><mml:mo>,</mml:mo><mml:mn>5</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, corresponding to a stricter set of parameters with less candidate components per frame (<xref ref-type="fig" rid="fig4s1">Figure 4—figure supplement 1</xref>).</p><p>For the analysis of the whole brain zebrafish dataset, C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> was run for one epoch with the same parameters as above, with only differences appearing in the number of neurons during initialization (600 vs 2), and the value of the threshold for the online CNN classifier (0.75 vs 0.5). The former decision was motivated by the goal of retrieving with a single pass neurons from a preparation with a denser level of activity over a larger FOV in this short dataset (1885 frames). To this end, the number of candidate neurons at each timestep was set to 10 (per plane). The threshold choice was motivated by the fact that the classifier was trained on mouse data only, and thus a higher threshold choice would help diminish potential false positive components. Rigid motion correction was applied online to each plane.</p></sec><sec id="s4-13"><title>Comparison with Suite2p</title><p>To compare C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> with Suite2p we used the MATLAB version of the Suite2p package (<xref ref-type="bibr" rid="bib27">Pachitariu et al., 2017</xref>). To select parameters for Suite2p we used a small grid search around the default values for the variables nSVDforROI, NavgFramesSVD, and sig. The classifier used by Suite2p was not re-trained for each dataset but used with the default values. For each case (with the classifier and without the classifier), the values that give the best <inline-formula><mml:math id="inf201"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> score in average are reported in <xref ref-type="fig" rid="fig4s2">Figure 4—figure supplement 2</xref>. The dataset <monospace>J123</monospace> was excluded from the comparison since (due its low SNR) Suite2p did not converge and kept adding a large number of neurons in each iteration. Use of the classifier improved the results on average, from <inline-formula><mml:math id="inf202"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> score <inline-formula><mml:math id="inf203"><mml:mrow><mml:mn>0.51</mml:mn><mml:mo>±</mml:mo><mml:mn>0.12</mml:mn></mml:mrow></mml:math></inline-formula> without the classifier to <inline-formula><mml:math id="inf204"><mml:mrow><mml:mn>0.55</mml:mn><mml:mo>±</mml:mo><mml:mn>0.12</mml:mn></mml:mrow></mml:math></inline-formula>, however the use of the classifier improved only four of the eight tested datasets in terms of the <inline-formula><mml:math id="inf205"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> score. As with C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> it is possible that dataset specific parameter choice can lead to improved results.</p></sec><sec id="s4-14"><title>Performance quantification as a function of SNR</title><p>To quantify performance as a function of SNR we construct the consensus traces by running C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>on the datasets seeded with the ‘consensus’ binary masks obtained from the manual annotators. Afterwards we obtain the average peak-SNR of a trace <inline-formula><mml:math id="inf206"><mml:mi mathvariant="bold">𝐜</mml:mi></mml:math></inline-formula> with corresponding residual signal <inline-formula><mml:math id="inf207"><mml:mi mathvariant="bold">𝐫</mml:mi></mml:math></inline-formula> (<xref ref-type="disp-formula" rid="equ5">Equation 5)</xref> is obtained as<disp-formula id="equ13"><label>(13)</label><mml:math id="m13"><mml:mrow><mml:mrow><mml:mrow><mml:mi>SNR</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold">𝐳</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>-</mml:mo><mml:mrow><mml:msup><mml:mi mathvariant="normal">Φ</mml:mi><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>min</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <inline-formula><mml:math id="inf208"><mml:mrow><mml:msup><mml:mi mathvariant="normal">Φ</mml:mi><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>⋅</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> denotes the probit function (quantile function for the standard Gaussian distribution), <inline-formula><mml:math id="inf209"><mml:mi mathvariant="bold">𝐳</mml:mi></mml:math></inline-formula> is the z-scored version of <inline-formula><mml:math id="inf210"><mml:mrow><mml:mi mathvariant="bold">𝐜</mml:mi><mml:mo>+</mml:mo><mml:mi mathvariant="bold">𝐫</mml:mi></mml:mrow></mml:math></inline-formula> (<xref ref-type="disp-formula" rid="equ6">Equation 6)</xref> and <inline-formula><mml:math id="inf211"><mml:msub><mml:mi>p</mml:mi><mml:mi>min</mml:mi></mml:msub></mml:math></inline-formula> is given by <xref ref-type="disp-formula" rid="equ8">Equation 8</xref>.</p><p>Let <inline-formula><mml:math id="inf212"><mml:mrow><mml:msubsup><mml:mi>c</mml:mi><mml:mn>1</mml:mn><mml:mi>gt</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mi>c</mml:mi><mml:mn>2</mml:mn><mml:mi>gt</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mi mathvariant="normal">…</mml:mi><mml:mo>,</mml:mo><mml:msubsup><mml:mi>c</mml:mi><mml:mi>N</mml:mi><mml:mi>gt</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> be the consensus traces and <inline-formula><mml:math id="inf213"><mml:mrow><mml:msubsup><mml:mi>c</mml:mi><mml:mn>1</mml:mn><mml:mi>cm</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mi>c</mml:mi><mml:mn>2</mml:mn><mml:mi>cm</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mi mathvariant="normal">…</mml:mi><mml:mo>,</mml:mo><mml:msubsup><mml:mi>c</mml:mi><mml:mi>N</mml:mi><mml:mi>cm</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> be their corresponding C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> inferred traces. Here we assume that false positive and false negative components are matched with trivial components that have 0 SNR. Let also <inline-formula><mml:math id="inf214"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mi mathvariant="normal">g</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>c</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">g</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula> and <inline-formula><mml:math id="inf215"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">m</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>c</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">m</mml:mi></mml:mrow></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula>, respectively. After we compute the SNR for both consensus and inferred traces the performance algorithm can be quantified in multiple ways as a function of a SNR thresholds <inline-formula><mml:math id="inf216"><mml:msub><mml:mi>θ</mml:mi><mml:mi>SNR</mml:mi></mml:msub></mml:math></inline-formula>:</p><p><bold>Precision</bold>: Precision at level <inline-formula><mml:math id="inf217"><mml:msub><mml:mi>θ</mml:mi><mml:mi>SNR</mml:mi></mml:msub></mml:math></inline-formula>, can be computed as the fraction of detected components with <inline-formula><mml:math id="inf218"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">m</mml:mi></mml:mrow></mml:mrow></mml:msup><mml:mo>&gt;</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mspace width="thinmathspace"/></mml:msub><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula> that are matched with consensus components. It quantifies the certainty that a component detected with a given SNR or above corresponds to a true component.<disp-formula id="equ14"><mml:math id="m14"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">C</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">m</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mspace width="thinmathspace"/><mml:mo>&gt;</mml:mo><mml:mspace width="thinmathspace"/><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mspace width="thickmathspace"/><mml:mspace width="thickmathspace"/><mml:mi mathvariant="normal">&amp;</mml:mi><mml:mspace width="thickmathspace"/><mml:mspace width="thickmathspace"/><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mi mathvariant="normal">g</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mspace width="thinmathspace"/><mml:mo>&gt;</mml:mo><mml:mspace width="thinmathspace"/><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">m</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mspace width="thinmathspace"/><mml:mo>&gt;</mml:mo><mml:mspace width="thinmathspace"/><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:mstyle></mml:math></disp-formula></p><p><bold>Recall</bold>: Recall at level <inline-formula><mml:math id="inf219"><mml:msub><mml:mi>θ</mml:mi><mml:mi>SNR</mml:mi></mml:msub></mml:math></inline-formula>, can be computed as the fraction of consensus components with <inline-formula><mml:math id="inf220"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">g</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:mrow></mml:msup><mml:mo>&gt;</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mspace width="thinmathspace"/></mml:msub><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula> that are detected by the algorithm. It quantifies the certainty that a consensus component with a given SNR or above is detected.<disp-formula id="equ15"><mml:math id="m15"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">L</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mi mathvariant="normal">g</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mspace width="thinmathspace"/><mml:mo>&gt;</mml:mo><mml:mspace width="thinmathspace"/><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mspace width="thickmathspace"/><mml:mspace width="thickmathspace"/><mml:mi mathvariant="normal">&amp;</mml:mi><mml:mspace width="thickmathspace"/><mml:mspace width="thickmathspace"/><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">m</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mspace width="thinmathspace"/><mml:mo>&gt;</mml:mo><mml:mspace width="thinmathspace"/><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mi mathvariant="normal">g</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mspace width="thinmathspace"/><mml:mo>&gt;</mml:mo><mml:mspace width="thinmathspace"/><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:mstyle></mml:math></disp-formula></p><p><inline-formula><mml:math id="inf221"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> <bold>Score</bold>: An overall <inline-formula><mml:math id="inf222"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> score at level <inline-formula><mml:math id="inf223"><mml:msub><mml:mi>θ</mml:mi><mml:mi>SNR</mml:mi></mml:msub></mml:math></inline-formula>, can be obtained by computing the harmonic mean between precision and recall<disp-formula id="equ16"><mml:math id="m16"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:msub><mml:mi mathvariant="normal">F</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mfrac><mml:mrow><mml:mrow><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">C</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:mrow><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">L</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">C</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mrow><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">L</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:mstyle></mml:math></disp-formula></p><p>The cautious reader will observe that the precision and recall quantities described above are not computed in the same set of components. This can be remedied by recomputing the quantities in two different ways:</p><p><bold>AND framework</bold>: Here we consider a match only if <italic>both</italic> traces have SNR above the given threshold:<disp-formula id="equ17"><mml:math id="m17"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">C</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">D</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mspace width="thinmathspace"/><mml:mo>=</mml:mo><mml:mspace width="thinmathspace"/><mml:mfrac><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">m</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mspace width="thinmathspace"/><mml:mo>&gt;</mml:mo><mml:mspace width="thinmathspace"/><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mspace width="thinmathspace"/><mml:mi mathvariant="normal">&amp;</mml:mi><mml:mspace width="thinmathspace"/><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mi mathvariant="normal">g</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mspace width="thinmathspace"/><mml:mo>&gt;</mml:mo><mml:mspace width="thinmathspace"/><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">m</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mspace width="thinmathspace"/><mml:mo>&gt;</mml:mo><mml:mspace width="thinmathspace"/><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:mstyle></mml:math></disp-formula><disp-formula id="equ18"><mml:math id="m18"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">L</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">D</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mspace width="thinmathspace"/><mml:mo>=</mml:mo><mml:mspace width="thinmathspace"/><mml:mfrac><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mi mathvariant="normal">g</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mspace width="thinmathspace"/><mml:mo>&gt;</mml:mo><mml:mspace width="thinmathspace"/><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mspace width="thinmathspace"/><mml:mi mathvariant="normal">&amp;</mml:mi><mml:mspace width="thinmathspace"/><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">m</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mspace width="thinmathspace"/><mml:mo>&gt;</mml:mo><mml:mspace width="thinmathspace"/><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mi mathvariant="normal">g</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mspace width="thinmathspace"/><mml:mo>&gt;</mml:mo><mml:mspace width="thinmathspace"/><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:mstyle></mml:math></disp-formula></p><p><bold>OR framework</bold>: Here we consider a match if <italic>either</italic> trace has SNR above the given threshold and its match has SNR above 0.<disp-formula id="equ19"><mml:math id="m19"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">L</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo form="prefix" movablelimits="true">max</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mi mathvariant="normal">g</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">m</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mspace width="thinmathspace"/><mml:mo>&gt;</mml:mo><mml:mspace width="thinmathspace"/><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mspace width="thinmathspace"/><mml:mi mathvariant="normal">&amp;</mml:mi><mml:mspace width="thinmathspace"/><mml:mo stretchy="false">(</mml:mo><mml:mo form="prefix" movablelimits="true">min</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mi mathvariant="normal">g</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">m</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mspace width="thinmathspace"/><mml:mo>&gt;</mml:mo><mml:mspace width="thinmathspace"/><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">m</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mspace width="thinmathspace"/><mml:mo>&gt;</mml:mo><mml:mspace width="thinmathspace"/><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:mstyle></mml:math></disp-formula><disp-formula id="equ20"><mml:math id="m20"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">L</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo form="prefix" movablelimits="true">max</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mi mathvariant="normal">g</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">m</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mspace width="thinmathspace"/><mml:mo>&gt;</mml:mo><mml:mspace width="thinmathspace"/><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mspace width="thinmathspace"/><mml:mi mathvariant="normal">&amp;</mml:mi><mml:mspace width="thinmathspace"/><mml:mo stretchy="false">(</mml:mo><mml:mo form="prefix" movablelimits="true">min</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mi mathvariant="normal">g</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">m</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mspace width="thinmathspace"/><mml:mo>&gt;</mml:mo><mml:mspace width="thinmathspace"/><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mi mathvariant="normal">g</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mspace width="thinmathspace"/><mml:mo>&gt;</mml:mo><mml:mspace width="thinmathspace"/><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:mstyle></mml:math></disp-formula></p><p>It is easy to show that<disp-formula id="equ21"><mml:math id="m21"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mtable columnalign="center center" columnspacing="1em" rowspacing="4pt"><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">C</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">D</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mrow><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">C</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">C</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">L</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">D</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mrow><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">L</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">L</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:msub><mml:mi mathvariant="normal">F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">D</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mrow><mml:msub><mml:mi mathvariant="normal">F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:msub><mml:mi mathvariant="normal">F</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mstyle></mml:math></disp-formula>with equality holding for <inline-formula><mml:math id="inf224"><mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mi>SNR</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. As demonstrated in <xref ref-type="fig" rid="fig4">Figure 4d</xref>, these bounds are tight.</p></sec><sec id="s4-15"><title>Additional features of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc></title><p> C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> contains a number of additional features that are not presented in the results section for reasons of brevity. These include:</p><sec id="s4-15-1"><title>Volumetric data processing</title><p>Apart from planar 2D data, C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc> is also applicable to 3D volumetric data collected via dense raster scanning methods or from direct volume imaging methods such as light field microscopy (<xref ref-type="bibr" rid="bib37">Prevedel et al., 2014</xref>; <xref ref-type="bibr" rid="bib19">Grosenick et al., 2017</xref>).</p></sec><sec id="s4-15-2"><title>Segmentation of structural indicator data</title><p>Structural indicators expressed in the nucleus and functional indicators expressed in the cytoplasm can facilitate source extraction and help identify silent or specific subpopulations of neurons (e.g., inhibitory). C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> provides a simple adaptive thresholding filtering method for segmenting summary images of the structural channel (e.g., mean image). The obtained results can be used for seeding source extraction from the functional channel in C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>or C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> as already discussed.</p></sec><sec id="s4-15-3"><title>Duplicate detection</title><p>The annotations obtained through the consensus process were screened for possible duplicate selections. To detect for duplicate components we define the degree of spatial overlap matrix <inline-formula><mml:math id="inf225"><mml:mi>O</mml:mi></mml:math></inline-formula> as<disp-formula id="equ22"><label>(14)</label><mml:math id="m22"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>O</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mtable columnalign="center center" columnspacing="1em" rowspacing="4pt"><mml:mtr><mml:mtd><mml:mn>0</mml:mn><mml:mo>,</mml:mo></mml:mtd><mml:mtd><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mi>j</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mfrac><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mspace width="thinmathspace"/><mml:mo>∩</mml:mo><mml:mspace width="thinmathspace"/><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:mtd><mml:mtd><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>j</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo fence="true" stretchy="true" symmetric="true"/></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:mstyle></mml:math></disp-formula>that defines the fraction of component <inline-formula><mml:math id="inf226"><mml:mi>i</mml:mi></mml:math></inline-formula> that overlap with component <inline-formula><mml:math id="inf227"><mml:mi>j</mml:mi></mml:math></inline-formula>, where <inline-formula><mml:math id="inf228"><mml:mrow><mml:mi>m</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>⋅</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is the thresholding function defined in <xref ref-type="disp-formula" rid="equ10">Equation 10</xref>. Any entry of <inline-formula><mml:math id="inf229"><mml:mi>O</mml:mi></mml:math></inline-formula> that is above a threshold <inline-formula><mml:math id="inf230"><mml:msub><mml:mi>θ</mml:mi><mml:mi>o</mml:mi></mml:msub></mml:math></inline-formula> (e.g., <inline-formula><mml:math id="inf231"><mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mi>o</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0.7</mml:mn></mml:mrow></mml:math></inline-formula> used here) indicates a pair of duplicate components. To decide which of the two components should be removed, we use predictions of the C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch </sc>CNN classifier, removing the component with the lowest score.</p></sec><sec id="s4-15-4"><title>Extraction of <inline-formula><mml:math id="inf232"><mml:mrow><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi><mml:mo>⁢</mml:mo><mml:mi>F</mml:mi></mml:mrow><mml:mo>/</mml:mo><mml:mi>F</mml:mi></mml:mrow></mml:math></inline-formula></title><p>The fluorescence trace <inline-formula><mml:math id="inf233"><mml:msub><mml:mi mathvariant="bold">𝐟</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> of component <inline-formula><mml:math id="inf234"><mml:mi>i</mml:mi></mml:math></inline-formula> can be written as<disp-formula id="equ23"><label>(15)</label><mml:math id="m23"><mml:mrow><mml:mrow><mml:msub><mml:mi mathvariant="bold">𝐟</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mo>∥</mml:mo><mml:msub><mml:mi mathvariant="bold">𝐚</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∥</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi mathvariant="bold">𝐜</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi mathvariant="bold">𝐫</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p>The fluorescence due to the component’s transients overlaps with a background fluorescence due to baseline fluorescence of the component and neuropil activity, that can be expressed as<disp-formula id="equ24"><label>(16)</label><mml:math id="m24"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="normal">B</mml:mi><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mspace width="thinmathspace"/><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msup><mml:mi>B</mml:mi><mml:mrow><mml:mi mathvariant="normal">⊤</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mstyle></mml:math></disp-formula>where <inline-formula><mml:math id="inf235"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mi mathvariant="normal">B</mml:mi><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mo>:</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">↦</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mstyle></mml:math></inline-formula> is a baseline extraction function, and <inline-formula><mml:math id="inf236"><mml:mi>B</mml:mi></mml:math></inline-formula> is the estimated background signal. Examples of the baseline extraction function are a percentile function (e.g., 10th percentile), or a for longer traces, a running percentile function, for example 10th percentile over a window of a hundred seconds (computing the exact running percentile function can be computationally intensive. To reduce the complexity we compute the running percentile with a stride of <inline-formula><mml:math id="inf237"><mml:mi>W</mml:mi></mml:math></inline-formula>, where <inline-formula><mml:math id="inf238"><mml:mi>W</mml:mi></mml:math></inline-formula> is equal or smaller to the length of the window, and then linearly interpolate the values). To determine the optimal percentile level an empirical histogram of the trace (or parts of it in case of long traces) is computed using a diffusion kernel density estimator (<xref ref-type="bibr" rid="bib4">Botev et al., 2010</xref>), and the mode of this density is used to define the baseline and its corresponding percentile level. The <inline-formula><mml:math id="inf239"><mml:mrow><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi><mml:mo>⁢</mml:mo><mml:mi>F</mml:mi></mml:mrow><mml:mo>/</mml:mo><mml:mi>F</mml:mi></mml:mrow></mml:math></inline-formula> activity of component <inline-formula><mml:math id="inf240"><mml:mi>i</mml:mi></mml:math></inline-formula> can then be written as<disp-formula id="equ25"><label>(17)</label><mml:math id="m25"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi><mml:mi>F</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>F</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mrow><mml:mi mathvariant="normal">B</mml:mi><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mspace width="thinmathspace"/><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mfrac></mml:mrow></mml:mstyle></mml:math></disp-formula></p><p>The approach we propose here is conceptually similar to practical approaches where the <inline-formula><mml:math id="inf241"><mml:mrow><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi><mml:mo>⁢</mml:mo><mml:mi>F</mml:mi></mml:mrow><mml:mo>/</mml:mo><mml:mi>F</mml:mi></mml:mrow></mml:math></inline-formula> is computed by averaging over the spatial extent of an ROI (<xref ref-type="bibr" rid="bib20">Jia et al., 2011</xref>) with some differences: (i) instead of averaging with a binary mask we use the a weighed average with the shape of each component, (ii) signal due to overlapping components is removed from the calculation of the background fluorescence, and (iii) the traces have been extracted through the CNMF process prior to the <inline-formula><mml:math id="inf242"><mml:mrow><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi><mml:mo>⁢</mml:mo><mml:mi>F</mml:mi></mml:mrow><mml:mo>/</mml:mo><mml:mi>F</mml:mi></mml:mrow></mml:math></inline-formula> extraction. Note that the same approach can also be performed to the trace <inline-formula><mml:math id="inf243"><mml:mrow><mml:msup><mml:mrow><mml:mo>∥</mml:mo><mml:msub><mml:mi mathvariant="bold">𝐚</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∥</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>⁢</mml:mo><mml:msub><mml:mi mathvariant="bold">𝐜</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> that does not include the residual traces for each component. In practice it can be beneficial to extract <inline-formula><mml:math id="inf244"><mml:mrow><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi><mml:mo>⁢</mml:mo><mml:mi>F</mml:mi></mml:mrow><mml:mo>/</mml:mo><mml:mi>F</mml:mi></mml:mrow></mml:math></inline-formula> traces prior to deconvolution, since the <inline-formula><mml:math id="inf245"><mml:mrow><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi><mml:mo>⁢</mml:mo><mml:mi>F</mml:mi></mml:mrow><mml:mo>/</mml:mo><mml:mi>F</mml:mi></mml:mrow></mml:math></inline-formula> transformation can alleviate the effects of drifting baselines, for example due to bleaching. For the non-deconvolved traces <inline-formula><mml:math id="inf246"><mml:msub><mml:mi mathvariant="bold">𝐟</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> some temporal smoothing can also be applied to obtain more smooth <inline-formula><mml:math id="inf247"><mml:mrow><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi><mml:mo>⁢</mml:mo><mml:mi>F</mml:mi></mml:mrow><mml:mo>/</mml:mo><mml:mi>F</mml:mi></mml:mrow></mml:math></inline-formula> traces.</p></sec></sec><sec id="s4-16"><title>Algorithmic details</title><p>In the following we present in pseudocode form several of the routines introduced and used by C<sc>a</sc>I<sc>m</sc>A<sc>n</sc>. Note that the pseudocode descriptions do not aim to present a complete picture and may refer to other work for some of the steps.</p><table-wrap id="inlinetable1" position="anchor"><table frame="hsides" rules="groups"><thead><tr><th colspan="3">Algorithm 1: P<sc>rocess</sc>I<sc>n</sc>P<sc>atches</sc></th></tr></thead><tbody><tr valign="top"><td colspan="3"><bold>Require:</bold> Input data matrix <inline-formula><mml:math id="inf248"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>Y</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula>, patch size, overlap size, initialization method, rest of parameters.</td></tr><tr valign="top"><td>1:</td><td><inline-formula><mml:math id="inf249"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msup><mml:mi>Y</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mi>Y</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="normal">C</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">U</mml:mi><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathvariant="normal">T</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">P</mml:mi><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mrow><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathvariant="normal">H</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">S</mml:mi></mml:mrow></mml:mrow></mml:mstyle></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>Y</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>o</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Break data into memory mapped patches.</td></tr><tr valign="top"><td>2:</td><td><bold>for</bold> <inline-formula><mml:math id="inf250"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi mathvariant="normal">…</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> <bold>do</bold></td><td align="right">Process each patch</td></tr><tr valign="top"><td>3:</td><td>       <inline-formula><mml:math id="inf251"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mi>A</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>C</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="normal">C</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">F</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>Y</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">p</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">s</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Run CNMF on each patch</td></tr><tr valign="top"><td>4:</td><td><bold>end for</bold></td><td align="right"/></tr><tr valign="top"><td>5:</td><td><inline-formula><mml:math id="inf252"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="normal">M</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">G</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">C</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">S</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:msup><mml:mi>A</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>C</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msub><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Merge components</td></tr><tr valign="top"><td>6:</td><td><inline-formula><mml:math id="inf253"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="normal">M</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">G</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">B</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathvariant="normal">K</mml:mi><mml:mi mathvariant="normal">G</mml:mi><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">U</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">D</mml:mi><mml:mi mathvariant="normal">S</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msub><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Merge background components</td></tr><tr valign="top"><td>7:</td><td><inline-formula><mml:math id="inf254"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">←</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mspace width="thinmathspace"/><mml:mo>&gt;</mml:mo><mml:mspace width="thinmathspace"/><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Find masks of spatial footprints.</td></tr><tr valign="top"><td>8:</td><td><bold>repeat</bold></td><td align="right">Optionally keep updating <inline-formula><mml:math id="inf255"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mspace width="thinmathspace"/><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mspace width="thinmathspace"/><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:mspace width="thinmathspace"/><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula> using HALS (<xref ref-type="bibr" rid="bib10">Cichocki et al., 2007</xref>).</td></tr><tr valign="top"><td>9:</td><td>       <inline-formula><mml:math id="inf256"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">←</mml:mo><mml:mi mathvariant="normal">N</mml:mi><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">F</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Y</mml:mi><mml:mo>−</mml:mo><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">C</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="normal">n</mml:mi><mml:mrow><mml:mi mathvariant="normal">b</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right"/></tr><tr valign="top"><td>10:</td><td>       <inline-formula><mml:math id="inf257"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">←</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">g</mml:mi><mml:mspace width="thinmathspace"/><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">n</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mspace width="thinmathspace"/><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mi>Y</mml:mi><mml:mo>−</mml:mo><mml:mrow><mml:mi mathvariant="bold">b</mml:mi><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mo>−</mml:mo><mml:mi>A</mml:mi><mml:mi>C</mml:mi><mml:mo fence="false" stretchy="false">‖</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right"/></tr><tr valign="top"><td>11:</td><td>        <inline-formula><mml:math id="inf258"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>A</mml:mi><mml:mo stretchy="false">←</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">g</mml:mi><mml:mspace width="thinmathspace"/><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">n</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>∼</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>==</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mspace width="thinmathspace"/><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mi>Y</mml:mi><mml:mo>−</mml:mo><mml:mrow><mml:mi mathvariant="bold">b</mml:mi><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mo>−</mml:mo><mml:mi>A</mml:mi><mml:mi>C</mml:mi><mml:mo fence="false" stretchy="false">‖</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right"/></tr><tr valign="top"><td>12:</td><td><bold>until</bold> Convergence</td><td align="right"/></tr><tr valign="top"><td>13:</td><td><bold>return</bold> <inline-formula><mml:math id="inf259"><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">𝐛</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">𝐟</mml:mi></mml:mrow></mml:math></inline-formula></td><td align="right"/></tr></tbody></table></table-wrap><table-wrap id="inlinetable2" position="anchor"><table frame="hsides" rules="groups"><thead><tr><th colspan="3">Algorithm 2 C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>batch</sc></th></tr></thead><tbody><tr valign="top"><td colspan="3"><bold>Require:</bold> Input data matrix <inline-formula><mml:math id="inf260"><mml:mi>Y</mml:mi></mml:math></inline-formula>, rest of parameters.</td></tr><tr valign="top"><td>1:</td><td><inline-formula><mml:math id="inf261"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>Y</mml:mi><mml:mo stretchy="false">←</mml:mo><mml:mrow><mml:mi mathvariant="normal">N</mml:mi><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">M</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mspace width="thinmathspace"/><mml:mrow><mml:mi mathvariant="normal">C</mml:mi><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>Y</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="normal">p</mml:mi><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">s</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Motion Correction (<xref ref-type="bibr" rid="bib34">Pnevmatikakis and Giovannucci, 2017</xref>)</td></tr><tr valign="top"><td>2:</td><td><inline-formula><mml:math id="inf262"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="normal">P</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">S</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">I</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mi mathvariant="normal">N</mml:mi></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">P</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathvariant="normal">H</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">S</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>Y</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="normal">p</mml:mi><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">s</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Run CNMF in patches Algorithm 1</td></tr><tr valign="top"><td>3:</td><td><inline-formula><mml:math id="inf263"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>J</mml:mi><mml:mo stretchy="false">←</mml:mo><mml:mrow><mml:mi mathvariant="normal">E</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">Q</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">U</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">Y</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>Y</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mtext>params</mml:mtext></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Get indeces of accepted components</td></tr><tr valign="top"><td>4:</td><td><inline-formula><mml:math id="inf264"><mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:mo>←</mml:mo><mml:mrow><mml:mi>A</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mo>:</mml:mo><mml:mo>,</mml:mo><mml:mi>J</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mo rspace="12.5pt">,</mml:mo><mml:mrow><mml:mi>C</mml:mi><mml:mo>←</mml:mo><mml:mrow><mml:mi>C</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>J</mml:mi><mml:mo>,</mml:mo><mml:mo>:</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="right">Disregard rejected components</td></tr><tr valign="top"><td>5:</td><td><inline-formula><mml:math id="inf265"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">←</mml:mo><mml:mrow><mml:mi mathvariant="normal">N</mml:mi></mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">F</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Y</mml:mi><mml:mo>−</mml:mo><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">C</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="normal">n</mml:mi><mml:mrow><mml:mi mathvariant="normal">b</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right"/></tr><tr valign="top"><td>6:</td><td><inline-formula><mml:math id="inf266"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">←</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">g</mml:mi><mml:mspace width="thinmathspace"/><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">n</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mspace width="thinmathspace"/><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mi>Y</mml:mi><mml:mo>−</mml:mo><mml:mrow><mml:mi mathvariant="bold">b</mml:mi><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mo>−</mml:mo><mml:mi>A</mml:mi><mml:mi>C</mml:mi><mml:mo fence="false" stretchy="false">‖</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right"/></tr><tr valign="top"><td>7:</td><td><inline-formula><mml:math id="inf267"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>A</mml:mi><mml:mo stretchy="false">←</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">g</mml:mi><mml:mspace width="thinmathspace"/><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">n</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>∼</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>==</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mspace width="thinmathspace"/><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mi>Y</mml:mi><mml:mo>−</mml:mo><mml:mrow><mml:mi mathvariant="bold">b</mml:mi><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mo>−</mml:mo><mml:mi>A</mml:mi><mml:mi>C</mml:mi><mml:mo fence="false" stretchy="false">‖</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Refit (optional)</td></tr><tr valign="top"><td>8:</td><td><bold>return</bold> <inline-formula><mml:math id="inf268"><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">𝐛</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">𝐟</mml:mi></mml:mrow></mml:math></inline-formula></td><td align="right"/></tr></tbody></table></table-wrap><table-wrap id="inlinetable3" position="anchor"><table frame="hsides" rules="groups"><thead><tr><th colspan="3">Algorithm 3: S<sc>eeded</sc>I<sc>nitialization</sc></th></tr></thead><tbody><tr valign="top"><td colspan="3"><bold>Require:</bold> Input data matrix <inline-formula><mml:math id="inf269"><mml:mi>Y</mml:mi></mml:math></inline-formula>, matrix of binary masks <inline-formula><mml:math id="inf270"><mml:mi>M</mml:mi></mml:math></inline-formula>, number of background components <inline-formula><mml:math id="inf271"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td></tr><tr valign="top"><td>1:</td><td><inline-formula><mml:math id="inf272"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mi mathvariant="bold">p</mml:mi></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="normal">f</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">d</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mo>==</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Find the pixels not covered by any component.</td></tr><tr valign="top"><td>2:</td><td><inline-formula><mml:math id="inf273"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mo>∼</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">←</mml:mo><mml:mrow><mml:mi mathvariant="normal">N</mml:mi><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">F</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>Y</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mi mathvariant="bold">p</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:mo>:</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Run NMF on these pixels just to get temporal backgrounds <inline-formula><mml:math id="inf274"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula></td></tr><tr valign="top"><td>3:</td><td><inline-formula><mml:math id="inf275"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mo stretchy="false">←</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">g</mml:mi><mml:mspace width="thinmathspace"/><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mspace width="thinmathspace"/><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mi>Y</mml:mi><mml:mo>−</mml:mo><mml:mrow><mml:mi mathvariant="bold">b</mml:mi><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mo fence="false" stretchy="false">‖</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Obtain spatial background <inline-formula><mml:math id="inf276"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula>.</td></tr><tr valign="top"><td>4:</td><td><inline-formula><mml:math id="inf277"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">←</mml:mo><mml:mo form="prefix" movablelimits="true">max</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:mi mathvariant="normal">⊤</mml:mi></mml:mrow></mml:msup><mml:mi>M</mml:mi><mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:mi mathvariant="normal">⊤</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>Y</mml:mi><mml:mo>−</mml:mo><mml:mrow><mml:mi mathvariant="bold">b</mml:mi><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Initialize temporal traces.</td></tr><tr valign="top"><td>5:</td><td><inline-formula><mml:math id="inf278"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>A</mml:mi><mml:mo stretchy="false">←</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">g</mml:mi><mml:mspace width="thinmathspace"/><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">n</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>∼</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>==</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mi>Y</mml:mi><mml:mo>−</mml:mo><mml:mrow><mml:mi mathvariant="bold">b</mml:mi><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mo>−</mml:mo><mml:mi>A</mml:mi><mml:mi>C</mml:mi><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Initialize spatial footprints constrained within the masks.</td></tr><tr valign="top"><td>6:</td><td><bold>repeat</bold></td><td align="right">Optionally keep updating <inline-formula><mml:math id="inf279"><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">𝐛</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">𝐟</mml:mi></mml:mrow></mml:math></inline-formula> using HALS</td></tr><tr valign="top"><td>7:</td><td>       <inline-formula><mml:math id="inf280"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">←</mml:mo><mml:mrow><mml:mi mathvariant="normal">N</mml:mi><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">F</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>Y</mml:mi><mml:mo>−</mml:mo><mml:mi>A</mml:mi><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right"/></tr><tr valign="top"><td>8:</td><td>       <inline-formula><mml:math id="inf281"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">←</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">g</mml:mi><mml:mspace width="thinmathspace"/><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">n</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mspace width="thinmathspace"/><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mi>Y</mml:mi><mml:mo>−</mml:mo><mml:mrow><mml:mi mathvariant="bold">b</mml:mi><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mo>−</mml:mo><mml:mi>A</mml:mi><mml:mi>C</mml:mi><mml:mo fence="false" stretchy="false">‖</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right"/></tr><tr valign="top"><td>9:</td><td>       <inline-formula><mml:math id="inf282"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>A</mml:mi><mml:mo stretchy="false">←</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">g</mml:mi><mml:mspace width="thinmathspace"/><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">n</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>∼</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>==</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mspace width="thinmathspace"/><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mi>Y</mml:mi><mml:mo>−</mml:mo><mml:mrow><mml:mi mathvariant="bold">b</mml:mi><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mo>−</mml:mo><mml:mi>A</mml:mi><mml:mi>C</mml:mi><mml:mo fence="false" stretchy="false">‖</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right"/></tr><tr valign="top"><td>10:</td><td><bold>until</bold> Convergence</td><td align="right"/></tr><tr valign="top"><td>11:</td><td><bold>return</bold> <inline-formula><mml:math id="inf283"><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">𝐛</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">𝐟</mml:mi></mml:mrow></mml:math></inline-formula></td><td align="right"/></tr></tbody></table></table-wrap><table-wrap id="inlinetable4" position="anchor"><table frame="hsides" rules="groups"><thead><tr><th colspan="3">Algorithm 4 C<sc>a</sc>I<sc>m</sc>A<sc>n</sc> <sc>online</sc> (See <xref ref-type="bibr" rid="bib17">Giovannucci et al., 2017</xref> for explanation of routines)</th></tr></thead><tbody><tr valign="top"><td colspan="3"><bold>Require:</bold> Data matrix <inline-formula><mml:math id="inf284"><mml:mi>Y</mml:mi></mml:math></inline-formula>, initial estimates <inline-formula><mml:math id="inf285"><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">𝐛</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">𝐟</mml:mi><mml:mo>,</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula>, current number of components <inline-formula><mml:math id="inf286"><mml:mi>K</mml:mi></mml:math></inline-formula>, current timestep <inline-formula><mml:math id="inf287"><mml:msup><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:math></inline-formula>, rest of parameters.</td></tr><tr valign="top"><td>1:</td><td><inline-formula><mml:math id="inf288"><mml:mrow><mml:mi>W</mml:mi><mml:mo>=</mml:mo><mml:mi>Y</mml:mi><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mo>:</mml:mo><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>:</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:msup><mml:mi>C</mml:mi><mml:mo>⊤</mml:mo></mml:msup><mml:mo>/</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mrow><mml:mi>M</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:mi>C</mml:mi><mml:mo>⁢</mml:mo><mml:msup><mml:mi>C</mml:mi><mml:mo>⊤</mml:mo></mml:msup></mml:mrow><mml:mo>/</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="right"/></tr><tr valign="top"><td>2:</td><td><inline-formula><mml:math id="inf289"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>M</mml:mi><mml:mo>=</mml:mo><mml:mi>C</mml:mi><mml:msup><mml:mi>C</mml:mi><mml:mrow><mml:mi mathvariant="normal">⊤</mml:mi></mml:mrow></mml:msup><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Initialize sufficient statistics (<xref ref-type="bibr" rid="bib17">Giovannucci et al., 2017</xref>)</td></tr><tr valign="top"><td>3:</td><td><inline-formula><mml:math id="inf290"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mi mathvariant="script">𝒢</mml:mi></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:mi mathvariant="normal">D</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">G</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">U</mml:mi><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">S</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>K</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">(<xref ref-type="bibr" rid="bib17">Giovannucci et al., 2017</xref>, Algorithm S1-S2)</td></tr><tr valign="top"><td>4:</td><td><inline-formula><mml:math id="inf291"><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mtext>buf</mml:mtext></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>Y</mml:mi><mml:mo>-</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">𝐛</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>C</mml:mi><mml:mo>;</mml:mo><mml:mi mathvariant="bold">𝐟</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mo>:</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>-</mml:mo><mml:msub><mml:mi>l</mml:mi><mml:mi>b</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>:</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="right">Initialize residual buffer</td></tr><tr valign="top"><td>5:</td><td><inline-formula><mml:math id="inf292"><mml:mrow><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi mathvariant="normal">…</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>epochs</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="right"/></tr><tr valign="top"><td>6:</td><td><bold>for</bold> <inline-formula><mml:math id="inf293"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">p</mml:mi><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">h</mml:mi><mml:mi mathvariant="normal">s</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula> <bold>do</bold></td><td align="right"/></tr><tr valign="top"><td>7:</td><td>     <bold>While</bold> there is more data <bold>do</bold></td><td align="right"/></tr><tr valign="top"><td>8:</td><td>          <inline-formula><mml:math id="inf294"><mml:mrow><mml:mi>t</mml:mi><mml:mo>←</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mi mathvariant="bold">𝐲</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:mrow><mml:mtext mathvariant="normal">MotionCorrect</mml:mtext><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="bold">𝐲</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold">𝐛𝐟</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="right"/></tr><tr valign="top"><td>9:</td><td>          <inline-formula><mml:math id="inf295"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">y</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">←</mml:mo><mml:mrow><mml:mrow><mml:mi mathvariant="normal">M</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">N</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">C</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathvariant="normal">T</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">y</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">(<xref ref-type="bibr" rid="bib34">Pnevmatikakis and Giovannucci, 2017</xref>)</td></tr><tr valign="top"><td>10:</td><td>          <inline-formula><mml:math id="inf296"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>;</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">←</mml:mo><mml:mrow><mml:mrow><mml:mi mathvariant="normal">U</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">D</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">T</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">S</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>;</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">y</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="script">𝒢</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">(<xref ref-type="bibr" rid="bib17">Giovannucci et al., 2017</xref>, Algorithm S3)</td></tr><tr valign="top"><td>11:</td><td>          <inline-formula><mml:math id="inf297"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">←</mml:mo><mml:mrow><mml:mrow><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">S</mml:mi></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>γ</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>λ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">(<xref ref-type="bibr" rid="bib16">Friedrich et al., 2017b</xref>)</td></tr><tr valign="top"><td>12:</td><td>          <inline-formula><mml:math id="inf298"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">w</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">w</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">←</mml:mo><mml:mrow><mml:mrow><mml:mi mathvariant="normal">F</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">D</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">N</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">W</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">C</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">S</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:mrow><mml:mtext>buf</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mrow><mml:mrow><mml:mtext>comp</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Algorithm 5</td></tr><tr valign="top"><td>13:</td><td colspan="2">          <inline-formula><mml:math id="inf299"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>K</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="script">𝒢</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:mrow><mml:mtext>buf</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>W</mml:mi><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">←</mml:mo><mml:mrow><mml:mrow><mml:mi mathvariant="normal">I</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">G</mml:mi><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">N</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">W</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">C</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">S</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td></tr><tr valign="top"><td>14:</td><td>               <inline-formula><mml:math id="inf300"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>K</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="script">𝒢</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">w</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">w</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:mrow><mml:mtext>buf</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">y</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>W</mml:mi><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">(<xref ref-type="bibr" rid="bib17">Giovannucci et al., 2017</xref>, Algorithm S4)</td></tr><tr valign="top"><td>15:</td><td>          <inline-formula><mml:math id="inf301"><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mtext>buf</mml:mtext></mml:msub><mml:mo>←</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mtext>buf</mml:mtext></mml:msub><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mo>:</mml:mo><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>:</mml:mo><mml:msub><mml:mi>l</mml:mi><mml:mi>b</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold">𝐲</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>-</mml:mo><mml:mi>A</mml:mi><mml:msub><mml:mi mathvariant="bold">𝐜</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mi mathvariant="bold">𝐛𝐟</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="right">Update residual buffer</td></tr><tr valign="top"><td>16:</td><td>          <inline-formula><mml:math id="inf302"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>W</mml:mi><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">←</mml:mo><mml:mrow><mml:mrow><mml:mi mathvariant="normal">U</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">D</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">U</mml:mi><mml:mi mathvariant="normal">F</mml:mi><mml:mi mathvariant="normal">F</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathvariant="normal">S</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>W</mml:mi><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">y</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>;</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right"/></tr><tr valign="top"><td>17:</td><td>          <inline-formula><mml:math id="inf303"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo stretchy="false">←</mml:mo><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">H</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">U</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">D</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">I</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">D</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">S</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">w</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Indeces of components to get updated, Algorithm S6</td></tr><tr valign="top"><td>18:</td><td>          <inline-formula><mml:math id="inf304"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">←</mml:mo><mml:mrow><mml:mi mathvariant="normal">U</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">D</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">H</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">S</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>W</mml:mi><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">(<xref ref-type="bibr" rid="bib17">Giovannucci et al., 2017</xref>, Algorithm S5)</td></tr><tr valign="top"><td>19:</td><td>     <bold>end while</bold></td><td align="right"/></tr><tr valign="top"><td>20:</td><td><inline-formula><mml:math id="inf305"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>t</mml:mi><mml:mspace width="thinmathspace"/><mml:mo stretchy="false">←</mml:mo><mml:mspace width="thinmathspace"/><mml:mn>0</mml:mn></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right"/></tr><tr valign="top"><td>21:</td><td><bold>end for</bold></td><td align="right"/></tr><tr valign="top"><td>22:</td><td><bold>return</bold> <inline-formula><mml:math id="inf306"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="bold">f</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right"/></tr></tbody></table></table-wrap><table-wrap id="inlinetable5" position="anchor"><table frame="hsides" rules="groups"><thead><tr><th colspan="3">Algorithm 5: F<sc>ind</sc>N<sc>ew</sc>C<sc>omponents</sc></th></tr></thead><tbody><tr valign="top"><td colspan="3"><bold>Require</bold>: Residual buffer <inline-formula><mml:math id="inf307"><mml:msub><mml:mi>R</mml:mi><mml:mtext>buf</mml:mtext></mml:msub></mml:math></inline-formula>, number of new candidate components <inline-formula><mml:math id="inf308"><mml:msub><mml:mi>N</mml:mi><mml:mtext>comp</mml:mtext></mml:msub></mml:math></inline-formula>, neuron radius <inline-formula><mml:math id="inf309"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>r</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td></tr><tr valign="top"><td>1:</td><td><inline-formula><mml:math id="inf310"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>E</mml:mi><mml:mo stretchy="false">←</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mi>t</mml:mi></mml:munder><mml:mo form="prefix" movablelimits="true">max</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">b</mml:mi><mml:mi mathvariant="normal">u</mml:mi><mml:mi mathvariant="normal">f</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right"/></tr><tr valign="top"><td>2:</td><td><inline-formula><mml:math id="inf311"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>E</mml:mi><mml:mo stretchy="false">←</mml:mo><mml:mrow><mml:mrow><mml:mi mathvariant="normal">H</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">G</mml:mi><mml:mi mathvariant="normal">H</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">P</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">S</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">F</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Spatial high pass filtering for contrast enhancement.</td></tr><tr valign="top"><td>3:</td><td><inline-formula><mml:math id="inf312"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:mi mathvariant="normal">F</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">D</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">L</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">L</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">P</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">K</mml:mi><mml:mi mathvariant="normal">S</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>E</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">p</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Find local maxima at least 2<italic>r </italic>apart.</td></tr><tr valign="top"><td>4:</td><td><inline-formula><mml:math id="inf313"><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mi>test</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:mi mathvariant="normal">∅</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo>∈</mml:mo><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>:</mml:mo><mml:mrow><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo>-</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo>≤</mml:mo><mml:mi>r</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mrow><mml:mi>y</mml:mi><mml:mo>-</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>y</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo>≤</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:mrow><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="right"/></tr><tr valign="top"><td>5:</td><td><bold>for</bold> <inline-formula><mml:math id="inf314"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>p</mml:mi><mml:mo>∈</mml:mo><mml:mi>P</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> <bold>do</bold></td><td align="right"/></tr><tr valign="top"><td>6:</td><td>       <inline-formula><mml:math id="inf315"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mi>x</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo>≤</mml:mo><mml:mi>r</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mi>y</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo>≤</mml:mo><mml:mi>r</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Define a neighborhood around <italic>p</italic></td></tr><tr valign="top"><td>7:</td><td>       <inline-formula><mml:math id="inf316"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">←</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:mrow><mml:mrow><mml:mi mathvariant="normal">M</mml:mi><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">N</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">b</mml:mi><mml:mi mathvariant="normal">u</mml:mi><mml:mi mathvariant="normal">f</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right"/></tr><tr valign="top"><td>8:</td><td><bold>end for</bold></td><td align="right"/></tr><tr valign="top"><td>9:</td><td><inline-formula><mml:math id="inf317"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">p</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">←</mml:mo><mml:mrow><mml:mrow><mml:mi mathvariant="normal">O</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">C</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">C</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">C</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">F</mml:mi><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Find indeces of accepted components</td></tr><tr valign="top"><td>10:</td><td><inline-formula><mml:math id="inf318"><mml:mrow><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mi>new</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:mi mathvariant="normal">∅</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi>new</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:mi mathvariant="normal">∅</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mi>accept</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="bold">𝐚</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">𝐜</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>←</mml:mo><mml:mrow><mml:mtext mathvariant="normal">NNMF</mml:mtext><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mi>buf</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:msup><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msup></mml:msub><mml:mo>,</mml:mo><mml:mo>:</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mi>new</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mi>new</mml:mi></mml:msub><mml:mo>∪</mml:mo><mml:mi mathvariant="bold">𝐚</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi>new</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi>new</mml:mi></mml:msub><mml:mo>∪</mml:mo><mml:mi mathvariant="bold">𝐜</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mi>new</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>new</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula></td><td align="right"/></tr><tr valign="top"><td>11;</td><td><bold>for </bold><inline-formula><mml:math id="inf319"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">p</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> <bold>do</bold></td><td align="right"/></tr><tr valign="top"><td>12:</td><td>       <inline-formula><mml:math id="inf320"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">←</mml:mo><mml:mrow><mml:mrow><mml:mi mathvariant="normal">N</mml:mi><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">F</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">b</mml:mi><mml:mi mathvariant="normal">u</mml:mi><mml:mi mathvariant="normal">f</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mrow><mml:msup><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msup></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>:</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right"/></tr><tr valign="top"><td>13:</td><td>       <inline-formula><mml:math id="inf321"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">w</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">←</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">w</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right"/></tr><tr valign="top"><td>14:</td><td>       <inline-formula><mml:math id="inf322"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">w</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">←</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">w</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right"/></tr><tr valign="top"><td>15:</td><td><bold>end for</bold></td><td align="right"/></tr><tr valign="top"><td>16:</td><td><bold>return</bold> <inline-formula><mml:math id="inf323"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">w</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">w</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right"/></tr></tbody></table></table-wrap><table-wrap id="inlinetable6" position="anchor"><table frame="hsides" rules="groups"><thead><tr><th colspan="3">Algorithm 6: S<sc>hape</sc>U<sc>pdate</sc>I<sc>ndeces</sc></th></tr></thead><tbody><tr valign="top"><td colspan="3"><bold>Require:</bold> Set of spatial footprints <inline-formula><mml:math id="inf324"><mml:mi>A</mml:mi></mml:math></inline-formula>, indeces of newly added components <inline-formula><mml:math id="inf325"><mml:mi>J</mml:mi></mml:math></inline-formula>, update vector <inline-formula><mml:math id="inf326"><mml:mi mathvariant="bold">𝐪</mml:mi></mml:math></inline-formula>, update period <inline-formula><mml:math id="inf327"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula>, current step in online mode <inline-formula><mml:math id="inf328"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula>.</td></tr><tr valign="top"><td>1:</td><td><bold>if</bold> t = 0 <bold>then</bold></td><td align="right">Initialize vector at the beginning of online mode.</td></tr><tr valign="top"><td>2:</td><td>      <inline-formula><mml:math id="inf329"><mml:mrow><mml:mi>q</mml:mi><mml:mo>←</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mi mathvariant="normal">…</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula></td><td align="right">Values logarithmically spaced between 1 and 2.</td></tr><tr valign="top"><td>3:</td><td><bold>end if</bold></td><td align="right"/></tr><tr valign="top"><td>4:</td><td><inline-formula><mml:math id="inf330"><mml:mrow><mml:mi mathvariant="bold">𝐪</mml:mi><mml:mo>←</mml:mo><mml:mrow><mml:mi mathvariant="bold">𝐪</mml:mi><mml:mo>×</mml:mo><mml:msup><mml:mn>0.5</mml:mn><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:mrow><mml:mrow><mml:mi>J</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="normal">∅</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:mrow><mml:msub><mml:mi>q</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="right"/></tr><tr valign="top"><td>5:</td><td><bold>if </bold><inline-formula><mml:math id="inf331"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>J</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="normal">∅</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> <bold>then</bold></td><td align="right"/></tr><tr valign="top"><td>6:</td><td>      <inline-formula><mml:math id="inf332"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo stretchy="false">←</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mi>q</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:mn>1</mml:mn><mml:mo fence="false" stretchy="false">}</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Indeces of components to get updated.</td></tr><tr valign="top"><td>7:</td><td>      <inline-formula><mml:math id="inf333"><mml:mrow><mml:mrow><mml:mi mathvariant="bold">𝐪</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>←</mml:mo><mml:mrow><mml:mrow><mml:mi mathvariant="bold">𝐪</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="right"/></tr><tr valign="top"><td>8:</td><td><bold>else</bold></td><td align="right">Do not update shapes if new components are added.</td></tr><tr valign="top"><td>9:</td><td>      <inline-formula><mml:math id="inf334"><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mi>o</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="normal">∅</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mi>J</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mi>o</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mi>o</mml:mi></mml:msub><mml:mo>∪</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:mo>⁢</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mo>:</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>⊤</mml:mo></mml:msup><mml:mo>⁢</mml:mo><mml:mi>A</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mo>:</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="right"/></tr><tr valign="top"><td>10:</td><td>      <bold>for</bold> <inline-formula><mml:math id="inf335"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mi>J</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> <bold>do</bold></td><td align="right"/></tr><tr valign="top"><td>11:</td><td>            <inline-formula><mml:math id="inf336"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mi>o</mml:mi></mml:msub><mml:mo stretchy="false">←</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mi>o</mml:mi></mml:msub><mml:mo>∪</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mo>:</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:msup><mml:mo stretchy="false">]</mml:mo><mml:mrow><mml:mi mathvariant="normal">⊤</mml:mi></mml:mrow></mml:msup><mml:mi>A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mo>:</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mspace width="thinmathspace"/><mml:mo>&gt;</mml:mo><mml:mspace width="thinmathspace"/><mml:mn>0</mml:mn><mml:mo fence="false" stretchy="false">}</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Find overlapping components.</td></tr><tr valign="top"><td>12:</td><td>      <bold>end for</bold></td><td align="right"/></tr><tr valign="top"><td>13:</td><td>      <inline-formula><mml:math id="inf337"><mml:mrow><mml:mrow><mml:mi mathvariant="bold">𝐪</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mi>o</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>←</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula></td><td align="right">Make sure these components get updated at the next step.</td></tr><tr valign="top"><td>14:</td><td>      <inline-formula><mml:math id="inf338"><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:mi mathvariant="normal">∅</mml:mi></mml:mrow></mml:math></inline-formula></td><td align="right"/></tr><tr valign="top"><td>15:</td><td><bold>end if</bold></td><td align="right"/></tr><tr valign="top"><td>16:</td><td colspan="2"><bold>return</bold> Indeces of components to get updated <inline-formula><mml:math id="inf339"><mml:msub><mml:mi>I</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:math></inline-formula>, update counter vector <inline-formula><mml:math id="inf340"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mi mathvariant="bold">q</mml:mi></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td></tr></tbody></table></table-wrap><table-wrap id="inlinetable7" position="anchor"><table frame="hsides" rules="groups"><thead><tr><th colspan="3">Algorithm 7: R<sc>egister</sc>P<sc>air</sc></th></tr></thead><tbody><tr valign="top"><td colspan="3"><bold>Require:</bold> Spatial footprint matrices <inline-formula><mml:math id="inf341"><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, field of view templates <inline-formula><mml:math id="inf342"><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, thresholds for binarization <inline-formula><mml:math id="inf343"><mml:msub><mml:mi>θ</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:math></inline-formula> and matching <inline-formula><mml:math id="inf344"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td></tr><tr valign="top"><td>1:</td><td><inline-formula><mml:math id="inf345"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="normal">C</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">U</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">M</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">N</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">F</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">D</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Compute motion field between the templates.</td></tr><tr valign="top"><td>2:</td><td><inline-formula><mml:math id="inf346"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">←</mml:mo><mml:mrow><mml:mi mathvariant="normal">A</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">Y</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">M</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">N</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">F</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">D</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Align A<sub>1</sub> to the template I<sub>2</sub></td></tr><tr valign="top"><td>3:</td><td><inline-formula><mml:math id="inf347"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>M</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>M</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="normal">B</mml:mi><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">Z</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mi>b</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Turn components into binary masks.</td></tr><tr valign="top"><td>4:</td><td><inline-formula><mml:math id="inf348"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>D</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="normal">C</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">O</mml:mi><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">U</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">D</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">M</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">X</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Compute distance matrix.</td></tr><tr valign="top"><td>5:</td><td><inline-formula><mml:math id="inf349"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="normal">H</mml:mi><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">U</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathvariant="normal">G</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">N</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Match using the Hungarian algorithm.</td></tr><tr valign="top"><td>6:</td><td colspan="2"><bold>return</bold> Matched components <inline-formula><mml:math id="inf350"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, non-matched components <inline-formula><mml:math id="inf351"><mml:mrow><mml:msub><mml:mi>L</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and aligned components from first session <italic>A</italic><sub>1</sub>.</td></tr></tbody></table></table-wrap><table-wrap id="inlinetable8" position="anchor"><table frame="hsides" rules="groups"><thead><tr><th colspan="3">Algorithm 8: R<sc>egister</sc>M<sc>ulti</sc></th></tr></thead><tbody><tr valign="top"><td colspan="3"><bold>Require:</bold> List of Spatial footprint matrices <inline-formula><mml:math id="inf352"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mi>N</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula>, field of view templates <inline-formula><mml:math id="inf353"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mi>N</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula>, thresholds for binarization <inline-formula><mml:math id="inf354"><mml:msub><mml:mi>θ</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:math></inline-formula> and matching <inline-formula><mml:math id="inf355"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td></tr><tr valign="top"><td>1:</td><td><bold>for</bold> <inline-formula><mml:math id="inf356"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> <bold>do</bold></td><td align="right"/></tr><tr valign="top"><td>2:</td><td> <inline-formula><mml:math id="inf357"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>K</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">Z</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Number of components in each session.</td></tr><tr valign="top"><td>3:</td><td><bold>end for</bold></td><td align="right"/></tr><tr valign="top"><td>4:</td><td><inline-formula><mml:math id="inf358"><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula></td><td align="right">Initialize <italic>A<sub>u</sub></italic> matrix</td></tr><tr valign="top"><td>5:</td><td><inline-formula><mml:math id="inf359"><mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mi mathvariant="normal">…</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="right">Initialize matchings list</td></tr><tr valign="top"><td>6:</td><td><inline-formula><mml:math id="inf360"><mml:mrow><mml:msub><mml:mi>K</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>⁢</mml:mo><mml:mi>o</mml:mi><mml:mo>⁢</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula></td><td align="right">Total # of distinct components so far.</td></tr><tr valign="top"><td>7:</td><td><bold>for</bold> <inline-formula><mml:math id="inf361"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> <bold>do</bold></td><td align="right"/></tr><tr valign="top"><td>8:</td><td> <inline-formula><mml:math id="inf362"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="normal">R</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">G</mml:mi><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mstyle></mml:mrow><mml:mi mathvariant="normal">P</mml:mi><mml:mrow><mml:mstyle mathsize="0.75em"><mml:mrow><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">I</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mi>b</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Register <italic>A<sub>u</sub></italic> to session <italic>i</italic>.</td></tr><tr valign="top"><td>9:</td><td> <inline-formula><mml:math id="inf363"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mo>:</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">←</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mo>:</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Keep the matched components from session <italic>i</italic>.</td></tr><tr valign="top"><td>10:</td><td> <inline-formula><mml:math id="inf364"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo stretchy="false">←</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mo>:</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Include the non-matched components from session <italic>i</italic>.</td></tr><tr valign="top"><td>11:</td><td> <inline-formula><mml:math id="inf365"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>m</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right"><inline-formula><mml:math id="inf366"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>m</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> if component <italic>j</italic> from session <italic>i</italic> is mapped to component <italic>k</italic> in Optionally keep updating <italic>A<sub>u</sub></italic>.</td></tr><tr valign="top"><td>12:</td><td> <inline-formula><mml:math id="inf367"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>m</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>o</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>o</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>o</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="right">Include newly added components.</td></tr><tr valign="top"><td>13:</td><td> <inline-formula><mml:math id="inf368"><mml:mrow><mml:msub><mml:mi>K</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>⁢</mml:mo><mml:mi>o</mml:mi><mml:mo>⁢</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:mrow><mml:msub><mml:mi>K</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>⁢</mml:mo><mml:mi>o</mml:mi><mml:mo>⁢</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="right">Update total number of distinct components.</td></tr><tr valign="top"><td>14:</td><td><bold>end for</bold></td><td align="right"/></tr><tr valign="top"><td>15:</td><td colspan="2"><bold>return</bold> Union of all distinct components <inline-formula><mml:math id="inf369"><mml:msub><mml:mi>A</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:math></inline-formula>, and list of matchings <inline-formula><mml:math id="inf370"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>m</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td></tr></tbody></table></table-wrap></sec></sec></body><back><ack id="ack"><title>Acknowledgements</title><p>We thank B Cohen, L Myers, N Roumelioti, and S Villani for providing us with manual annotations. We thank V Staneva and B Deverett for contributing to the early stages of C<sc>a</sc>I<sc>m</sc>A<sc>n</sc>, M Schachter for his insight and contributions, and L Paninski for numerous useful discussions. We thank N Carriero, I Fisk, and D Simon from the Flatiron Institute (Simons Foundation) for useful discussions and suggestions to optimize High Performance Computing code. We thank T Kawashima and M Ahrens for sharing the whole brain zebrafish dataset. Last but not least, we thank the active community of users for their great help in terms of code/method contributions, bug reporting, code testing and suggestions that have led to the growth of into a widely used open source package. A partial list of contributors (in the form of GitHub usernames) can be found in <ext-link ext-link-type="uri" xlink:href="https://github.com/flatironinstitute/CaImAn/graphs/contributors">https://github.com/flatironinstitute/CaImAn/graphs/contributors</ext-link> (Python) and <ext-link ext-link-type="uri" xlink:href="https://github.com/flatironinstitute/CaImAn-MATLAB/graphs/contributors">https://github.com/flatironinstitute/CaImAn-MATLAB/graphs/contributors</ext-link> (MATLAB). The authors acknowledge support from following funding sources: AG, EAP, JF, PG (Simons Foundation, internal funding). JG, SAK, DWT (NIH NRSA F32NS077840-01,5U01NS090541, 1U19NS104648 and Simons Foundation SCGB), PZ (NIH NIBIB R01EB022913, NSF NeuroNex DBI-1707398, Gatsby Foundation), JT (NIH R01-MH101198), FN (MURI, Simons Collaboration on the Global Brain and Pew Foundation).</p></ack><sec id="s5" sec-type="additional-information"><title>Additional information</title><fn-group content-type="competing-interest"><title>Competing interests</title><fn fn-type="COI-statement" id="conf1"><p>No competing interests declared</p></fn></fn-group><fn-group content-type="author-contribution"><title>Author contributions</title><fn fn-type="con" id="con1"><p>Conceptualization, Data curation, Software, Formal analysis, Supervision, Validation, Investigation, Visualization, Methodology, Writing—review and editing</p></fn><fn fn-type="con" id="con2"><p>Conceptualization, Software, Formal analysis, Validation, Investigation, Visualization, Methodology, Writing—review and editing</p></fn><fn fn-type="con" id="con3"><p>Software, Validation, Writing—review and editing</p></fn><fn fn-type="con" id="con4"><p>Software, Visualization</p></fn><fn fn-type="con" id="con5"><p>Software</p></fn><fn fn-type="con" id="con6"><p>Data curation, Formal analysis, Validation, Writing—review and editing</p></fn><fn fn-type="con" id="con7"><p>Data curation, Software</p></fn><fn fn-type="con" id="con8"><p>Software, Validation</p></fn><fn fn-type="con" id="con9"><p>Conceptualization, Data curation</p></fn><fn fn-type="con" id="con10"><p>Software, Validation, Methodology, Writing—review and editing</p></fn><fn fn-type="con" id="con11"><p>Resources, Funding acquisition</p></fn><fn fn-type="con" id="con12"><p>Resources, Data curation</p></fn><fn fn-type="con" id="con13"><p>Conceptualization, Resources, Data curation, Software, Formal analysis, Supervision, Project administration, Writing—review and editing</p></fn><fn fn-type="con" id="con14"><p>Conceptualization, Data curation, Software, Formal analysis, Supervision, Validation, Visualization, Methodology, Writing—original draft</p></fn></fn-group></sec><sec id="s6" sec-type="supplementary-material"><title>Additional files</title><supplementary-material id="transrepform"><object-id pub-id-type="doi">10.7554/eLife.38173.031</object-id><label>Transparent reporting form</label><media mime-subtype="pdf" mimetype="application" xlink:href="elife-38173-transrepform-v1.pdf"/></supplementary-material><sec id="s7" sec-type="data-availability"><title>Data availability</title><p>All input data used to generate most figures, along with the necessary scripts, is available via Zenodo (<ext-link ext-link-type="uri" xlink:href="https://zenodo.org/record/1659149#.XC_Wcs9Ki9s">https://zenodo.org/record/1659149#.XC_Wcs9Ki9s</ext-link>). The original (pre-non-rigid-motion correction) NF datasets listed in Table 2 are publicly available via <ext-link ext-link-type="uri" xlink:href="https://github.com/CodeNeuro/neurofinder">https://github.com/CodeNeuro/neurofinder</ext-link>. They were originally shared by the Hausser, Losonczy, Svoboda, and Harvey labs.</p><p>The following previously published datasets were used:</p><p><element-citation id="dataset4" publication-type="data" specific-use="references"><person-group person-group-type="author"><name><surname>Andrea</surname><given-names>Giovannucci</given-names></name><name><surname>Johannes</surname><given-names>Friedrich</given-names></name><name><surname>Pat</surname><given-names>Gunn</given-names></name><name><surname>Brandon</surname><given-names>L Brown</given-names></name><name><surname>Sue</surname><given-names>Ann Koay</given-names></name><name><surname>Jiannis</surname><given-names>Taxidis</given-names></name><name><surname>Farzaneh</surname><given-names>Najafi</given-names></name><name><surname>Jeffrey</surname><given-names>L Gauthier</given-names></name><name><surname>Pengcheng</surname><given-names>Zhou</given-names></name><name><surname>Baljit</surname><given-names>S Khakh</given-names></name><name><surname>David</surname><given-names>W Tank</given-names></name><name><surname>Dmitri</surname><given-names>B Chklovskii</given-names></name><name><surname>Eftychios</surname><given-names>A Pnevmatikakis</given-names></name></person-group><year iso-8601-date="2018">2018</year><data-title>Datasets Generated: Data from CaImAn, an open source tool for scalable Calcium Imaging data Analysis</data-title><source>Zenodo</source><pub-id assigning-authority="Zenodo" pub-id-type="doi">10.5281/zenodo.1659149</pub-id></element-citation></p></sec></sec><ref-list><title>References</title><ref id="bib1"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ahrens</surname> <given-names>MB</given-names></name><name><surname>Orger</surname> <given-names>MB</given-names></name><name><surname>Robson</surname> <given-names>DN</given-names></name><name><surname>Li</surname> <given-names>JM</given-names></name><name><surname>Keller</surname> <given-names>PJ</given-names></name></person-group><year iso-8601-date="2013">2013</year><article-title>Whole-brain functional imaging at cellular resolution using light-sheet microscopy</article-title><source>Nature Methods</source><volume>10</volume><fpage>413</fpage><lpage>420</lpage><pub-id pub-id-type="doi">10.1038/nmeth.2434</pub-id><pub-id pub-id-type="pmid">23524393</pub-id></element-citation></ref><ref id="bib2"><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Apthorpe</surname> <given-names>N</given-names></name><name><surname>Riordan</surname> <given-names>A</given-names></name><name><surname>Aguilar</surname> <given-names>R</given-names></name><name><surname>Homann</surname> <given-names>J</given-names></name><name><surname>Gu</surname> <given-names>Y</given-names></name><name><surname>Tank</surname> <given-names>D</given-names></name><name><surname>Seung</surname> <given-names>HS</given-names></name></person-group><year iso-8601-date="2016">2016</year><chapter-title>Automatic Neuron Detection in Calcium Imaging Data Using Convolutional Networks</chapter-title><source>Advances in Neural Information Processing Systems</source><publisher-name>MIT Press</publisher-name><fpage>3270</fpage><lpage>3278</lpage></element-citation></ref><ref id="bib3"><element-citation publication-type="preprint"><person-group person-group-type="author"><name><surname>Berens</surname> <given-names>P</given-names></name><name><surname>Freeman</surname> <given-names>J</given-names></name><name><surname>Deneux</surname> <given-names>T</given-names></name><name><surname>Chenkov</surname> <given-names>N</given-names></name><name><surname>McColgan</surname> <given-names>T</given-names></name><name><surname>Speiser</surname> <given-names>A</given-names></name><name><surname>Macke</surname> <given-names>JH</given-names></name><name><surname>Turaga</surname> <given-names>S</given-names></name><name><surname>Mineault</surname> <given-names>P</given-names></name><name><surname>Rupprecht</surname> <given-names>P</given-names></name><name><surname>Gerhard</surname> <given-names>S</given-names></name><name><surname>Friedrich</surname> <given-names>RW</given-names></name><name><surname>Friedrich</surname> <given-names>J</given-names></name><name><surname>Paninski</surname> <given-names>L</given-names></name><name><surname>Pachitariu</surname> <given-names>M</given-names></name><name><surname>Harris</surname> <given-names>KD</given-names></name><name><surname>Bolte</surname> <given-names>B</given-names></name><name><surname>Machado</surname> <given-names>TA</given-names></name><name><surname>Ringach</surname> <given-names>D</given-names></name><name><surname>Reimer</surname> <given-names>J</given-names></name></person-group><year iso-8601-date="2017">2017</year><article-title>Community-based benchmarking improves spike inference from two-photon calcium imaging data</article-title><source>bioRxiv</source><pub-id pub-id-type="doi">10.1101/177956</pub-id></element-citation></ref><ref id="bib4"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Botev</surname> <given-names>ZI</given-names></name><name><surname>Grotowski</surname> <given-names>JF</given-names></name><name><surname>Kroese</surname> <given-names>DP</given-names></name></person-group><year iso-8601-date="2010">2010</year><article-title>Kernel density estimation via diffusion</article-title><source>The Annals of Statistics</source><volume>38</volume><fpage>2916</fpage><lpage>2957</lpage><pub-id pub-id-type="doi">10.1214/10-AOS799</pub-id></element-citation></ref><ref id="bib5"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bouchard</surname> <given-names>MB</given-names></name><name><surname>Voleti</surname> <given-names>V</given-names></name><name><surname>Mendes</surname> <given-names>CS</given-names></name><name><surname>Lacefield</surname> <given-names>C</given-names></name><name><surname>Grueber</surname> <given-names>WB</given-names></name><name><surname>Mann</surname> <given-names>RS</given-names></name><name><surname>Bruno</surname> <given-names>RM</given-names></name><name><surname>Hillman</surname> <given-names>EM</given-names></name></person-group><year iso-8601-date="2015">2015</year><article-title>Swept confocally-aligned planar excitation (SCAPE) microscopy for high speed volumetric imaging of behaving organisms</article-title><source>Nature Photonics</source><volume>9</volume><fpage>113</fpage><lpage>119</lpage><pub-id pub-id-type="doi">10.1038/nphoton.2014.323</pub-id><pub-id pub-id-type="pmid">25663846</pub-id></element-citation></ref><ref id="bib6"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bradski</surname> <given-names>G</given-names></name></person-group><year iso-8601-date="2000">2000</year><article-title>The OpenCV library</article-title><source>Dr Dobb’s Journal: Software Tools for the Professional Programmer</source><volume>25</volume><fpage>120</fpage><lpage>123</lpage></element-citation></ref><ref id="bib7"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Cai</surname> <given-names>DJ</given-names></name><name><surname>Aharoni</surname> <given-names>D</given-names></name><name><surname>Shuman</surname> <given-names>T</given-names></name><name><surname>Shobe</surname> <given-names>J</given-names></name><name><surname>Biane</surname> <given-names>J</given-names></name><name><surname>Song</surname> <given-names>W</given-names></name><name><surname>Wei</surname> <given-names>B</given-names></name><name><surname>Veshkini</surname> <given-names>M</given-names></name><name><surname>La-Vu</surname> <given-names>M</given-names></name><name><surname>Lou</surname> <given-names>J</given-names></name><name><surname>Flores</surname> <given-names>SE</given-names></name><name><surname>Kim</surname> <given-names>I</given-names></name><name><surname>Sano</surname> <given-names>Y</given-names></name><name><surname>Zhou</surname> <given-names>M</given-names></name><name><surname>Baumgaertel</surname> <given-names>K</given-names></name><name><surname>Lavi</surname> <given-names>A</given-names></name><name><surname>Kamata</surname> <given-names>M</given-names></name><name><surname>Tuszynski</surname> <given-names>M</given-names></name><name><surname>Mayford</surname> <given-names>M</given-names></name><name><surname>Golshani</surname> <given-names>P</given-names></name><name><surname>Silva</surname> <given-names>AJ</given-names></name></person-group><year iso-8601-date="2016">2016</year><article-title>A shared neural ensemble links distinct contextual memories encoded close in time</article-title><source>Nature</source><volume>534</volume><fpage>115</fpage><lpage>118</lpage><pub-id pub-id-type="doi">10.1038/nature17955</pub-id><pub-id pub-id-type="pmid">27251287</pub-id></element-citation></ref><ref id="bib8"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Carrillo-Reid</surname> <given-names>L</given-names></name><name><surname>Yang</surname> <given-names>W</given-names></name><name><surname>Kang Miller</surname> <given-names>JE</given-names></name><name><surname>Peterka</surname> <given-names>DS</given-names></name><name><surname>Yuste</surname> <given-names>R</given-names></name></person-group><year iso-8601-date="2017">2017</year><article-title>Imaging and optically manipulating neuronal ensembles</article-title><source>Annual Review of Biophysics</source><volume>46</volume><fpage>271</fpage><lpage>293</lpage><pub-id pub-id-type="doi">10.1146/annurev-biophys-070816-033647</pub-id><pub-id pub-id-type="pmid">28301770</pub-id></element-citation></ref><ref id="bib9"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chen</surname> <given-names>TW</given-names></name><name><surname>Wardill</surname> <given-names>TJ</given-names></name><name><surname>Sun</surname> <given-names>Y</given-names></name><name><surname>Pulver</surname> <given-names>SR</given-names></name><name><surname>Renninger</surname> <given-names>SL</given-names></name><name><surname>Baohan</surname> <given-names>A</given-names></name><name><surname>Schreiter</surname> <given-names>ER</given-names></name><name><surname>Kerr</surname> <given-names>RA</given-names></name><name><surname>Orger</surname> <given-names>MB</given-names></name><name><surname>Jayaraman</surname> <given-names>V</given-names></name><name><surname>Looger</surname> <given-names>LL</given-names></name><name><surname>Svoboda</surname> <given-names>K</given-names></name><name><surname>Kim</surname> <given-names>DS</given-names></name></person-group><year iso-8601-date="2013">2013</year><article-title>Ultrasensitive fluorescent proteins for imaging neuronal activity</article-title><source>Nature</source><volume>499</volume><fpage>295</fpage><lpage>300</lpage><pub-id pub-id-type="doi">10.1038/nature12354</pub-id><pub-id pub-id-type="pmid">23868258</pub-id></element-citation></ref><ref id="bib10"><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Cichocki</surname> <given-names>A</given-names></name><name><surname>Zdunek</surname> <given-names>R</given-names></name><name><surname>Si</surname> <given-names>A</given-names></name></person-group><year iso-8601-date="2007">2007</year><chapter-title>Hierarchical ALS algorithms for nonnegative matrix and 3D tensor factorization</chapter-title><source>Lecture Notes in Computer Science</source><publisher-name>Springer</publisher-name><fpage>169</fpage><lpage>176</lpage></element-citation></ref><ref id="bib11"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Dean</surname> <given-names>J</given-names></name><name><surname>Ghemawat</surname> <given-names>S</given-names></name></person-group><year iso-8601-date="2008">2008</year><article-title>MapReduce</article-title><source>Communications of the ACM</source><volume>51</volume><fpage>107</fpage><lpage>113</lpage><pub-id pub-id-type="doi">10.1145/1327452.1327492</pub-id></element-citation></ref><ref id="bib12"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Deneux</surname> <given-names>T</given-names></name><name><surname>Kaszas</surname> <given-names>A</given-names></name><name><surname>Szalay</surname> <given-names>G</given-names></name><name><surname>Katona</surname> <given-names>G</given-names></name><name><surname>Lakner</surname> <given-names>T</given-names></name><name><surname>Grinvald</surname> <given-names>A</given-names></name><name><surname>Rózsa</surname> <given-names>B</given-names></name><name><surname>Vanzetta</surname> <given-names>I</given-names></name></person-group><year iso-8601-date="2016">2016</year><article-title>Accurate spike estimation from noisy calcium signals for ultrafast three-dimensional imaging of large neuronal populations in vivo</article-title><source>Nature Communications</source><volume>7</volume><elocation-id>12190</elocation-id><pub-id pub-id-type="doi">10.1038/ncomms12190</pub-id><pub-id pub-id-type="pmid">27432255</pub-id></element-citation></ref><ref id="bib13"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Flusberg</surname> <given-names>BA</given-names></name><name><surname>Nimmerjahn</surname> <given-names>A</given-names></name><name><surname>Cocker</surname> <given-names>ED</given-names></name><name><surname>Mukamel</surname> <given-names>EA</given-names></name><name><surname>Barretto</surname> <given-names>RP</given-names></name><name><surname>Ko</surname> <given-names>TH</given-names></name><name><surname>Burns</surname> <given-names>LD</given-names></name><name><surname>Jung</surname> <given-names>JC</given-names></name><name><surname>Schnitzer</surname> <given-names>MJ</given-names></name></person-group><year iso-8601-date="2008">2008</year><article-title>High-speed, miniaturized fluorescence microscopy in freely moving mice</article-title><source>Nature Methods</source><volume>5</volume><fpage>935</fpage><lpage>938</lpage><pub-id pub-id-type="doi">10.1038/nmeth.1256</pub-id><pub-id pub-id-type="pmid">18836457</pub-id></element-citation></ref><ref id="bib14"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Freeman</surname> <given-names>J</given-names></name><name><surname>Vladimirov</surname> <given-names>N</given-names></name><name><surname>Kawashima</surname> <given-names>T</given-names></name><name><surname>Mu</surname> <given-names>Y</given-names></name><name><surname>Sofroniew</surname> <given-names>NJ</given-names></name><name><surname>Bennett</surname> <given-names>DV</given-names></name><name><surname>Rosen</surname> <given-names>J</given-names></name><name><surname>Yang</surname> <given-names>CT</given-names></name><name><surname>Looger</surname> <given-names>LL</given-names></name><name><surname>Ahrens</surname> <given-names>MB</given-names></name></person-group><year iso-8601-date="2014">2014</year><article-title>Mapping brain activity at scale with cluster computing</article-title><source>Nature Methods</source><volume>11</volume><fpage>941</fpage><lpage>950</lpage><pub-id pub-id-type="doi">10.1038/nmeth.3041</pub-id><pub-id pub-id-type="pmid">25068736</pub-id></element-citation></ref><ref id="bib15"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Friedrich</surname> <given-names>J</given-names></name><name><surname>Yang</surname> <given-names>W</given-names></name><name><surname>Soudry</surname> <given-names>D</given-names></name><name><surname>Mu</surname> <given-names>Y</given-names></name><name><surname>Ahrens</surname> <given-names>MB</given-names></name><name><surname>Yuste</surname> <given-names>R</given-names></name><name><surname>Peterka</surname> <given-names>DS</given-names></name><name><surname>Paninski</surname> <given-names>L</given-names></name></person-group><year iso-8601-date="2017">2017a</year><article-title>Multi-scale approaches for high-speed imaging and analysis of large neural populations</article-title><source>PLOS Computational Biology</source><volume>13</volume><elocation-id>e1005685</elocation-id><pub-id pub-id-type="doi">10.1371/journal.pcbi.1005685</pub-id><pub-id pub-id-type="pmid">28771570</pub-id></element-citation></ref><ref id="bib16"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Friedrich</surname> <given-names>J</given-names></name><name><surname>Zhou</surname> <given-names>P</given-names></name><name><surname>Paninski</surname> <given-names>L</given-names></name></person-group><year iso-8601-date="2017">2017b</year><article-title>Fast online deconvolution of calcium imaging data</article-title><source>PLOS Computational Biology</source><volume>13</volume><elocation-id>e1005423</elocation-id><pub-id pub-id-type="doi">10.1371/journal.pcbi.1005423</pub-id><pub-id pub-id-type="pmid">28291787</pub-id></element-citation></ref><ref id="bib17"><element-citation publication-type="preprint"><person-group person-group-type="author"><name><surname>Giovannucci</surname> <given-names>A</given-names></name><name><surname>Friedrich</surname> <given-names>J</given-names></name><name><surname>Kaufman</surname> <given-names>J</given-names></name><name><surname>Churchland</surname> <given-names>A</given-names></name><name><surname>Chklovskii</surname> <given-names>D</given-names></name><name><surname>Paninski</surname> <given-names>L</given-names></name><name><surname>Pnevmatikakis</surname> <given-names>EA</given-names></name></person-group><year iso-8601-date="2017">2017</year><article-title>OnACID: online analysis of calcium imaging data in real time</article-title><source>Biorxiv</source><pub-id pub-id-type="doi">10.1101/193383</pub-id></element-citation></ref><ref id="bib18"><element-citation publication-type="software"><person-group person-group-type="author"><name><surname>Giovannucci</surname> <given-names>A</given-names></name><name><surname>Pnevmatikakis</surname> <given-names>EA</given-names></name><name><surname>Friedrich</surname> <given-names>J</given-names></name><name><surname>Gunn</surname> <given-names>P</given-names></name><name><surname>Kalfon</surname> <given-names>J</given-names></name><name><surname>Brown</surname> <given-names>B</given-names></name></person-group><year iso-8601-date="2018">2018</year><data-title>CaImAn</data-title><source>GitHub</source><version designator="c156373">c156373</version><ext-link ext-link-type="uri" xlink:href="https://github.com/flatironinstitute/CaImAn">https://github.com/flatironinstitute/CaImAn</ext-link></element-citation></ref><ref id="bib19"><element-citation publication-type="preprint"><person-group person-group-type="author"><name><surname>Grosenick</surname> <given-names>LM</given-names></name><name><surname>Broxton</surname> <given-names>M</given-names></name><name><surname>Kim</surname> <given-names>CK</given-names></name><name><surname>Liston</surname> <given-names>C</given-names></name><name><surname>Poole</surname> <given-names>B</given-names></name><name><surname>Yang</surname> <given-names>S</given-names></name><name><surname>Andalman</surname> <given-names>AS</given-names></name><name><surname>Scharff</surname> <given-names>E</given-names></name><name><surname>Cohen</surname> <given-names>N</given-names></name><name><surname>Yizhar</surname> <given-names>O</given-names></name><name><surname>Ramakrishnan</surname> <given-names>C</given-names></name><name><surname>Ganguli</surname> <given-names>S</given-names></name><name><surname>Suppes</surname> <given-names>P</given-names></name><name><surname>Levoy</surname> <given-names>M</given-names></name><name><surname>Deisseroth</surname> <given-names>K</given-names></name></person-group><year iso-8601-date="2017">2017</year><article-title>Identification of cellular-activity dynamics across large tissue volumes in the mammalian brain</article-title><source>bioRxiv</source><pub-id pub-id-type="doi">10.1101/132688</pub-id></element-citation></ref><ref id="bib20"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Jia</surname> <given-names>H</given-names></name><name><surname>Rochefort</surname> <given-names>NL</given-names></name><name><surname>Chen</surname> <given-names>X</given-names></name><name><surname>Konnerth</surname> <given-names>A</given-names></name></person-group><year iso-8601-date="2011">2011</year><article-title>In vivo two-photon imaging of sensory-evoked dendritic calcium signals in cortical neurons</article-title><source>Nature Protocols</source><volume>6</volume><fpage>28</fpage><lpage>35</lpage><pub-id pub-id-type="doi">10.1038/nprot.2010.169</pub-id><pub-id pub-id-type="pmid">21212780</pub-id></element-citation></ref><ref id="bib21"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kaifosh</surname> <given-names>P</given-names></name><name><surname>Zaremba</surname> <given-names>JD</given-names></name><name><surname>Danielson</surname> <given-names>NB</given-names></name><name><surname>Losonczy</surname> <given-names>A</given-names></name></person-group><year iso-8601-date="2014">2014</year><article-title>SIMA: python software for analysis of dynamic fluorescence imaging data</article-title><source>Frontiers in Neuroinformatics</source><volume>8</volume><elocation-id>80</elocation-id><pub-id pub-id-type="doi">10.3389/fninf.2014.00080</pub-id><pub-id pub-id-type="pmid">25295002</pub-id></element-citation></ref><ref id="bib22"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kawashima</surname> <given-names>T</given-names></name><name><surname>Zwart</surname> <given-names>MF</given-names></name><name><surname>Yang</surname> <given-names>CT</given-names></name><name><surname>Mensh</surname> <given-names>BD</given-names></name><name><surname>Ahrens</surname> <given-names>MB</given-names></name></person-group><year iso-8601-date="2016">2016</year><article-title>The serotonergic system tracks the outcomes of actions to mediate Short-Term motor learning</article-title><source>Cell</source><volume>167</volume><fpage>933</fpage><lpage>946</lpage><pub-id pub-id-type="doi">10.1016/j.cell.2016.09.055</pub-id><pub-id pub-id-type="pmid">27881303</pub-id></element-citation></ref><ref id="bib23"><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Klibisz</surname> <given-names>A</given-names></name><name><surname>Rose</surname> <given-names>D</given-names></name><name><surname>Eicholtz</surname> <given-names>M</given-names></name><name><surname>Blundon</surname> <given-names>J</given-names></name><name><surname>Zakharenko</surname> <given-names>S</given-names></name></person-group><year iso-8601-date="2017">2017</year><chapter-title>Fast, Simple Calcium Imaging Segmentation with Fully Convolutional Networks</chapter-title><source>Lecture Notes in Computer Science</source><publisher-name>Springer</publisher-name><fpage>285</fpage><lpage>293</lpage></element-citation></ref><ref id="bib24"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mairal</surname> <given-names>J</given-names></name><name><surname>Bach</surname> <given-names>F</given-names></name><name><surname>Ponce</surname> <given-names>J</given-names></name><name><surname>Sapiro</surname> <given-names>G</given-names></name></person-group><year iso-8601-date="2010">2010</year><article-title>Online learning for matrix factorization and sparse coding</article-title><source>Journal of Machine Learning Research</source><volume>11</volume><fpage>19</fpage><lpage>60</lpage></element-citation></ref><ref id="bib25"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mukamel</surname> <given-names>EA</given-names></name><name><surname>Nimmerjahn</surname> <given-names>A</given-names></name><name><surname>Schnitzer</surname> <given-names>MJ</given-names></name></person-group><year iso-8601-date="2009">2009</year><article-title>Automated analysis of cellular signals from large-scale calcium imaging data</article-title><source>Neuron</source><volume>63</volume><fpage>747</fpage><lpage>760</lpage><pub-id pub-id-type="doi">10.1016/j.neuron.2009.08.009</pub-id><pub-id pub-id-type="pmid">19778505</pub-id></element-citation></ref><ref id="bib26"><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Pachitariu</surname> <given-names>M</given-names></name><name><surname>Packer</surname> <given-names>AM</given-names></name><name><surname>Pettit</surname> <given-names>N</given-names></name><name><surname>Dalgleish</surname> <given-names>H</given-names></name><name><surname>Hausser</surname> <given-names>M</given-names></name><name><surname>Sahani</surname> <given-names>M</given-names></name></person-group><year iso-8601-date="2013">2013</year><chapter-title>Extracting regions of interest from biological images with convolutional sparse block coding</chapter-title><source>Advances in Neural Information Processing Systems</source><publisher-name>MIT Press</publisher-name><fpage>1745</fpage><lpage>1753</lpage></element-citation></ref><ref id="bib27"><element-citation publication-type="preprint"><person-group person-group-type="author"><name><surname>Pachitariu</surname> <given-names>M</given-names></name><name><surname>Stringer</surname> <given-names>C</given-names></name><name><surname>Dipoppa</surname> <given-names>M</given-names></name><name><surname>Schröder S</surname> <given-names>RLF</given-names></name><name><surname>Dalgleish</surname> <given-names>H</given-names></name><name><surname>Carandini</surname> <given-names>M</given-names></name><name><surname>Harris</surname> <given-names>KD</given-names></name></person-group><year iso-8601-date="2017">2017</year><article-title>Suite2p: beyond 10,000 neurons with standard two-photon microscopy</article-title><source>BioRxiv</source><pub-id pub-id-type="doi">10.1101/061507</pub-id></element-citation></ref><ref id="bib28"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Packer</surname> <given-names>AM</given-names></name><name><surname>Russell</surname> <given-names>LE</given-names></name><name><surname>Dalgleish</surname> <given-names>HW</given-names></name><name><surname>Häusser</surname> <given-names>M</given-names></name></person-group><year iso-8601-date="2015">2015</year><article-title>Simultaneous all-optical manipulation and recording of neural circuit activity with cellular resolution in vivo</article-title><source>Nature Methods</source><volume>12</volume><fpage>140</fpage><lpage>146</lpage><pub-id pub-id-type="doi">10.1038/nmeth.3217</pub-id><pub-id pub-id-type="pmid">25532138</pub-id></element-citation></ref><ref id="bib29"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Pedregosa</surname> <given-names>F</given-names></name><name><surname>Varoquaux</surname> <given-names>G</given-names></name><name><surname>Gramfort</surname> <given-names>A</given-names></name><name><surname>Michel</surname> <given-names>V</given-names></name><name><surname>Thirion</surname> <given-names>B</given-names></name><name><surname>Grisel</surname> <given-names>O</given-names></name><name><surname>Blondel</surname> <given-names>M</given-names></name><name><surname>Prettenhofer</surname> <given-names>P</given-names></name><name><surname>Weiss</surname> <given-names>R</given-names></name><name><surname>Dubourg</surname> <given-names>V</given-names></name><name><surname>Vanderplas</surname> <given-names>J</given-names></name><name><surname>Passos</surname> <given-names>A</given-names></name><name><surname>Cournapeau</surname> <given-names>D</given-names></name><name><surname>Brucher</surname> <given-names>M</given-names></name><name><surname>Perrot</surname> <given-names>M</given-names></name></person-group><year iso-8601-date="2011">2011</year><article-title>Scikit-learn: machine learning in python</article-title><source>Journal of Machine Learning Research</source><volume>12</volume><fpage>2825</fpage><lpage>2830</lpage></element-citation></ref><ref id="bib30"><element-citation publication-type="preprint"><person-group person-group-type="author"><name><surname>Petersen</surname> <given-names>A</given-names></name><name><surname>Simon</surname> <given-names>N</given-names></name><name><surname>Witten</surname> <given-names>D</given-names></name></person-group><year iso-8601-date="2017">2017</year><article-title>SCALPEL: extracting neurons from calcium imaging data</article-title><source>arXiv</source><ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/1703.06946">https://arxiv.org/abs/1703.06946</ext-link></element-citation></ref><ref id="bib31"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Piatkevich</surname> <given-names>KD</given-names></name><name><surname>Jung</surname> <given-names>EE</given-names></name><name><surname>Straub</surname> <given-names>C</given-names></name><name><surname>Linghu</surname> <given-names>C</given-names></name><name><surname>Park</surname> <given-names>D</given-names></name><name><surname>Suk</surname> <given-names>HJ</given-names></name><name><surname>Hochbaum</surname> <given-names>DR</given-names></name><name><surname>Goodwin</surname> <given-names>D</given-names></name><name><surname>Pnevmatikakis</surname> <given-names>E</given-names></name><name><surname>Pak</surname> <given-names>N</given-names></name><name><surname>Kawashima</surname> <given-names>T</given-names></name><name><surname>Yang</surname> <given-names>CT</given-names></name><name><surname>Rhoades</surname> <given-names>JL</given-names></name><name><surname>Shemesh</surname> <given-names>O</given-names></name><name><surname>Asano</surname> <given-names>S</given-names></name><name><surname>Yoon</surname> <given-names>YG</given-names></name><name><surname>Freifeld</surname> <given-names>L</given-names></name><name><surname>Saulnier</surname> <given-names>JL</given-names></name><name><surname>Riegler</surname> <given-names>C</given-names></name><name><surname>Engert</surname> <given-names>F</given-names></name><name><surname>Hughes</surname> <given-names>T</given-names></name><name><surname>Drobizhev</surname> <given-names>M</given-names></name><name><surname>Szabo</surname> <given-names>B</given-names></name><name><surname>Ahrens</surname> <given-names>MB</given-names></name><name><surname>Flavell</surname> <given-names>SW</given-names></name><name><surname>Sabatini</surname> <given-names>BL</given-names></name><name><surname>Boyden</surname> <given-names>ES</given-names></name></person-group><year iso-8601-date="2018">2018</year><article-title>A robotic multidimensional directed evolution approach applied to fluorescent voltage reporters</article-title><source>Nature Chemical Biology</source><volume>14</volume><fpage>352</fpage><lpage>360</lpage><pub-id pub-id-type="doi">10.1038/s41589-018-0004-9</pub-id><pub-id pub-id-type="pmid">29483642</pub-id></element-citation></ref><ref id="bib32"><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Pnevmatikakis</surname> <given-names>EA</given-names></name><name><surname>Merel</surname> <given-names>J</given-names></name><name><surname>Pakman</surname> <given-names>A</given-names></name><name><surname>Paninski</surname> <given-names>L</given-names></name></person-group><year iso-8601-date="2013">2013</year><article-title>Bayesian spike inference from calcium imaging data</article-title><conf-name>Signals, Systems and Computers, 2013 Asilomar Conference on IEEE</conf-name><fpage>349</fpage><lpage>353</lpage></element-citation></ref><ref id="bib33"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Pnevmatikakis</surname> <given-names>EA</given-names></name><name><surname>Soudry</surname> <given-names>D</given-names></name><name><surname>Gao</surname> <given-names>Y</given-names></name><name><surname>Machado</surname> <given-names>TA</given-names></name><name><surname>Merel</surname> <given-names>J</given-names></name><name><surname>Pfau</surname> <given-names>D</given-names></name><name><surname>Reardon</surname> <given-names>T</given-names></name><name><surname>Mu</surname> <given-names>Y</given-names></name><name><surname>Lacefield</surname> <given-names>C</given-names></name><name><surname>Yang</surname> <given-names>W</given-names></name><name><surname>Ahrens</surname> <given-names>M</given-names></name><name><surname>Bruno</surname> <given-names>R</given-names></name><name><surname>Jessell</surname> <given-names>TM</given-names></name><name><surname>Peterka</surname> <given-names>DS</given-names></name><name><surname>Yuste</surname> <given-names>R</given-names></name><name><surname>Paninski</surname> <given-names>L</given-names></name></person-group><year iso-8601-date="2016">2016</year><article-title>Simultaneous denoising, Deconvolution, and demixing of calcium imaging data</article-title><source>Neuron</source><volume>89</volume><fpage>285</fpage><lpage>299</lpage><pub-id pub-id-type="doi">10.1016/j.neuron.2015.11.037</pub-id><pub-id pub-id-type="pmid">26774160</pub-id></element-citation></ref><ref id="bib34"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Pnevmatikakis</surname> <given-names>EA</given-names></name><name><surname>Giovannucci</surname> <given-names>A</given-names></name></person-group><year iso-8601-date="2017">2017</year><article-title>NoRMCorre: an online algorithm for piecewise rigid motion correction of calcium imaging data</article-title><source>Journal of Neuroscience Methods</source><volume>291</volume><fpage>83</fpage><lpage>94</lpage><pub-id pub-id-type="doi">10.1016/j.jneumeth.2017.07.031</pub-id><pub-id pub-id-type="pmid">28782629</pub-id></element-citation></ref><ref id="bib35"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Pnevmatikakis</surname> <given-names>EA</given-names></name></person-group><year iso-8601-date="2018">2018</year><article-title>Analysis pipelines for calcium imaging data.</article-title><source>Current Opinion in Neurobiology</source><volume>55</volume><fpage>15</fpage><lpage>21</lpage><pub-id pub-id-type="doi">10.1016/j.conb.2018.11.004</pub-id><pub-id pub-id-type="pmid">30529147</pub-id></element-citation></ref><ref id="bib36"><element-citation publication-type="software"><person-group person-group-type="author"><name><surname>Pnevmatikakis</surname> <given-names>EA</given-names></name><name><surname>Giovannucci</surname> <given-names>A</given-names></name><name><surname>Kalfon</surname> <given-names>J</given-names></name><name><surname>Najafi</surname> <given-names>F</given-names></name><name><surname>Taxidis</surname> <given-names>J</given-names></name></person-group><year iso-8601-date="2018">2018</year><data-title>CaImAn-MATLAB</data-title><source>GitHub</source><version designator="52af659">52af659</version><ext-link ext-link-type="uri" xlink:href="https://github.com/elifesciences-publications/CaImAn-MATLAB">https://github.com/elifesciences-publications/CaImAn-MATLAB</ext-link></element-citation></ref><ref id="bib37"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Prevedel</surname> <given-names>R</given-names></name><name><surname>Yoon</surname> <given-names>YG</given-names></name><name><surname>Hoffmann</surname> <given-names>M</given-names></name><name><surname>Pak</surname> <given-names>N</given-names></name><name><surname>Wetzstein</surname> <given-names>G</given-names></name><name><surname>Kato</surname> <given-names>S</given-names></name><name><surname>Schrödel</surname> <given-names>T</given-names></name><name><surname>Raskar</surname> <given-names>R</given-names></name><name><surname>Zimmer</surname> <given-names>M</given-names></name><name><surname>Boyden</surname> <given-names>ES</given-names></name><name><surname>Vaziri</surname> <given-names>A</given-names></name></person-group><year iso-8601-date="2014">2014</year><article-title>Simultaneous whole-animal 3D imaging of neuronal activity using light-field microscopy</article-title><source>Nature Methods</source><volume>11</volume><fpage>727</fpage><lpage>730</lpage><pub-id pub-id-type="doi">10.1038/nmeth.2964</pub-id><pub-id pub-id-type="pmid">24836920</pub-id></element-citation></ref><ref id="bib38"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Reynolds</surname> <given-names>S</given-names></name><name><surname>Abrahamsson</surname> <given-names>T</given-names></name><name><surname>Schuck</surname> <given-names>R</given-names></name><name><surname>Sjöström</surname> <given-names>PJ</given-names></name><name><surname>Schultz</surname> <given-names>SR</given-names></name><name><surname>Dragotti</surname> <given-names>PL</given-names></name></person-group><year iso-8601-date="2017">2017</year><article-title>ABLE: an Activity-Based level set segmentation algorithm for Two-Photon calcium imaging data</article-title><source>Eneuro</source><volume>4</volume><elocation-id>ENEURO.0012-17.2017</elocation-id><pub-id pub-id-type="doi">10.1523/ENEURO.0012-17.2017</pub-id><pub-id pub-id-type="pmid">29085906</pub-id></element-citation></ref><ref id="bib39"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sheintuch</surname> <given-names>L</given-names></name><name><surname>Rubin</surname> <given-names>A</given-names></name><name><surname>Brande-Eilat</surname> <given-names>N</given-names></name><name><surname>Geva</surname> <given-names>N</given-names></name><name><surname>Sadeh</surname> <given-names>N</given-names></name><name><surname>Pinchasof</surname> <given-names>O</given-names></name><name><surname>Ziv</surname> <given-names>Y</given-names></name></person-group><year iso-8601-date="2017">2017</year><article-title>Tracking the same neurons across multiple days in Ca<sup>2+</sup>Imaging Data</article-title><source>Cell Reports</source><volume>21</volume><fpage>1102</fpage><lpage>1115</lpage><pub-id pub-id-type="doi">10.1016/j.celrep.2017.10.013</pub-id><pub-id pub-id-type="pmid">29069591</pub-id></element-citation></ref><ref id="bib40"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Smith</surname> <given-names>SL</given-names></name><name><surname>Häusser</surname> <given-names>M</given-names></name></person-group><year iso-8601-date="2010">2010</year><article-title>Parallel processing of visual space by neighboring neurons in mouse visual cortex</article-title><source>Nature Neuroscience</source><volume>13</volume><fpage>1144</fpage><lpage>1149</lpage><pub-id pub-id-type="doi">10.1038/nn.2620</pub-id><pub-id pub-id-type="pmid">20711183</pub-id></element-citation></ref><ref id="bib41"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sofroniew</surname> <given-names>NJ</given-names></name><name><surname>Flickinger</surname> <given-names>D</given-names></name><name><surname>King</surname> <given-names>J</given-names></name><name><surname>Svoboda</surname> <given-names>K</given-names></name></person-group><year iso-8601-date="2016">2016</year><article-title>A large field of view two-photon mesoscope with subcellular resolution for in vivo imaging</article-title><source>eLife</source><volume>5</volume><elocation-id>e14472</elocation-id><pub-id pub-id-type="doi">10.7554/eLife.14472</pub-id><pub-id pub-id-type="pmid">27300105</pub-id></element-citation></ref><ref id="bib42"><element-citation publication-type="preprint"><person-group person-group-type="author"><name><surname>Spaen</surname> <given-names>Q</given-names></name><name><surname>Hochbaum</surname> <given-names>DS</given-names></name><name><surname>Asín-Achá</surname> <given-names>R</given-names></name></person-group><year iso-8601-date="2017">2017</year><article-title>HNCcorr: a novel combinatorial approach for cell identification in calcium-imaging movies</article-title><source>arXiv</source><ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/1703.01999">https://arxiv.org/abs/1703.01999</ext-link></element-citation></ref><ref id="bib43"><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Speiser</surname> <given-names>A</given-names></name><name><surname>Yan</surname> <given-names>J</given-names></name><name><surname>Archer</surname> <given-names>EW</given-names></name><name><surname>Buesing</surname> <given-names>L</given-names></name><name><surname>Turaga</surname> <given-names>SC</given-names></name><name><surname>Macke</surname> <given-names>JH</given-names></name></person-group><year iso-8601-date="2017">2017</year><chapter-title>Fast amortized inference of neural activity from calcium imaging data with variational autoencoders</chapter-title><source>Advances in Neural Information Processing Systems</source><publisher-name>MIT Press</publisher-name><fpage>4027</fpage><lpage>4037</lpage></element-citation></ref><ref id="bib44"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Theis</surname> <given-names>L</given-names></name><name><surname>Berens</surname> <given-names>P</given-names></name><name><surname>Froudarakis</surname> <given-names>E</given-names></name><name><surname>Reimer</surname> <given-names>J</given-names></name><name><surname>Román Rosón</surname> <given-names>M</given-names></name><name><surname>Baden</surname> <given-names>T</given-names></name><name><surname>Euler</surname> <given-names>T</given-names></name><name><surname>Tolias</surname> <given-names>AS</given-names></name><name><surname>Bethge</surname> <given-names>M</given-names></name></person-group><year iso-8601-date="2016">2016</year><article-title>Benchmarking spike rate inference in population calcium imaging</article-title><source>Neuron</source><volume>90</volume><fpage>471</fpage><lpage>482</lpage><pub-id pub-id-type="doi">10.1016/j.neuron.2016.04.014</pub-id><pub-id pub-id-type="pmid">27151639</pub-id></element-citation></ref><ref id="bib45"><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Toledo</surname> <given-names>S</given-names></name></person-group><year iso-8601-date="1999">1999</year><chapter-title>A survey of out-of-core algorithms in numerical linear algebra</chapter-title><source>DIMACS Series in Discrete Mathematics and Theoretical Computer Science</source><publisher-name>American Mathematical Society</publisher-name><fpage>161</fpage><lpage>179</lpage></element-citation></ref><ref id="bib46"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Valmianski</surname> <given-names>I</given-names></name><name><surname>Shih</surname> <given-names>AY</given-names></name><name><surname>Driscoll</surname> <given-names>JD</given-names></name><name><surname>Matthews</surname> <given-names>DW</given-names></name><name><surname>Freund</surname> <given-names>Y</given-names></name><name><surname>Kleinfeld</surname> <given-names>D</given-names></name></person-group><year iso-8601-date="2010">2010</year><article-title>Automatic identification of fluorescently labeled brain cells for rapid functional imaging</article-title><source>Journal of Neurophysiology</source><volume>104</volume><fpage>1803</fpage><lpage>1811</lpage><pub-id pub-id-type="doi">10.1152/jn.00484.2010</pub-id><pub-id pub-id-type="pmid">20610792</pub-id></element-citation></ref><ref id="bib47"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>van der Walt</surname> <given-names>S</given-names></name><name><surname>Schönberger</surname> <given-names>JL</given-names></name><name><surname>Nunez-Iglesias</surname> <given-names>J</given-names></name><name><surname>Boulogne</surname> <given-names>F</given-names></name><name><surname>Warner</surname> <given-names>JD</given-names></name><name><surname>Yager</surname> <given-names>N</given-names></name><name><surname>Gouillart</surname> <given-names>E</given-names></name><name><surname>Yu</surname> <given-names>T</given-names></name><collab>scikit-image contributors</collab></person-group><year iso-8601-date="2014">2014</year><article-title>scikit-image: image processing in python</article-title><source>PeerJ</source><volume>2</volume><elocation-id>e453</elocation-id><pub-id pub-id-type="doi">10.7717/peerj.453</pub-id><pub-id pub-id-type="pmid">25024921</pub-id></element-citation></ref><ref id="bib48"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Vogelstein</surname> <given-names>JT</given-names></name><name><surname>Packer</surname> <given-names>AM</given-names></name><name><surname>Machado</surname> <given-names>TA</given-names></name><name><surname>Sippy</surname> <given-names>T</given-names></name><name><surname>Babadi</surname> <given-names>B</given-names></name><name><surname>Yuste</surname> <given-names>R</given-names></name><name><surname>Paninski</surname> <given-names>L</given-names></name></person-group><year iso-8601-date="2010">2010</year><article-title>Fast nonnegative deconvolution for spike train inference from population calcium imaging</article-title><source>Journal of Neurophysiology</source><volume>104</volume><fpage>3691</fpage><lpage>3704</lpage><pub-id pub-id-type="doi">10.1152/jn.01073.2009</pub-id><pub-id pub-id-type="pmid">20554834</pub-id></element-citation></ref><ref id="bib49"><element-citation publication-type="software"><person-group person-group-type="author"><name><surname>Walker</surname> <given-names>T</given-names></name></person-group><year iso-8601-date="2014">2014</year><source>Cell Magic Wand Tool</source></element-citation></ref><ref id="bib50"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Xie</surname> <given-names>Y</given-names></name><name><surname>Chan</surname> <given-names>AW</given-names></name><name><surname>McGirr</surname> <given-names>A</given-names></name><name><surname>Xue</surname> <given-names>S</given-names></name><name><surname>Xiao</surname> <given-names>D</given-names></name><name><surname>Zeng</surname> <given-names>H</given-names></name><name><surname>Murphy</surname> <given-names>TH</given-names></name></person-group><year iso-8601-date="2016">2016</year><article-title>Resolution of High-Frequency mesoscale intracortical maps using the genetically encoded glutamate sensor iGluSnFR</article-title><source>Journal of Neuroscience</source><volume>36</volume><fpage>1261</fpage><lpage>1272</lpage><pub-id pub-id-type="doi">10.1523/JNEUROSCI.2744-15.2016</pub-id><pub-id pub-id-type="pmid">26818514</pub-id></element-citation></ref><ref id="bib51"><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Yoo</surname> <given-names>AB</given-names></name><name><surname>Jette</surname> <given-names>MA</given-names></name><name><surname>Grondona</surname> <given-names>M</given-names></name></person-group><year iso-8601-date="2003">2003</year><chapter-title>Slurm: Simple linux utility for resource management</chapter-title><source>Lecture Notes in Computer Science</source><publisher-name>Springer</publisher-name><fpage>44</fpage><lpage>60</lpage></element-citation></ref><ref id="bib52"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Zhou</surname> <given-names>P</given-names></name><name><surname>Resendez</surname> <given-names>SL</given-names></name><name><surname>Rodriguez-Romaguera</surname> <given-names>J</given-names></name><name><surname>Jimenez</surname> <given-names>JC</given-names></name><name><surname>Neufeld</surname> <given-names>SQ</given-names></name><name><surname>Giovannucci</surname> <given-names>A</given-names></name><name><surname>Friedrich</surname> <given-names>J</given-names></name><name><surname>Pnevmatikakis</surname> <given-names>EA</given-names></name><name><surname>Stuber</surname> <given-names>GD</given-names></name><name><surname>Hen</surname> <given-names>R</given-names></name><name><surname>Kheirbek</surname> <given-names>MA</given-names></name><name><surname>Sabatini</surname> <given-names>BL</given-names></name><name><surname>Kass</surname> <given-names>RE</given-names></name><name><surname>Paninski</surname> <given-names>L</given-names></name></person-group><year iso-8601-date="2018">2018</year><article-title>Efficient and accurate extraction of in vivo calcium signals from microendoscopic video data</article-title><source>eLife</source><volume>7</volume><elocation-id>e28728</elocation-id><pub-id pub-id-type="doi">10.7554/eLife.28728</pub-id><pub-id pub-id-type="pmid">29469809</pub-id></element-citation></ref></ref-list></back><sub-article article-type="decision-letter" id="SA1"><front-stub><article-id pub-id-type="doi">10.7554/eLife.38173.027</article-id><title-group><article-title>Decision letter</article-title></title-group><contrib-group><contrib contrib-type="editor"><name><surname>Kleinfeld</surname><given-names>David</given-names></name><role>Reviewing Editor</role><aff><institution>University of California, San Diego</institution><country>United States</country></aff></contrib></contrib-group></front-stub><body><boxed-text><p>In the interests of transparency, eLife includes the editorial decision letter and accompanying author responses. A lightly edited version of the letter sent to the authors after peer review is shown, indicating the most substantive concerns; minor comments are not usually included.</p></boxed-text><p>Thank you for submitting your article &quot;CaImAn: An open source tool for scalable Calcium Imaging data Analysis&quot; for consideration by <italic>eLife</italic>.</p><p>Your manuscript has been thoroughly reviewed by three outstanding reviewers and your software extensively tested by one of the groups. Your technical contribution, while admittedly introducing no novel approaches per se, is seen as a timely and carefully constructed software package that will help a large community of neuroscientists. However, before we can pass final judgment, we ask you to address all of the comments of the reviewers; this extensive request is based on the pointed nature of the comments and the importance of having your software accepted by the largest possible fraction of the imaging community. Please pay particular attention to queries on implementation.</p><p>A few key points to attend to include:</p><p>It is essential to judge the results with CaImAn against existing pipelines, e.g. the very popular Suite2P (Pachitariu et al.,) There is no expectation that CaImAn will shine in every dimension of use. Yet the authors simply must supply comparative benchmarks.</p><p>The trial data sets need to be completely described and, of course, made publicly and fully available if and when the manuscript is accepted.</p><p>It should be stated up front that there is no &quot;ground truth&quot; in the sense of simultaneous electrical and calcium measurements, only a comparison with a consensus view (note &quot;tyranny of the majority&quot; in one interpretation). Reviewer three makes a clear suggestion for cross-validation that should be followed.</p><p>The authors note that fine-tuning of parameters to individual datasets 'can significantly increase performance'. This must be detailed in light of the experience gained with nine different datasets.</p><p>Please augment the analysis of Figure 4 to show how precision and recall separately change with signal-to-noise ratio.</p><p><italic>Reviewer #1:</italic></p><p>Giovannucci et al., present a new open-source software package for analyzing calcium imaging data collected by two-photon and 1-photon microscopes. While the key algorithms used in the pipeline have been developed over many years and largely overlap with previously published work, new features, e.g. memory mapping, CNN-based classifiers, cross-day registration, have been added to improve the performance and further extend the functionalities of the software. The authors tested the package using various in vivo imaging datasets and compared the results with 'consensus ground truth'. The software is written in Python and is open-source, well-organized, and requires minimal user intervention.</p><p>The main advance of the manuscript is to combine a plethora of powerful algorithms that have been developed and improved over almost a decade into a single software package that allows batch processing as well as real-time processing of calcium imaging data. Most of the algorithms have been optimized for speed and performance to allow their use in real-time experiments such as closed-loop and all-optical experiments. Having a software package for calcium imaging data analysis that is freely available, well-documented and makes use of the most recent algorithms for the multiple steps involved in calcium imaging processing is extremely valuable for the field, as it will improve the quality and the efficiency of calcium data analysis throughout the neuroscience community, and also open up many new experimental avenues. I therefore strongly support publication.</p><p>1) My main concern is the lack of rigorous comparison of the performance of the package with existing solutions. The manuscript only contains internal comparisons but does not show comparisons to existing pipelines (e.g. Suite2P by Pachitariu et al.,) or earlier versions described in other manuscripts (e.g. CNMF in Pnevmatikakis et al., 2016), or state-of-the-art databases such as Neurofinder. This greatly increases the difficulty of judging the overall performance of the software package in its current form. Although the effort the authors went through to generate an improved ground truth data set is laudable, this does not allow one to judge the performance of the package with respect to existing packages/algorithms. For example, a test of how the package performs on the Neurofinder data and how existing packages (like e.g. Suite2P) perform on their newly generated ground truth data would help one to assess the performance of the ROI detection, which is one of the core features of the pipeline. While some of the comparisons have been performed in the respective publications, an overview of the performance of the pipeline with respect to its modules in their current form would be extremely informative.</p><p>2) Following on from the previous point, in the Discussion, the authors claim that 'apart from computational gains both approaches [MapReduce batch and O<sc>n</sc>ACID online] also result in improved performance'. Is this with respect to CNMF-based approaches or other existing methods, for example, Suite2pl? If the latter, then the caiman software was never directly compared to any other approaches commonly used (discussed in the Related work section) to validate if it outperforms them in terms of speed or accuracy (only shown similar number of cells detected to Zhou et al., (2018)). Some of the datasets used for ground truth testing could be easily analyzed using different algorithms to provide the comparison and demonstrate the advantages of Caiman. Pachitariu et al., (2018) showed Suite2p detects more cells (in particular, cells with low baseline firing rate) than CNMF-based method does. It would be helpful to know in which way Caiman outperforms Suite2P.</p><p>3) The authors claim that CaImAn Online outperforms Batch in terms of neuron detection for longer recordings, while CaImAn Batch is better suited for shorter recordings (Table 1 and also in the Discussion section). What is this claim based on, or what is the performance measure considered? Assuming longer recordings as &gt; 3000 frames and by inspecting Table 2, there is no clear distinction in terms of F1 scores or precision/recall scores (Table 1) based on the file length. Additionally, it is currently hard to inspect this claim as the information to be compared is stored in two separate tables.</p><p>4) The manuscript states that fine-tuning of parameters to individual datasets 'can significantly increase performance' (subsection “CAIMAN Batch and CAIMAN online detect neurons with near-human accuracy”) but no evidence is provided for this rather strong statement. It would be interesting to see the results of one of the videos analyzed in this section when the parameters were fine-tuned to show if such adjustment could lead to more reliable results.</p><p>5) In Figure 4A, why are the consensus ground truth components different in the Caiman batch panels and the caiman online panels? Were they constructed using the same SEEDINITIALIZATION procedure?</p><p>a) In the same figure, there are clearly some components that do not look like cells, in both Caiman batch/online detected components, and even in the consensus ROIs. The authors should add two panels to this figure, one showing the raw FOV image (preferably just the average image of the video, without further processing) with the manual selected ROI contours marked on it – which should look similar to the last panel in Figure 3A; and another showing the 'consensus ground truth' components given by the SEEDINITIALIZATION on top of the average image.</p><p>b) A worry is that the initialization procedure might add error to the ground truth and bias it towards the same direction as caiman does, and therefore masking error from benchmarking. For example, if one cell is mistakenly split into several components in both consensus data and caiman data, and both methods detected them, the performance metrics will be artifactually higher. It is important to directly compare the manually-picked ROIs in Figure 3 with the caiman-detected ROIs in Figure 4A (yellow), as the authors claim in the abstract that the software 'achieves near-human performance in detecting locations of active neurons'. It would be good to quantify how well the spatial footprints of the manually drawn ROIs and the caiman detected ROIs overlap. At least please plot the number of ROIs detected by humans against that by the software.</p><p>6. Figure 4B shows that the F1 score of Caiman online is higher than that of Caiman batch. And also, in text, the recall value of Caiman online is higher than Caiman batch. In the Materials and methods section, the authors state Caiman online uses a more strict CNN classifier to avoid false positives – I would expect this to result in a higher precision and lower recall, compared to the results given by Caiman batch – but it turns out to be the opposite. Is it a result of comparing the results with different consensus ground truth data?</p><p>7) The authors analysed how the F1 score of Caiman Batch depends on SNR, but do not directly address the question of why precision is much higher than recall. It would be helpful if the authors would should show how precision and recall change with SNR separately in addition to the current Figure 4D.</p><p>8) Motion correction algorithms and CNN classifier based neuronal filtering are discussed for the online purposes while the computational performance section does not touch on their speed. Running of the demo files in the GitHub link provided by the authors shows that they both introduce additional delays. The CNN classifier (evaluate_components_CNN function) run every few hundred frames is especially computationally expensive (&gt; a few hundred ms on my device). In Figure 8C, is the CNN classifier used? If not, how much time delay will that induce? The computational cost of motion correction and CNN classifier should be reported to verify that.</p><p>9) In Figure 8C, does the 'processing time' in the left panel include the time for 'updating shapes'? Judging from the right panel, if the 'updating shapes' is enabled, it could take larger than 15 seconds to complete processing one frame, which means the software could not function in real-time. Subsection “Computational performance of CAIMAN” say that the shape update functionality can be distributed over several frames or done in parallel to allow for real-time processing. Was this already implemented into the online software? Also, how does the shape update functionality impact the activity traces, and does it bring any substantial advantages? This is not shown (Giovannucci et al., (2017) also does not quantify the differences) but can be useful to know for online implementation of the algorithm into experimental setups. It would be helpful if the authors would quantify how much improvement the 'updating shapes' step actually brings to the fidelity of calcium traces. If the improvement is minimal, then the user might skip this step if speed is the priority.</p><p>10) Figure 3, Figure 7, Figure 9, Appendix 0—figure 10, Appendix 0—figure 11: how were these FOV images generated? Are they the average frames of the motion-corrected videos or are the intensities of pixels within ROIs enhanced somehow? Please clarify. Please show the average image of the videos without enhancement.</p><p><italic>Reviewer #2:</italic></p><p>Let me start this review by acknowledging that CaImAn is unequivocally the state of the art toolbox for calcium imaging, and is an impressive piece of work.</p><p>However, this manuscript a bit confusing. It reads like the combination of an advertisement and documentation, without ever referencing (quantitatively) the gains/performance of the tools in caiman relative to any other tools in the literature. In other words, it is a description and benchmarking of a given tool.</p><p>Such a document is very useful, but also a bit confusing because that is not what peer-reviewed manuscripts typically look like. <italic>eLife</italic> is an interesting journal/venue, so perhaps they are interested in publishing something like this, I won't comment on its suitability for publishing in its current form. I will, however, describe what I believe to be the most important novel contributions that are valuable to the field that are in this manuscript, with some suggested modifications to clarify/improve on some points.</p><p>1) Nine new manually labeled datasets, with four &quot;expert&quot; labelers. In spike sorting, the most important paper ever (imho) was the one that generate &quot;ground truth&quot; data. this manuscript does not do that; one could image a &quot;ground truth&quot; channel but this manuscript does basically provide an upper bound on accuracy for any algorithm on these calcium imaging datasets, as defined by the consensus. This is potentially incredibly valuable. however, the details of the datasets are merely listed in a table in the Methods section, but not quantitative description / evaluation of them. As a resource, showing some images of sample traces, sample frames, summary statistics so that potential users could evaluate and compare their data with these data would be very valuable and interesting. comparing them, how hard is each for the experts, and what about the machines, is the hardness correlated, etc.? And this would be a highlight of this manuscript.</p><p>2) The parallelization of the standard method in the field, as in Figure 8, is a new result, and interesting but the metrics are not &quot;standard&quot; in the parallel programming literature. I'd recommend a few relevant notions of scaling, including strong scaling and weak scaling (https://en.wikipedia.org/wiki/Scalability#Weak_versus_strong_scaling), as well as &quot;scale up&quot; and &quot;scale out&quot; (https://en.wikipedia.org/wiki/Scalability).</p><p>I think strong, weak, scale up, and scale out would be the appropriate quantities to plot for Figure 8, as well as a reference of &quot;optimal scaling&quot;, which is available, e.g., from Amdahl's law (https://en.wikipedia.org/wiki/Amdahl%27s_law). Perhaps users also want the quantities that are plotted but, in terms of demonstrating high quality parallelization procedures, the scaling plots are more standard and informative.</p><p>3) Registration of components across days. It seems one pub previously addressed this, but caiman has a new strategy, employing the (basically standard) approach to aligning points, the Hungarian algorithm. note that Hungarian scales with n^3 naively, though faster implementations are available for sparse data, etc. MATLAB actually has much better implementations than Python last I checked. In any case, I believe this approach is better than the previously publish one just based on first principles, but no evidence is reported, just words. I also believe it is faster when n is small, but when n is big, I suspect it would be slower. A quantitative comparison of accuracy and speed would be desirable. Also, Hungarian typically requires the *same* number of points, but there is no guarantee that this will be the case. I did not quite understand the comment about infinite distances.</p><p>4) Caiman batch and online have a number of minor features/additions/tweaks/bug-fixes relative to previous implementations. however, the resulting improvements in performance is not documented. perhaps that is unnecessary. but a clear list of novel contributions would be very instructive. Getting a tool from &quot;kind of working in our lab&quot; to &quot;actually working in lots of other labs&quot; is really hard, and really important. But the level of effort that went in to doing that is obscured in the text. perhaps this is the most important point of the manuscript.</p><p>5 It is very impressive that all the results were obtained using the same parameters. however, the caveat to that is that all the results were based on using the parameters jointly chosen on *these datasets*, meaning that one would expect the performance on essentially any new dataset to be worse. Held out datasets can provide evidence that performance does not drop too much. With more information on each datasets (see point 1), and similar knowledge of held-out data, one could use these results to predict how well these particular parameters would work on a new dataset that a different lab might generate. Note that this is the same problem as the very popular benchmarking problems in machine vision that are very popular, which doesn't stop those papers from getting published in top journals.</p><p>6) In the end, it remains unclear precisely what you recommend to do and when. Specifically, the manuscript mentions many functions/options/setting/parameters and several pre-processing stages. I also understand that the jupyter notebooks provide some examples. I think some concrete guidance, given that you've now analyzed nine different datasets spanning labs, sensors, etc., you have a wealth of knowledge about the heterogeneity of these datasets that would be valuable for the rest of the community, but is not quite conveyed in the manuscript.</p><p><italic>Reviewer #3:</italic></p><p>Giovannucci et al., present a software package to process calcium imaging data. As calcium imaging is becoming a dominant methodology to record neural activity, a standardized and open-source analytical platform is of importance. CaImAn presents one such effort. The manuscript is well written, and the software seems state-of-the-art and properly validated. I believe <italic>eLife</italic> Tools and Resources is a perfect outlet for such a commendable effort and enthusiastically support the publication of the study. Below are some comments that I believe the authors can address relatively easily prior to publication.</p><p>Subsection “Batch processing of large scale datasets on standalone machines” (parallelization). First, it should be mentioned that the difficulty of parallelization arises from this particular motion correction algorithm in which correction of a frame depends on the previous frames. If each frame is processed independently, like in some other motion correction methods, it would be trivial to parallelize. Second, is there any mechanism to ensure that there is no jump between the temporal chunks? In other words, is the beginning of chunk X adjusted to match the end of chunk X-1? This seems critical for subsequent analysis.</p><p>Subsection “CAIMAN BATCH and CAIMAN ONLINE detect neurons with near-human accuracy” (ground truth).The authors mention that the human performance is overestimated because the ground truth is based on the agreement among the scorers. This effect can be eliminated, and the true human performance can be estimated by cross-validation. For example, in a dataset annotated by four annotators, one can test the performance of one annotator against a putative ground truth defined by the other three annotators. This can be repeated for all the four annotators and the average will give a better estimate of human performance than the current method.</p><p>Subsection “Computational performance of CAIMAN”. The details of the systems are not described in the Materials and methods section. For a Macbook Pro, it has 8 logical CPU cores and 4 physical CPU cores (in 1 CPU). Please specify the CPU model names.</p><p>Subsection “Computational performance of CAIMAN” (employing more processing power results in faster processing). From the figure, a 112 CPU cluster processes the data about three times as fast as a 8 CPU laptop. The performance gain does not seem to be proportional to the number of CPUs available even considering the overhead. Please discuss the overhead of parallelization and the bottleneck when processed in the cluster.</p><p>Subsection “Computational performance of CAIMAN” (the performance scales linearly). Please clarify whether this (linearity) is a visual observation of the results, or is this based on a complexity analysis of the factorization algorithm?</p><p>Subsection “Computational performance of CAIMAN” (enabling real-time processing). Please clarify how often such an update of a footprint is required in order to support real-time processing without parallelization.</p><p><italic>Reviewing editor:</italic></p><p>Please consider adding a reference under &quot;Related Work&quot; to the use of supervised learning (&quot;Adaboost&quot;) to segment active neurons, i.e. Automatic identification of fluorescently labeled brain cells for rapid functional imaging. I. Valmianski, A. Y. Shih, J. D. Driscoll, D. M. Matthews, Y. Freund and D. Kleinfeld, Journal of Neurophysiology (2010) 104:1803-1811.</p></body></sub-article><sub-article article-type="reply" id="SA2"><front-stub><article-id pub-id-type="doi">10.7554/eLife.38173.028</article-id><title-group><article-title>Author response</article-title></title-group></front-stub><body><disp-quote content-type="editor-comment"><p>Your manuscript has been thoroughly reviewed by three outstanding reviewers and your software extensively tested by one of the groups. Your technical contribution, while admittedly introducing no novel approaches per se, is seen as a timely and carefully constructed software package that will help a large community of neuroscientists. However, before we can pass final judgment, we ask you to address all of the comments of the reviewers; this extensive request is based on the pointed nature of the comments and the importance of having your software accepted by the largest possible fraction of the imaging community. Please pay particular attention to queries on implementation.</p></disp-quote><p>We would like to thank the reviewers and the editor for their thorough and thoughtful reviews. CaImAn is a big project and the reviews touched upon almost all of its aspects leading to a large revision of our paper. We believe that our current submission addresses all the issues raised by reviewers. In summary the revised version of our paper includes (among many other improvements):</p><p>A link to a (password protected) website that contains all the datasets, their characteristics and the manual annotations.</p><p>A comparison of CaImAn with the popular package Suite2p.</p><p>A more systematic exploration of the parameter space for both CaImAn batch and CaImAn online, to better distinguish between “average” and “best” cases, and insight for parameter choosing.</p><p>A systematic study on the computational speed for both CaImAn batch and CaImAn online, and the effect of parallelization.</p><p>Concurrently with this submission we also released a new version of CaImAn, that presents a simplified way to run the various algorithms and pass the parameters.</p><disp-quote content-type="editor-comment"><p>Please find our detailed responses below. Since our paper is long, we copied excerpts from the paper (text, figures etc.) that directly address the reviewers’ concerns.</p><p>A few key points to attend to include:</p><p>It is essential to judge the results with CaImAn against existing pipelines, e.g. the very popular Suite2P (Pachitariu et al.) There is no expectation that CaImAn will shine in every dimension of use. Yet the authors simply must supply comparative benchmarks.</p></disp-quote><p>With our revised submission we provide a comparison between Suite2p and CaImAn. The results are described in the text and appear in a new Figure 4—figure supplement 2.</p><p>To compare against Suite2p we used a grid search for some parameters around the defaults provided by its developers and report the combination that gave the best results on average. The software and scripts were cloned from the master branch of the GitHub repository (https://github.com/cortex-lab/Suite2P) on August 27th 2018. We modified the make_db_example.mand master_file_example.mscripts to accommodate for the grid parameter search. One file was excluded from the comparison (J123) because Suite2p would run a significantly large number of iterations and add tens of thousands of components (J123 has very low SNR, it is possible that some ad hoc parameter needed to be set in Suite2p). Suite2p comes with a trainable classifier; to keep the comparison fully automated this classifier was not retrained for each dataset, yet it was used with its default and results were reported both using the default general suite2P classifier or without any classifier. In both conditions we selected the set of parameters providing the highest average f1_score over all the datasets. In all cases CaImAn outperformed Suite2p with varying degrees of difference. Suite2p includes a supervised learning based classifier that is used to evaluate components. The <italic>MEAN +/- STD</italic> F1_score obtained with the default classifier was 0.59 +/-.12 (optimal parameters {1500, 2000,0.25}), whereas without classifier we obtained an F1_score of 0.55 +/- 0.12 ({500,2000,0.25}). It is expected that separate training on each dataset will yield better results (as is also the case with CaImAn). As we stated in our initial cover letter, comparisons like this are not definitive and Suite2p in the hands of a more experienced user might yield better results than the results reported here. We in fact contacted the main developer of Suite2p prior trying out the comparison on our own but received no response. As such we choose to present these results in the supplement and avoid overselling them.</p><disp-quote content-type="editor-comment"><p>The trial data sets need to be completely described and, of course, made publicly and fully available if and when the manuscript is accepted.</p></disp-quote><p>We have deposited the raw data and manual and consensus annotations to Zenodo.</p><disp-quote content-type="editor-comment"><p>It should be stated up front that there is no &quot;ground truth&quot; in the sense of simultaneous electrical and calcium measurements, only a comparison with a consensus view (note &quot;tyranny of the majority&quot; in one interpretation). Reviewer three makes a clear suggestion for cross-validation that should be followed.</p></disp-quote><p>We agree. In the revised manuscript we changed our phrasing to use the term “consensus annotation” as opposed to “consensus ground truth” to make clear your point that there is no well defined ground truth. We also followed the cross-validation approach suggested by reviewer #3 to better understand the variability of human annotators. While the “ground truth” (and thus individual scores) could vary significantly in this case, on average we observed only mild differences. See also our detailed response to the relevant comment from reviewer #3.</p><disp-quote content-type="editor-comment"><p>The authors note that fine-tuning of parameters to individual datasets 'can significantly increase performance'. This must be detailed in light of the experience gained with nine different datasets.</p></disp-quote><p>In the revised version of the paper we made a more systematic search of the parameter space for both CaImAn batch and CaImAn online. We performed a small grid search on some threshold parameters for the quality evaluation tests. For both algorithms we found the set of parameters that give the best results on average for all datasets,as well as the parameters that individually maximize the performance on each dataset. The set of parameters yielding the highest average F1 score was selected as the default and reported in Figure 4B (batch and online) and Table 1. We also checked which choice of parameters maximized the performance for each dataset (batch max and online maxin Figure 4B). The average F1 score are 0.77 +/- 0.03 for batch max, 0.78 +/- 0.04 for online max, 0.75 +/- 0.03 for batch, and 0.76 +/- 0.05 for online. In both cases the average total F1 score can be raised by about 0.02.</p><p>We offer more details the Results section and Materials and methods section (Implementation details of CaImAn batch/online).</p><p>For CaImAn batch: “The global default parameters for all datasets were obtained by performing a grid search on the 9 datasets over the following values: trace peak SNR threshold {1.75, 2, 2.25, 2.5}, spatial correlation threshold {0.75, 0.8, 0.85}, lower threshold on CNN classifier (reject if prediction is below, {0.05, 0.1, 0.15}) and upper threshold on classifier (accept if prediction is above, {0.9,.95, 0.99, 1}). The best overall parameters (used for the results reported in Table 1) were given for the choice (2, 0.85, 0.1, 0.99).”</p><p>For CaImAn online: “To select global parameters for all datasets we performed a grid search on all 9 datasets by varying the following parameters: The peak SNR threshold for accepting a candidate component on the set {0.6, 0.8, 1, 1.2, 1.4, 1.6, 1.8, 2}, the online CNN classifier threshold for accepting candidate components on the set {0.5, 0.55, 0.6, 0.65, 0.7, 0.75}, and the number of candidate components per frame on the set {5, 7, 10, 14}. The best overall parameters (reported in Table 1) were given for the choice $(1.2, 0.65, 10).”</p><disp-quote content-type="editor-comment"><p>Please augment the analysis of Figure 4 to show how precision and recall separately change with signal-to-noise ratio.</p></disp-quote><p>We have followed this suggestion and also show how precision and recall change as a function of the SNR for each file in Figure 4E. The same trend is followed, i.e., performance is higher for neurons with higher SNR traces.</p><disp-quote content-type="editor-comment"><p>Reviewer #1:</p><p>Giovannucci et al., present a new open-source software package for analyzing calcium imaging data collected by two-photon and 1-photon microscopes. While the key algorithms used in the pipeline have been developed over many years and largely overlap with previously published work, new features, e.g. memory mapping, CNN-based classifiers, cross-day registration, have been added to improve the performance and further extend the functionalities of the software. The authors tested the package using various in vivo imaging datasets and compared the results with 'consensus ground truth'. The software is written in Python and is open-source, well-organized, and requires minimal user intervention.</p><p>The main advance of the manuscript is to combine a plethora of powerful algorithms that have been developed and improved over almost a decade into a single software package that allows batch processing as well as real-time processing of calcium imaging data. Most of the algorithms have been optimized for speed and performance to allow their use in real-time experiments such as closed-loop and all-optical experiments. Having a software package for calcium imaging data analysis that is freely available, well-documented and makes use of the most recent algorithms for the multiple steps involved in calcium imaging processing is extremely valuable for the field, as it will improve the quality and the efficiency of calcium data analysis throughout the neuroscience community, and also open up many new experimental avenues. I therefore strongly support publication.</p><p>1) My main concern is the lack of rigorous comparison of the performance of the package with existing solutions. The manuscript only contains internal comparisons but does not show comparisons to existing pipelines (e.g. Suite2P by Pachitariu et al.,) or earlier versions described in other manuscripts (e.g. CNMF in Pnevmatikakis et al., 2016), or state-of-the-art databases such as Neurofinder. This greatly increases the difficulty of judging the overall performance of the software package in its current form. Although the effort the authors went through to generate an improved ground truth data set is laudable, this does not allow one to judge the performance of the package with respect to existing packages/algorithms. For example, a test of how the package performs on the Neurofinder data and how existing packages (like e.g. Suite2P) perform on their newly generated ground truth data would help one to assess the performance of the ROI detection, which is one of the core features of the pipeline. While some of the comparisons have been performed in the respective publications, an overview of the performance of the pipeline with respect to its modules in their current form would be extremely informative.</p></disp-quote><p>We added a detailed comparison of the performance of CaImAn batch to Suite2P. Please refer to our response to the editor comments for details. Besides that, we also analysed all the neurofinder test files and generated the results to be submitted but unfortunately the neurofinder website appears to be down at the moment, therefore submission is impossible (September/October 2018). We have nevertheless added the scripts and results of the performed benchmark in the folder shared with the reviewers. The original CNMF algorithm (Pnevmatikakis et al., 2016) can be considered a subset of the CaImAn batch algorithm. CNMF essentially corresponds to applying CaImAn batch without using patches and without using automated component quality testing. In contrast, CNMF sorted the various components and required from the human to select a cut-off threshold. As such, we chose not to do a formal comparison. For instance, it is not possible to run J123, J115 and K53 on a 128 GB RAM workstation because of the memory load (data not shown).</p><disp-quote content-type="editor-comment"><p>2) Following on from the previous point, in the Discussion, the authors claim that 'apart from computational gains both approaches [MapReduce batch and O<sc>n</sc>ACID online] also result in improved performance'. Is this with respect to CNMF-based approaches or other existing methods, for example, Suite2pl? If the latter, then the caiman software was never directly compared to any other approaches commonly used (discussed in the Related work section) to validate if it outperforms them in terms of speed or accuracy (only shown similar number of cells detected to Zhou et al., (2018)). Some of the datasets used for ground truth testing could be easily analyzed using different algorithms to provide the comparison and demonstrate the advantages of Caiman. Pachitariu et al., (2018) showed Suite2p detects more cells (in particular, cells with low baseline firing rate) than CNMF-based method does. It would be helpful to know in which way Caiman outperforms Suite2P.</p></disp-quote><p>The introduction of patch processing with map reduce, component quality testing, as well as a modified initialization algorithm (RollingGreedyROI vs GreedyROI in CNMF) has improved the results of CaImAn over CNMF in terms of scalability, performance, but also with respect to automation. As we also noted above, the original CNMF algorithm was not fully automated and required the user to order the components and select a cut-off point. As such, we believe a comparison of the two methods will not be particularly instructive. We also do not want to comment on qualitative differences between Suite2p and CaImAn. In its core Suite2p uses a very similar matrix factorization model to the original CNMF algorithm, with the main difference being the background/neuropil model. Other differences arise in the implementation details as well as post-processing methods, are hard to compare qualitatively. Our results directly contradict the statements of Pachitariu et al., (2018) as we demonstrate a qualitatively much better performance of CaImAn than what is reported there.</p><p>Just to clarify, for microendoscopic 1p data, CaImAn does not present an alternative algorithm to CNMF-E (Zhou et al., (2018)). It merely just ports the algorithm in Python and endows it with the map-reduce and component quality testing capabilities. As such, we expect the results to be similar (but not identical).</p><disp-quote content-type="editor-comment"><p>3) The authors claim that CaImAn Online outperforms Batch in terms of neuron detection for longer recordings, while CaImAn Batch is better suited for shorter recordings (Table 1 and also in the Discussion section). What is this claim based on, or what is the performance measure considered? Assuming longer recordings as &gt; 3000 frames and by inspecting Table 2, there is no clear distinction in terms of F1 scores or precision/recall scores (Table 1) based on the file length. Additionally, it is currently hard to inspect this claim as the information to be compared is stored in two separate tables.</p></disp-quote><p>The reviewer is right that our statement was vague and not well supported. Here by longer recordings we mean recordings with length &gt; 20000 or, better stated, experiments long enough where the spatial footprints could change during the course of the experiment due to various non-stationarities. In our analysis we observed that in the three longest datasets (J115, J123, and K53) the difference between CaImAn batch and online was the highest, with online achieving better results as quantified by our precision/recall framework. CaImAn online looks at a local window of the data (current frame plus the residual buffer) to update the activity of each neuron and identify new ones. On the other hand, the batch algorithm looks at the all data at once and tries to express the spatio-temporal activity of each neuron as a simple rank one matrix. We believe that this important difference endows the online algorithm with more robustness to various non-stationarities that can arise in long experimental sessions. To ease the presentation, we have re-ordered the datasets in all the Figures and Tables in an increasing order according to their number of frames and included the number of frames on Table 1. We have also rephrased our wording and included additional discussion to better express our views:</p><p>“[…]While the two algorithms performed similarly on average, CaImAn online tends to perform better for longer datasets (e.g., datasets J115, J123, K53 that all have more than 40000 frames). CaImAn batch operates on the dataset at once, representing each neuron as constant in time spatial footprint. In contrast, CaImAn online operates at a local level looking at a short window over time to detect new components, while adaptively changing their shape based on the new data. This enables CaImAn online to adapt to slow non-stationarities that can appear in long experiments.”</p><disp-quote content-type="editor-comment"><p>4) The manuscript states that fine-tuning of parameters to individual datasets 'can significantly increase performance' (subsection “CAIMAN Batch and CAIMAN online detect neurons with near-human accuracy”) but no evidence is provided for this rather strong statement. It would be interesting to see the results of one of the videos analyzed in this section when the parameters were fine-tuned to show if such adjustment could lead to more reliable results.</p></disp-quote><p>We thank the reviewer for this suggestion. To quantify this comment, we repeated the analysis on the nine labeled datasets using a small grid search over several parameters. The results show an average improvement of 0.02 in terms of F1 score and also highlight strategies for parameter choice. We present these results in Figure 4B and note in the text (see also relevant answer to the editor for parameter details):</p><p>“[…] In general by choosing a parameter combination that maximizes the value for each dataset, the performance increases across the datasets with F_1 scores in the range 0.72-0.85 and average performance 0.78 +/- 0.05 (see Figure 4B (orange) and Figure 4—figure supplement 1 (magenta)). This analysis also shows that in general a strategy of testing a large number of components per timestep, but with stricter criteria, achieves better results than testing fewer components with looser criteria (at the expense of increased computational cost). The results also indicate different strategies for parameter choice depending on the length of a dataset: Lower threshold values and/or larger number of candidate components (Figure 4—figure supplement 1(red)), lead to better values for shorter datasets, but can decrease precision and overall performance for longer datasets. The opposite also holds for higher threshold values and/or smaller number of candidate components (Figure 4—figure supplement 1(blue)), where CaImAn online for shorter datasets can suffer from lower recall values, whereas in longer datasets CaImAn online can add neurons over a longer period of time while maintaining high precision values and thus achieve better performance.”</p><disp-quote content-type="editor-comment"><p>5) In Figure 4A, why are the consensus ground truth components different in the Caiman batch panels and the caiman online panels? Were they constructed using the same SEEDEDINITIALIZATION procedure?</p></disp-quote><p>We thank the reviewer for the careful inspection and for pointing out this issue. We apologize for our oversight, it should not have happened in the first place. The mismatch stemmed from two different thresholds used to binarize the ground truth. It is now fixed in Figure 4A.</p><disp-quote content-type="editor-comment"><p>a) In the same figure, there are clearly some components that do not look like cells, in both Caiman batch/online detected components, and even in the consensus ROIs. The authors should add two panels to this figure, one showing the raw FOV image (preferably just the average image of the video, without further processing) with the manual selected ROI contours marked on it – which should look similar to the last panel in Figure 3A; and another showing the 'consensus ground truth' components given by the SEEDEDINITIALIZATION on top of the average image.</p></disp-quote><p>We added Figure 3—figure supplement 1 comparing the original masks and the ones after seeded initialization for the dataset. Panel b shows that SEEDEDINITIALIZATION allows the original elliptical annotations to adapt to the actual footprint of each component as shown in the FOV. Figure 3—figure supplement 1C also demonstrates some examples of the thresholding process. The main goal of this process is to obtain the most prominent (visible) parts of the neuron, a step that facilitates the comparison process.</p><p>We have also modified the text to make this point more clear:</p><p>“[…]To compare CaImAn against the consensus annotation, the manual annotations were used as binary masks to construct the consensus spatial and temporal components, using the SeededInitialization procedure (Algorithm 3) of CaImAn Batch. This step is necessary in order to adapt the manual annotations to the shapes of the actual spatial footprints of each neuron in the FOV (Figure 3—figure supplement 1), since manual annotations had in general an elliptical shape.”</p><disp-quote content-type="editor-comment"><p>b) A worry is that the initialization procedure might add error to the ground truth and bias it towards the same direction as caiman does, and therefore masking error from benchmarking. For example, if one cell is mistakenly split into several components in both consensus data and caiman data, and both methods detected them, the performance metrics will be artifactually higher. It is important to directly compare the manually-picked ROIs in Figure 3 with the caiman-detected ROIs in Figure 4A (yellow), as the authors claim in the abstract that the software 'achieves near-human performance in detecting locations of active neurons'. It would be good to quantify how well the spatial footprints of the manually drawn ROIs and the caiman detected ROIs overlap. At least please plot the number of ROIs detected by humans against that by the software.</p></disp-quote><p>The SEEDEDINITIALIZATION procedure cannot split (or merge) any selection. Essentially what it does is a simple non-negative matrix factorization where the spatial footprints of each components are constrained to be subsets of the input annotations, together with additional components for background. As noted in our previous response, this is necessary to ensure a comparison among similar ROIs. While this can introduce a bias in terms of the extracted traces, we believe that this bias is significantly less compared to non-model based approaches. For example, simply computing the average over a selected ROI which would introduce contamination from neuropil or components with overlapping spatial footprints. We have updated Table 1 to also include the number of neurons selected by each labeller and our algorithms.</p><disp-quote content-type="editor-comment"><p>6. Figure 4B shows that the F1 score of Caiman online is higher than that of Caiman batch. And also, in text, the recall value of Caiman online is higher than Caiman batch. In the Materials and methods section, the authors state Caiman online uses a more strict CNN classifier to avoid false positives – I would expect this to result in a higher precision and lower recall, compared to the results given by Caiman batch – but it turns out to be the opposite. Is it a result of comparing the results with different consensus ground truth data?</p></disp-quote><p>There is an important difference between the two classifiers. The CNN classifier for the CaImAn batch algorithm is applied only once for every component that has been selected from the CNMF algorithm to test its quality. If it does not pass the test, then it is excluded from the final list of active components. However, the CNN classifier for the CaImAn online algorithm is applied to every candidate component considered at each frame. If a component does not get selected at some point from the online CNN classifier then it can be considered again for inclusion in the future once more signal has been integrated. As a result, it can be included at a later point during the experiment. This explains our choice to train the online CNN classifier to be stricter. This salient point is explained in subsection “Differences between the two classifiers”.</p><p>“Although both classifiers examine the spatial footprints of candidate components, their required performance characteristics are different which led us to train them separately. First of all, the two classifiers are trained on separate data: The batch classifier is trained on spatial footprints extracted from CaImAn batch, whereas the online classifier is trained on residual signals that are generated as CaImAn online operates. The batch classifier examines each component as a post-processing step to determine whether its shape corresponds to a neural cell body. As such, false positive and false negative examples are treated equally and possible mis-classifications do not directly affect the traces of the other components. By contrast, the online classifier operates as part of the online processing pipeline. In this case, a new component that is not detected in a residual buffer is likely to be detected later should it become more active. On the other hand, a component that is falsely detected and incorporated in the online processing pipeline will continue to affect the future buffer residuals and the detection of future components. As such the online algorithm is more sensitive to false positives than false negatives. To ensure a small number of false positive examples under testing conditions, only components with average peak-SNR value at least 4 were considered as positive examples during training of the online classifier<bold>”</bold></p><disp-quote content-type="editor-comment"><p>7) The authors analysed how the F1 score of Caiman Batch depends on SNR, but do not directly address the question of why precision is much higher than recall. It would be helpful if the authors would should show how precision and recall change with SNR separately in addition to the current Figure 4D.</p></disp-quote><p>We updated Figure 4D to show how precision and recall change as a function of the SNR, per the reviewer’s instructions (see also our response to the editor). The main reason for the discrepancy between precision and recall is the existence of the quality assessment step in CaImAn batch and the similar tests that are used during CaImAn online. These tests aim to filter out false positive components a step that will increase precision but do not introduce any missed out components, a step that would increase recall. In fact, if a true positive component is filtered out the recall will actually fall. Appropriately changing the thresholds of the various tests can lead to increased recall at the price of reduced precision. However, we believe that having a higher precision is desirable. As we note in the Discussion section:</p><p>“[…] The performance of CaImAn (especially in its batch version) indicates a considerably higher precision than recall in most datasets. While more balanced results can be achieved by appropriately relaxing the relevant quality evaluation thresholds, we prefer to maintain a higher precision as we believe that the inclusion false positive traces can be more detrimental in any downstream analysis compared to the exclusion of, typically weak, true positive traces. This statement is true especially in experiments with low task dimensionality where a good signal from few neurons can be sufficient for the required hypothesis testing.”</p><disp-quote content-type="editor-comment"><p>8) Motion correction algorithms and CNN classifier based neuronal filtering are discussed for the online purposes while the computational performance section does not touch on their speed. Running of the demo files in the GitHub link provided by the authors shows that they both introduce additional delays. The CNN classifier (evaluate_components_CNN function) run every few hundred frames is especially computationally expensive (&gt; a few hundred ms on my device). In Figure 8C, is the CNN classifier used? If not, how much time delay will that induce? The computational cost of motion correction and CNN classifier should be reported to verify that.</p></disp-quote><p>These are both valid observations. Motion correction adds a computational cost to the online pipeline, especially if non-rigid motion correction is required. In our case, motion correction was done beforehand to ensure that the FOV where CaImAn online operates is perfectly aligned to the FOV that the annotators used. As we note in the text:</p><p>“[…] The analysis here excludes the cost of motion correction, because the files where motion corrected before hand to ensure that manual annotations and the algorithms where operating on the same FOV. This cost depends on whether rigid or pw-rigid motion correction is being used. Rigid motion correction taking on average 3-5ms per frame for a 512 x 512 pixel FOV, whereas pw-rigid motion correction with patch size 128 x 128 pixel is typically 3-4 times slower.”</p><p>The online CNN classifier is run on every step to evaluate the spatial footprints of the candidate components. This also adds a high computational overload (&gt;=10ms) which we found to depend critically on the computing infrastructure. For example, utilizing a GPU, which is not the default mode of installing CaImAn, can help speed up this process significantly. Note that the cost of the CNN classifier mostly occurs from calling the underlying neural network at every frame and less so on the number of components that it needs to check at every point. We discuss these issues further in the paper and have modified Figure 8 to include a breakdown of the computational cost per frame for one dataset (J123).</p><p>“The cost of detecting and incorporating new components remains approximately constant across time and is dependent on the number of candidate components at each timestep. In this example 5 candidate components were used per frame resulting in a relatively low cost (~7ms per frame). As discussed earlier, a higher number of candidate components can lead to higher recall in shorter datasets but at a computational cost. This step can benefit by the use of a GPU for running the online CNN on the footprints of the candidate components. Finally, as also noted in [Giovannucci et al., 2017], the cost of tracking components can be kept low, and shows a mild increase over time as more components are being added by the algorithm.”</p><p>The cost of running the CNN classifier for the zebrafish example is not substantially higher and is significantly smaller than the intervolume time of 1s. An architecture where the CNN classifier is run on a parallel stream can significantly help there although we have not implemented such an architecture yet.</p><disp-quote content-type="editor-comment"><p>9) In Figure 8C, does the 'processing time' in the left panel include the time for 'updating shapes'? Judging from the right panel, if the 'updating shapes' is enabled, it could take larger than 15 seconds to complete processing one frame, which means the software could not function in real-time. Subsection “Computational performance of CAIMAN” say that the shape update functionality can be distributed over several frames or done in parallel to allow for real-time processing. Was this already implemented into the online software? Also, how does the shape update functionality impact the activity traces, and does it bring any substantial advantages? This is not shown (Giovannucci et al., (2017) also does not quantify the differences) but can be useful to know for online implementation of the algorithm into experimental setups. It would be helpful if the authors would quantify how much improvement the 'updating shapes' step actually brings to the fidelity of calcium traces. If the improvement is minimal, then the user might skip this step if speed is the priority.</p></disp-quote><p>Periodically updating the shapes is an important step in the online pipeline: As the experiment proceeds and a neuron keeps firing spikes the algorithm can accumulate more information and produce refined estimates about the neuron’s spatial footprint. This is important for both estimating its future activity more accurately and for distinguishing it from neighboring neurons. Moreover, the spatial footprint of a neuron can slowly vary with time especially in long experiments. The online algorithm can natively adapt to changes like this unlike batch approaches. We have modified our code so that now the shape update is indeed distributed among all the frames and happens only in frames where no new neurons are added to further distribute the cost evenly. We developed a simple algorithm that ensures (i) that every neuron gets updated every N frames (where N is a user defined parameter, default value 200) and (ii) if a neuron is added, then the spatial footprints of all neighboring neurons are updated to adapt to the presence of their new neighbor. We describe this process more analytically in the Materials and methods section (see: distributed shape update). Based on this approach we modified Figure 8 to reflect this new approach and show how the computational cost per frame is allocated to each step of the online algorithm.</p><p>“As discussed in Giovannucci et al., (2017) processing time of CaImAn online depends primarily on i) the computational cost of tracking the temporal activity of discovered neurons, ii) the cost of detecting and incorporating new neurons, and iii) the cost of periodic updates of spatial footprints. Figure 8e shows the cost of each of these steps for each frame, for one epoch of processing of the dataset J123. Distributing the spatial footprint update more uniformly among all frames removes the computational bottleneck appearing in Giovannucci et al., (2017), where all the footprints where updated periodically at the same frame.”</p><disp-quote content-type="editor-comment"><p>10) Figure 3, Figure 7, Figure 9, Appendix 0—figure 10, Appendix 0—figure 11: how were these FOV images generated? Are they the average frames of the motion-corrected videos or are the intensities of pixels within ROIs enhanced somehow? Please clarify. Please show the average image of the videos without enhancement.</p></disp-quote><p>The figure that we generally choose as a background is the so-called correlation image (or for longer datasets the max-correlation image). The value of the correlation image at each pixel corresponds to the average of the correlation coefficients between the trace of a pixel and its neighbors (in an already motion corrected movie). We included this definition in the Materials and methods section but now also refer to it in footnote 3 in the text:</p><p>“[…] The value of the correlation image for each pixel represent the average correlation (across time) between the pixel and its neighbors. This summarization can enhance active neurons and suppress neuropil for two photon datasets (Figure 10A). See Materials and methods section (Collection of manual annotations)”.</p><p>We choose this image because it demonstrates invariance with respect to expression levels and it has the property of attaining high values in pixels that are part of active neurons and lower values for pixels that are not. Since our methods focus on the detection of active neurons, their performance can be better assessed visually by plotting contours against the correlation image as opposed to e.g., the mean. Note that the use of the correlation image is very common in practice and has also been used for source extraction algorithms (as we detail in the related work). To make this point more clear we included the new Figure 3—figure supplement 1A that shows the median (equivalent to mean) and correlation images for three datasets and demonstrates the utility of the correlation image. Median and correlation images overlaid to all the manual labels are shown in the supporting website that contains all our data.</p><disp-quote content-type="editor-comment"><p>Reviewer #2:</p><p>Let me start this review by acknowledging that CaImAn is unequivocally the state of the art toolbox for calcium imaging, and is an impressive piece of work.</p><p>However, this manuscript a bit confusing. It reads like the combination of an advertisement and documentation, without ever referencing (quantitatively) the gains/performance of the tools in caiman relative to any other tools in the literature. In other words, it is a description and benchmarking of a given tool.</p><p>Such a document is very useful, but also a bit confusing because that is not what peer-reviewed manuscripts typically look like. eLife is an interesting journal/venue, so perhaps they are interested in publishing something like this, I won't comment on its suitability for publishing in its current form. I will, however, describe what I believe to be the most important novel contributions that are valuable to the field that are in this manuscript, with some suggested modifications to clarify/improve on some points.</p></disp-quote><p>We thank the reviewer for the useful comments. We added a formal comparison with a state-of-the-art package for calcium imaging data (Suite2P) and demonstrate that CaImAn is competitive when benchmarked against consensus annotations (see answer to editor for details).</p><disp-quote content-type="editor-comment"><p>1) Nine new manually labeled datasets, with four &quot;expert&quot; labelers. In spike sorting, the most important paper ever (imho) was the one that generate &quot;ground truth&quot; data. this manuscript does not do that; one could image a &quot;ground truth&quot; channel but this manuscript does basically provide an upper bound on accuracy for any algorithm on these calcium imaging datasets, as defined by the consensus. This is potentially incredibly valuable. however, the details of the datasets are merely listed in a table in the methods, but not quantitative description / evaluation of them. As a resource, showing some images of sample traces, sample frames, summary statistics so that potential users could evaluate and compare their data with these data would be very valuable and interesting. comparing them, how hard is each for the experts, and what about the machines, is the hardness correlated, etc.? And this would be a highlight of this manuscript.</p></disp-quote><p>We have created a website that can be used to download the raw data and manual and consensus annotations. For each dataset, the website also depicts the labels generated by each labelers and the consensus overlaid on the correlation image, as well as example spatial and temporal components extracted by CaImAn. The site can be found at the url https://users.flatironinstitute.org/~neuro/caiman_paper/</p><p>To log-in use the username “reviewers” and password “island”. We kindly ask the reviewers to not share these credentials; we will make the site publicly accessible should the paper gets accepted.</p><disp-quote content-type="editor-comment"><p>2) The parallelization of the standard method in the field, as in Figure 8, is a new result, and interesting but the metrics are not &quot;standard&quot; in the parallel programming literature. I'd recommend a few relevant notions of scaling, including strong scaling and weak scaling (https://en.wikipedia.org/wiki/Scalability#Weak_versus_strong_scaling), as well as &quot;scale up&quot; and &quot;scale out&quot; (https://en.wikipedia.org/wiki/Scalability).</p><p>I think strong, weak, scale up, and scale out would be the appropriate quantities to plot for Figure 8, as well as a reference of &quot;optimal scaling&quot;, which is available, eg, from Amdahl's law (https://en.wikipedia.org/wiki/Amdahl%27s_law). Perhaps users also want the quantities that are plotted but, in terms of demonstrating high quality parallelization procedures, the scaling plots are more standard and informative.</p></disp-quote><p>We thank the reviewer for this useful suggestion. We have included a new panel in Figure 8 (panel c) that shows the scaling of CaImAn batch when processing a dataset in the same machine but using a different number of CPUs. Even though it would be desirable to plot this Figure all the way up to 112 CPUs (or more) we found that the usage of a computing cluster was leading to variable results due to variable speeds for reading the files over network drives, thus hindering our conclusions. While the language of strong vs weak scaling can help demonstrate the properties of the algorithm, we believe that it can be highly technical for a neuroscience audience and refrained from using it to describe our results. Instead we note:</p><p>“[…] To the study the effects of parallelization we ran CaImAn batch on the same computing architecture (24CPUs) utilizing a different number of CPUs at a time (Figure 8c). In all cases significant speedup factors can be gained by utilizing parallel processing, with the gains being similar for all stages of processing (patch processing, refinement, and quality testing, data not shown). The results show better scaling for medium sized datasets (J123, ~50GB). For the largest datasets (J115, ~100GB), the speedup gains saturate due to limited RAM, whereas for small datasets (~5GB) the speedup factor can be limited by the increased fraction of communications cost overhead (an indication of weak scaling in the language of high performance computing).”</p><disp-quote content-type="editor-comment"><p>3) Registration of components across days. It seems one pub previously addressed this, but caiman has a new strategy, employing the (basically standard) approach to aligning points, the Hungarian algorithm. note that Hungarian scales with n^3 naively, though faster implementations are available for sparse data, etc. MATLAB actually has much better implementations than Python last I checked. In any case, I believe this approach is better than the previously publish one just based on first principles, but no evidence is reported, just words. I also believe it is faster when n is small, but when n is big, I suspect it would be slower. A quantitative comparison of accuracy and speed would be desirable. Also, Hungarian typically requires the *same* number of points, but there is no guarantee that this will be the case. I did not quite understand the comment about infinite distances.</p></disp-quote><p>Our response to this comment can be separated in three parts:</p><p>A) It is true that the Hungarian algorithm is not the most computationally efficient solution for the linear assignment problem. However, for the population sizes that we encounter the cost of solving the linear assignment problem with the Hungarian problem is only a small fraction of the total cost. Moreover, the cubic cost refers to the general case of a dense unstructured affinity matrix. In our case, the matrix is sparse since most pairs of neurons are far from each other and are not considered for registration. This is the reason why we assign infinite distances (i.e., zero affinity) in this case. The sparse matrix leads to faster matrix vector operations and eventually a faster solution.</p><p>B) The infinite distances also permit to have neurons that are unmatched (i.e., have infinite distance from all the neurons in the other session) and enable registering sessions with unequal number of neurons. Every neuron that is matched in the other session with infinite distance is considered as unmatched.</p><p>C) Comparison with the method of Sheintuch et al., is not easy because of the absence of ground truth information. The metric proposed in Sheintuch et al., is tailored for their approach, since it uses the confidence in the assignment that comes from their probabilistic approach. To better compare the two approaches, we applied our method to the same publicly available Allen Brain datasets and computed the transitivity index. For all the datasets considered our transitivity index was very high (&gt;0.99). A similar analysis already appeared in our initial submission in Figure 8C where we compared the approach of registering components through union vs direct registration.</p><p>We modified the paper to include the additional analysis and clarifications.</p><p>&quot;A different approach for multiple day registration was recently proposed by Sheintuch et al., (2017) (CellReg). While a direct comparison of the two methods is not feasible in the absence of ground truth, we tested our method against the same publicly available datasets from the Allen Brain Observatory visual coding database. (http://observatory.brain-map.org/visualcoding). Similarly, to Sheintuch et al., (2017) the same experiment performed over the course of different days produced very different populations of active neurons. To measure performance of R<sc>egister</sc>P<sc>air</sc> for pairwise registration, we computed the transitivity index proposed in Sheintuch et al., (2017). The transitivity property requires that if cell &quot;a&quot; from session 1 matches with cell &quot;b&quot; from session 2, and cell &quot;b&quot; from session 2 matches with cell &quot;c&quot; from session 3, then cell &quot;a&quot; from session 1 should match with cell &quot;c&quot; from session 3 when sessions 1 and 3 are registered directly. For all ten tested datasets the transitivity index was very high, with values ranging from 0.976 to 1 (0.992 +/- 0.006, data not shown). A discussion between the similarities and differences of the two methods is given in Methods section and Materials and methods section.”</p><disp-quote content-type="editor-comment"><p>4) Caiman batch and online have a number of minor features/additions/tweaks/bug-fixes relative to previous implementations. however, the resulting improvements in performance is not documented. perhaps that is unnecessary. but a clear list of novel contributions would be very instructive. Getting a tool from &quot;kind of working in our lab&quot; to &quot;actually working in lots of other labs&quot; is really hard, and really important. But the level of effort that went in to doing that is obscured in the text. perhaps this is the most important point of the manuscript.</p></disp-quote><p>We have tried to make a list of the contributions summarized in this work in the Introduction (see: Contributions). We elaborate more on them in the subsequent Methods section and Materials and methods section. These contributions refer more to algorithmic developments as well as the release of the labeled datasets. With respect to software contributions (e.g., bug fixes) we believe that providing a list would be rather daunting and without clear benefits. Our public code repository is a better source for that information and we invite interested parties to follow (or even participate in) the development of CaImAn there.</p><disp-quote content-type="editor-comment"><p>5 It is very impressive that all the results were obtained using the same parameters. however, the caveat to that is that all the results were based on using the parameters jointly chosen on *these datasets*, meaning that one would expect the performance on essentially any new dataset to be worse. Held out datasets can provide evidence that performance does not drop too much. With more information on each datasets (see point 1), and similar knowledge of held-out data, one could use these results to predict how well these particular parameters would work on a new dataset that a different lab might generate. Note that this is the same problem as the very popular benchmarking problems in machine vision that are very popular, which doesn't stop those papers from getting published in top journals.</p></disp-quote><p>The supervised learning tools that we use in CaImAn pertain to the two CNN classifiers. From these the batch classifier was trained only on the first three datasets, whereas the online classifier was trained on the first five datasets, thus leaving a significant amount of held out data for testing. This is stated in subsection “Classification through CNNs”). For the rest of the pipeline CaImAn mostly uses tools from unsupervised learning (e.g., matrix factorization, tests of correlation coefficients and SNR levels etc). As such it is not exactly trained on a set of data to define a set of parameters which could be subject to overfitting. Thus, we believe that the parameters we pick here for the diverse set of nine datasets offer a sufficient amount of generalization to other datasets.</p><disp-quote content-type="editor-comment"><p>6) In the end, it remains unclear precisely what you recommend to do and when. Specifically, the manuscript mentions many functions/options/setting/parameters and several pre-processing stages. I also understand that the jupyter notebooks provide some examples. I think some concrete guidance, given that you've now analyzed nine different datasets spanning labs, sensors, etc., you have a wealth of knowledge about the heterogeneity of these datasets that would be valuable for the rest of the community, but is not quite conveyed in the manuscript.</p></disp-quote><p>This is a helpful suggestion. We have created an entry on the wiki of our GitHub repo with several tips on using CaImAn. https://github.com/flatironinstitute/CaImAn/wiki/CaImAn-Tips</p><p>We plan to continuously update this entry as our code and experience evolves, which explains our decision to not include this discussion in the main part of the paper. We link to this page from the paper when talking about our software. Please also see our response to reviewer #1, point 4 on parameter choice strategies for CaimAn online.</p><disp-quote content-type="editor-comment"><p>Reviewer #3:</p><p>Giovannucci et al., present a software package to process calcium imaging data. As calcium imaging is becoming a dominant methodology to record neural activity, a standardized and open-source analytical platform is of importance. CaImAn presents one such effort. The manuscript is well written, and the software seems state-of-the-art and properly validated. I believe eLife Tools and Resources is a perfect outlet for such a commendable effort and enthusiastically support the publication of the study. Below are some comments that I believe the authors can address relatively easily prior to publication.</p><p>Subsection “Batch processing of large scale datasets on standalone machines” (parallelization). First, it should be mentioned that the difficulty of parallelization arises from this particular motion correction algorithm in which correction of a frame depends on the previous frames. If each frame is processed independently, like in some other motion correction methods, it would be trivial to parallelize. Second, is there any mechanism to ensure that there is no jump between the temporal chunks? In other words, is the beginning of chunk X adjusted to match the end of chunk X-1? This seems critical for subsequent analysis.</p></disp-quote><p>Jumps between consecutive chunks are avoided by ensuring that eventually all the chunks are registered with the same template. At the beginning each chunk gets its own template but then the templates of all the chunks get a template of their own (a template of templates so to speak) which is used to register each individual frame. We’ve made this more clear in the document (subsection “Batch processing of large scale datasets on standalone machines”):</p><p>“[…] Naive implementations of motion correction algorithms need to either load in memory the full dataset or are constrained to process one frame at a time, therefore preventing parallelization. Motion correction is parallelized in CaImAn batch without significant memory overhead by processing temporal chunks of movie data on different CPUs. First, each chunk is registered with its own template and a new template is formed by the registered data of each chunk. CaImAn batch then broadcasts to each CPU ameta-template, obtained as the median between all templates, which is used to align all the frames in each chunk. Each process writes in parallel to the target file containing motion-corrected data, which is stored as a memory mapped array.”</p><disp-quote content-type="editor-comment"><p>Subsection “CAIMAN BATCH and CAIMAN ONLINE detect neurons with near-human accuracy” (ground truth).The authors mention that the human performance is overestimated because the ground truth is based on the agreement among the scorers. This effect can be eliminated, and the true human performance can be estimated by cross-validation. For example, in a dataset annotated by four annotators, one can test the performance of one annotator against a putative ground truth defined by the other three annotators. This can be repeated for all the four annotators and the average will give a better estimate of human performance than the current method.</p></disp-quote><p>Thanks for this suggestion. We followed this approach by comparing the results of each annotator to the combined results of the other annotators. We report these results in Table 3, (see: subsection “Cross-Validation analysis of manual annotations”). Perhaps surprisingly, the overall results were only modestly decreased, although the scores of individual annotators varied more resulting in more cases where CaImAn achieved a higher F1 score than individual annotators. While this comparison is unbiased (in the sense that it does not favor the manual annotations) it resulted in a set of 3 (or 4) different “ground truth” labels for each dataset and we felt that a direct comparison with the results of CaImAn was not warranted. As such, we do not present this analysis in the main Results section.</p><p>“[…] As mentioned in the Results section, comparing each manual annotation with the consensus can create slightly biased results in favor of individual labelers since the consensus is chosen from the union of individual annotations. To correct for this, we performed a cross-validation analysis where the annotations of each labeler where compared against an automatically generated combinations of the rest of the labelers. To create the combined annotations we first used the R<sc>egisterMulti</sc> procedure to construct the union of each subset of N-1 labelers (where N is the total number of labelers for each dataset). When N=4 then the combined annotation consisted of the components that were selected by at least two labelers. When N=3 a stricter intersection approach was used, i.e., the combined annotation consisted of the components that were selected by both remaining labelers. The procedure was repeated for all subsets of labelers and all datasets. The results are shown in Table 3. While individual scores for specific annotators and datasets vary significantly compared to using the consensus annotation as ground truth (Table 1), the decrease in average performance was modest indicating a low bias level.”</p><disp-quote content-type="editor-comment"><p>Subsection “Computational performance of CAIMAN”. The details of the systems are not described in the Materials and methods section. For a Macbook Pro, it has 8 logical CPU cores and 4 physical CPU cores (in 1 CPU). Please specify the CPU model names.</p></disp-quote><p>We have included this information in the revision:</p><p>“[…] each dataset was analyzed using three different computing architectures: (i) a single laptop (MacBook Pro) with 8 CPUs (Intel Core i7) and 16GB of RAM (blue in Figure 8a), (ii) a linux-based workstation (CentOS) with 24 CPUs (Intel Xeon CPU E5-263 v3 at 3.40GHz) and 128GB of RAM (magenta), and (iii) a linux-based HPC cluster (CentOS) where 112 CPUs (Intel Xeon Gold 6148 at 2.40GHz, 4 nodes, 28 CPUs each) were allocated for the processing task (yellow).”</p><disp-quote content-type="editor-comment"><p>Subsection “Computational performance of CAIMAN” (employing more processing power results in faster processing). From the figure, a 112 CPU cluster processes the data about 3 times as fast as a 8 CPU laptop. The performance gain does not seem to be proportional to the number of CPUs available even considering the overhead. Please discuss the overhead of parallelization and the bottleneck when processed in the cluster.</p></disp-quote><p>This is a valid observation. This phenomenon is mainly due to the fact that the data was processed on two different machines. The 112 CPU cluster was reading the data over network drives, a process that was both slower and somewhat variable. To examine the parallelization properties (see also our response to Reviewer #2, point #2) we more rigorously tested the processing speed when using the <italic>same</italic> machine but different number of cores:</p><p>“[…] To the study the effects of parallelization we ran CaImAn batch on the same computing architecture (24CPUs) utilizing a different number of CPUs at a time (Figure 8c). In all cases significant speedup factors can be gained by utilizing parallel processing, with the gains being similar for all stages of processing (patch processing, refinement, and quality testing, data not shown). The results show better scaling for medium sized datasets (J123, ~50GB). For the largest datasets (J115, ~100GB), the speedup gains saturate due to limited RAM, whereas for small datasets (~5GB) the speedup factor can be limited by the increased fraction of communications cost overhead (an indication of weak scaling in the language of high performance computing).”</p><disp-quote content-type="editor-comment"><p>Subsection “Computational performance of CAIMAN” (the performance scales linearly). Please clarify whether this (linearity) is a visual observation of the results, or is this based on a complexity analysis of the factorization algorithm?</p></disp-quote><p>The linear scaling with respect to frames is based on the complexity of the algorithm. A rank-K factorization of a MxN matrix has typically complexity O(MNK) and all the other analysis steps have linear scaling.</p><disp-quote content-type="editor-comment"><p>Subsection “Computational performance of CAIMAN” (enabling real-time processing). Please clarify how often such an update of a footprint is required in order to support real-time processing without parallelization.</p></disp-quote><p>(Please see also our response to point #9 from reviewer #1 who raised a similar question). We have modified our code so that the shape update is distributed among all the frames and happens only in frames where no new neurons are added to further distribute the cost evenly. We developed a simple algorithm that ensures that (i) every neuron is updated every N frames (where N is a user defined parameter, default value 200) and (ii) if a neuron is added, then the spatial footprints of all neighboring neurons are updated to adapt to the presence of their new neighbor. We describe this process more analytically in the Materials and methods section (see: distributed shape update). Our results indicate that updating all shapes at least once every 500 frames (in a distributed fashion) leads to similar results as in the original case where all the shapes were being updated at once at specific frames.</p><p>“[…] To efficiently distribute the cost of updating shapes across all frames we derived a simple algorithm that i) ensures that every spatial footprint gets updated at least once every T_u steps, where T_u is a user defined parameter, e.g., T_u=200, and ii) no spatial component gets updated during a step when new components were added. The latter property is used to compensate for the additional computational cost that comes with introducing new components. Moreover, whenever a new component gets added the algorithm collects the components with overlapping spatial footprints and makes sure they get updated at the next frame. This property ensures that the footprints of all required components adapt quickly whenever a new neighbor is introduced. The procedure is described in algorithmic form in Algorithm 6.”</p><disp-quote content-type="editor-comment"><p>Reviewing editor:</p><p>Please consider adding a reference under &quot;Related Work&quot; to the use of supervised learning (&quot;Adaboost&quot;) to segment active neurons, i.e. Automatic identification of fluorescently labeled brain cells for rapid functional imaging. I. Valmianski, A. Y. Shih, J. D. Driscoll, D. M. Matthews, Y. Freund and D. Kleinfeld, Journal of Neurophysiology (2010) 104:1803-1811.</p></disp-quote><p>Thank you for this suggestion, we have included this reference in our discussion of related methods.</p></body></sub-article></article>