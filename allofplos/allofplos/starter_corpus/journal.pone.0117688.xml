<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="3.0" xml:lang="en" article-type="research-article">
<front>
<journal-meta>
<journal-id journal-id-type="nlm-ta">PLoS ONE</journal-id>
<journal-id journal-id-type="publisher-id">plos</journal-id>
<journal-id journal-id-type="pmc">plosone</journal-id>
<journal-title-group>
<journal-title>PLOS ONE</journal-title>
</journal-title-group>
<issn pub-type="epub">1932-6203</issn>
<publisher>
<publisher-name>Public Library of Science</publisher-name>
<publisher-loc>San Francisco, CA USA</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">PONE-D-14-04600</article-id>
<article-id pub-id-type="doi">10.1371/journal.pone.0117688</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Research Article</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>Iterative Most-Likely Point Registration (IMLP): A Robust Algorithm for Computing Optimal Shape Alignment</article-title>
<alt-title alt-title-type="running-head">Iterative Most-Likely Point Registration (IMLP)</alt-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes" xlink:type="simple">
<name name-style="western">
<surname>Billings</surname> <given-names>Seth D.</given-names></name>
<xref ref-type="aff" rid="aff001"><sup>1</sup></xref>
<xref ref-type="corresp" rid="cor001">*</xref>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<name name-style="western">
<surname>Boctor</surname> <given-names>Emad M.</given-names></name>
<xref ref-type="aff" rid="aff002"><sup>2</sup></xref>
<xref ref-type="aff" rid="aff001"><sup>1</sup></xref>
<xref ref-type="aff" rid="aff003"><sup>3</sup></xref>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<name name-style="western">
<surname>Taylor</surname> <given-names>Russell H.</given-names></name>
<xref ref-type="aff" rid="aff001"><sup>1</sup></xref>
</contrib>
</contrib-group>
<aff id="aff001">
<label>1</label>
<addr-line>Department of Computer Science, Johns Hopkins University, Baltimore, MD, United States of America</addr-line>
</aff>
<aff id="aff002">
<label>2</label>
<addr-line>Division of Medical Imaging Physics, Department of Radiology, Johns Hopkins Medical Institutions, Baltimore, MD, United States of America</addr-line>
</aff>
<aff id="aff003">
<label>3</label>
<addr-line>Department of Electrical &amp; Computer Engineering, Johns Hopkins University, Baltimore, MD, United States of America</addr-line>
</aff>
<contrib-group>
<contrib contrib-type="editor" xlink:type="simple">
<name name-style="western">
<surname>Rahman</surname> <given-names>M. Sohel</given-names></name>
<role>Academic Editor</role>
<xref ref-type="aff" rid="edit1"/>
</contrib>
</contrib-group>
<aff id="edit1">
<addr-line>Bangladesh University of Engineering and Technology, BANGLADESH</addr-line>
</aff>
<author-notes>
<fn fn-type="conflict" id="coi001">
<p>A minor source of funding for this effort came indirectly through commercial funding by Intuitive Surgical. This does not alter the authors’ adherence to PLOS ONE policies on sharing data and materials.</p>
</fn>
<fn fn-type="con" id="contrib001">
<p>Conceived and designed the experiments: SDB EMB RHT. Performed the experiments: SDB. Analyzed the data: SDB EMB RHT. Contributed reagents/materials/analysis tools: SDB. Wrote the paper: SDB EMB RHT.</p>
</fn>
<corresp id="cor001">* E-mail: <email xlink:type="simple">sbillin3@jhu.edu</email></corresp>
</author-notes>
<pub-date pub-type="collection">
<year>2015</year>
</pub-date>
<pub-date pub-type="epub">
<day>6</day>
<month>3</month>
<year>2015</year>
</pub-date>
<volume>10</volume>
<issue>3</issue>
<elocation-id>e0117688</elocation-id>
<history>
<date date-type="received">
<day>30</day>
<month>1</month>
<year>2014</year>
</date>
<date date-type="accepted">
<day>30</day>
<month>12</month>
<year>2014</year>
</date>
</history>
<permissions>
<copyright-year>2015</copyright-year>
<copyright-holder>Billings et al</copyright-holder>
<license xlink:href="http://creativecommons.org/licenses/by/4.0/" xlink:type="simple">
<license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/" xlink:type="simple">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited</license-p>
</license>
</permissions>
<self-uri content-type="pdf" xlink:href="info:doi/10.1371/journal.pone.0117688" xlink:type="simple"/>
<abstract>
<p>We present a probabilistic registration algorithm that robustly solves the problem of rigid-body alignment between two shapes with high accuracy, by aptly modeling measurement noise in each shape, whether isotropic or anisotropic. For point-cloud shapes, the probabilistic framework additionally enables modeling locally-linear surface regions in the vicinity of each point to further improve registration accuracy. The proposed Iterative Most-Likely Point (IMLP) algorithm is formed as a variant of the popular Iterative Closest Point (ICP) algorithm, which iterates between point-correspondence and point-registration steps. IMLP’s probabilistic framework is used to incorporate a generalized noise model into both the correspondence and the registration phases of the algorithm, hence its name as a most-likely point method rather than a closest-point method. To efficiently compute the most-likely correspondences, we devise a novel search strategy based on a principal direction (PD)-tree search. We also propose a new approach to solve the generalized total-least-squares (GTLS) sub-problem of the registration phase, wherein the point correspondences are registered under a generalized noise model. Our GTLS approach has improved accuracy, efficiency, and stability compared to prior methods presented for this problem and offers a straightforward implementation using standard least squares. We evaluate the performance of IMLP relative to a large number of prior algorithms including ICP, a robust variant on ICP, Generalized ICP (GICP), and Coherent Point Drift (CPD), as well as drawing close comparison with the prior anisotropic registration methods of GTLS-ICP and A-ICP. The performance of IMLP is shown to be superior with respect to these algorithms over a wide range of noise conditions, outliers, and misalignments using both mesh and point-cloud representations of various shapes.</p>
</abstract>
<funding-group>
<funding-statement>Funding and support for this work was provided by: National Science Foundation Graduate Research Fellowship Program (NSF GRFP, <ext-link ext-link-type="uri" xlink:href="http://www.nsfgrfp.org" xlink:type="simple">http://www.nsfgrfp.org</ext-link>), National Institutes of Health Graduate Partnership Program (NIH GPP, <ext-link ext-link-type="uri" xlink:href="http://www.nih.gov" xlink:type="simple">http://www.nih.gov</ext-link>), a gift from Intuitive Surgical (<ext-link ext-link-type="uri" xlink:href="http://www.intuitivesurgical.com" xlink:type="simple">http://www.intuitivesurgical.com</ext-link>), and Johns Hopkins University internal funds (<ext-link ext-link-type="uri" xlink:href="http://www.jhu.edu" xlink:type="simple">http://www.jhu.edu</ext-link>). The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement>
</funding-group>
<counts>
<fig-count count="9"/>
<table-count count="14"/>
<page-count count="45"/>
</counts>
</article-meta>
</front>
<body>
<sec id="sec001" sec-type="intro">
<title>Introduction</title>
<p>The need to co-align multiple representations of a shape or environment is a problem commonly encountered in numerous fields such as robotics, computer vision, and computer-integrated medical procedures. An early method devised to address this problem is the widely popular Iterative Closest Point (ICP) algorithm [<xref ref-type="bibr" rid="pone.0117688.ref001">1</xref>]. ICP operates by decomposing one of the shapes to be registered (the source shape) into a set of points (if not already in point form) and then computing a spatial transformation to align these points to the second shape (the target shape). The registration is performed through a two-step iterative procedure that first computes matching points on the target shape that lie closest to each point of the source shape (the correspondence phase) and then computes the rigid-body spatial transformation, composed of a rotation and translation, that minimizes the sum of square distances between the matched points (the registration phase). This process iterates until the two shapes converge upon a stable alignment. An important implementation concern regards efficient techniques to compute matches in the correspondence phase; the standard approach for closest-point matching is to use a KD tree [<xref ref-type="bibr" rid="pone.0117688.ref002">2</xref>].</p>
<p>Following the introduction of ICP by Besl and McKay [<xref ref-type="bibr" rid="pone.0117688.ref001">1</xref>], many variants of the standard procedure have been proposed. Chen and Medioni [<xref ref-type="bibr" rid="pone.0117688.ref003">3</xref>] minimize point-to-plane square distances between the source points and planes tangent to the target surface at the corresponding target points. They demonstrate the usefulness of this method for registration of range images. Zhang [<xref ref-type="bibr" rid="pone.0117688.ref004">4</xref>] presents a robust ICP variant that incorporates robust statistics and adaptive thresholding to handle outliers and occlusions in the correspondence phase. Maurer et al. [<xref ref-type="bibr" rid="pone.0117688.ref005">5</xref>] introduce weighting terms in the registration phase for each point-pair, which they use for outlier rejection and for normalization of non-uniform point densities when registering head segmentations from medical images. Others have sought to improve correspondence selection by augmenting the match metric with additional information besides distance. Sharp et al. [<xref ref-type="bibr" rid="pone.0117688.ref006">6</xref>], for example, use feature invariants such as curvature to refine match selection. In [<xref ref-type="bibr" rid="pone.0117688.ref007">7</xref>] Armesto et al. present an alternate metric-based distance function for the scan-matching problem in mobile robotics, which takes into account both translation and rotation error of the sensor. Their work is based on extending the 2D metric-based ICP (MbICP) method of Minguez et al. [<xref ref-type="bibr" rid="pone.0117688.ref008">8</xref>] to the 3D case. An interesting approach by Fitzgibbon [<xref ref-type="bibr" rid="pone.0117688.ref009">9</xref>] directly minimizes a model-data error function using the nonlinear Levenberg-Marquardt algorithm while providing robust estimation via a Huber kernel. This approach is made efficient by pre-computing a distance transform on the target shape.</p>
<p>More recently, researchers have investigated probabilistic methods to improve upon the accuracy and flexibility of the standard ICP algorithm through incorporation of generalized noise models. In contrast, the standard ICP method and most variants implicitly assume an isotropic noise model. Estépar et al. [<xref ref-type="bibr" rid="pone.0117688.ref010">10</xref>] introduce the robust Generalized Total-Least-Squares ICP (GTLS-ICP) algorithm for registration problems in medical imaging, which incorporates a generalized total-least-squares framework within the registration phase of the algorithm to account for anisotropic noise in the measured data points. Segal et al. [<xref ref-type="bibr" rid="pone.0117688.ref011">11</xref>] later employ a similar framework for their Generalized ICP (GICP) algorithm; instead of using the probabilistic framework to model measurement noise, however, they structure the noise model to approximately minimize a plane-to-plane square distance metric, which they demonstrate by range image registration to have an accuracy advantage compared to the point-to-plane method of Chen and Medioni [<xref ref-type="bibr" rid="pone.0117688.ref003">3</xref>]. The methods of Estépar et al. and Segal et al. both follow standard ICP procedure in the correspondence phase by using closest points as the match criteria. Maier-Hein et al. [<xref ref-type="bibr" rid="pone.0117688.ref012">12</xref>] later introduce Anisotropic ICP (A-ICP), which primarily extends the works of Estépar et al. and Segal et al. by modifying the match criteria of the correspondence phase to minimize a Mahalanobis-distance metric defined by the covariances of the noise model. In lieu of an efficient method to compute such matches, A-ICP follows a procedure of first computing an initial registration using standard ICP and then continuing the registration with A-ICP while enforcing a user-defined bound on the search distance in the correspondence phase to reduce runtime. Moghari and Abolmaesumi [<xref ref-type="bibr" rid="pone.0117688.ref013">13</xref>] propose an ICP-like method based on the Unscented Kalman Filter algorithm, which is also able to account for anisotropic measurement error. Their method, which was further evaluated in [<xref ref-type="bibr" rid="pone.0117688.ref014">14</xref>], is an improvement over the Extended Kalman Filter algorithm of Pennec and Thirion [<xref ref-type="bibr" rid="pone.0117688.ref015">15</xref>].</p>
<p>Other authors incorporate probabilistic methods in a different manner by using soft matching, where each point in the source shape is matched to every point in the target shape (rather than just one point) with a varying weight or probability associated to each pairing. Early works pioneering this approach were presented by Gold et al. [<xref ref-type="bibr" rid="pone.0117688.ref016">16</xref>] using the softassign technique for matching and by Chui and Rangarajan [<xref ref-type="bibr" rid="pone.0117688.ref017">17</xref>] (TPS-RMP) and Granger and Pennec [<xref ref-type="bibr" rid="pone.0117688.ref018">18</xref>] (EM-ICP) using Gaussian mixture models (GMMs) optimized within an expectation maximization (EM) framework. In addition to rigid registration, Chui and Rangarajan present a non-rigid method based on thin-plate splines. An alternate consistent and symmetric approach for non-rigid registration based on EM-ICP is given by Combès and Prima [<xref ref-type="bibr" rid="pone.0117688.ref019">19</xref>]. A modern variant of the EM-based methods called Coherent Point Drift (CPD) was presented by Myronenko and Song [<xref ref-type="bibr" rid="pone.0117688.ref020">20</xref>], in which they present a closed-form M-step solution for the rigid-body alignment problem and use Gaussian radial basis functions for the non-rigid alignment problem. The CPD algorithm treats one point cloud as the centroids of a GMM, which is aligned by maximum likelihood to a data set represented by the second point cloud. Robustness to outliers is enabled by additionally matching each point to the background using an outlier weighting parameter. An alternate approach presented by Tsin and Kanade [<xref ref-type="bibr" rid="pone.0117688.ref021">21</xref>] treats each set of points as separate kernel densities formed from Gaussian kernel functions centered at each point; the registration is computed by maximizing a kernel correlation (KC) metric between the two densities. Jian and Vemuri [<xref ref-type="bibr" rid="pone.0117688.ref022">22</xref>] present a similar idea for rigid and non-rigid registration by forming GMMs from each point set and minimizing the L2 distance between the Gaussian mixtures. While soft-match variants of ICP tend to achieve higher accuracy and to have wider basins of convergence towards the global optimum, these algorithms also tend to be less efficient than the single-match variants due to the exhaustive point pairings.</p>
<p>In this paper, we propose a new variant of ICP, called the Iterative Most-Likely Point (IMLP) algorithm, which incorporates a probabilistic framework similar to the algorithms of [<xref ref-type="bibr" rid="pone.0117688.ref010">10</xref>–<xref ref-type="bibr" rid="pone.0117688.ref012">12</xref>]. Overall, our method is most similar to A-ICP [<xref ref-type="bibr" rid="pone.0117688.ref012">12</xref>] and likewise incorporates a generalized noise model within both the registration and correspondence phases of the algorithm. A notable difference of our method is that point correspondences are computed to maximize the match likelihood function under the assumed multivariate Gaussian noise model (thus its name), whereas A-ICP computes correspondences to minimize a square Mahalanobis-distance metric. As we will show, these approaches are not equivalent and this difference in match criteria can dramatically impact the accuracy of the computed registration. IMLP also includes distinct approaches for registering shapes of partial overlap and for handling outliers, which is based in part on a dynamic updating of the noise model to account for uncertainty in the matches. As an important implementation concern, we present a novel scheme to efficiently compute the most-likely matches, which enables IMLP to run efficiently. In contrast, the implementation presented for A-ICP relies on pre-registration by an alternate algorithm. Finally, we present a new solution to the generalized total-least-squares (GTLS) optimization problem of the registration phase that is based on a Gauss-Newton approach and that has both speed and accuracy advantages compared to prior published solutions for this problem, while being straightforward to implement. The following paragraphs involve summary discussions of these contributions in further detail.</p>
<p>In this paper, we devise a new search strategy for computing point correspondences under an anisotropic distance criterion, which is based on a modified principal direction (PD)-tree search. A description of the standard PD-tree search technique is found in [<xref ref-type="bibr" rid="pone.0117688.ref023">23</xref>]. While our approach was devised for the most-likely match criterion of IMLP, it is equally applicable to the Mahalanobis-distance match criterion of A-ICP. Our method is efficient and guarantees that the best match, as defined by the match criterion, is always selected from the target shape. The PD tree, also known as the PCA or covariance tree, is similar in concept to the KD tree except that the local coordinate systems assigned to each node of the tree do not have constrained orientations with respect to a global coordinate frame. Williams et al. [<xref ref-type="bibr" rid="pone.0117688.ref024">24</xref>] previously investigated using a PD tree for the problem of closest-point matching.</p>
<p>The efficient correspondence search introduced in this paper is an essential element of the IMLP algorithm, as the primary computational bottleneck for ICP-based methods occurs at the correspondence search. Having an efficient search strategy is therefore critical for the performance and usefulness of these algorithms in practice. As was already mentioned, among the closely related prior works GTLS-ICP and GICP address the issue by simply using closest-point matching, which has an efficient implementation based on the KD-tree data structure [<xref ref-type="bibr" rid="pone.0117688.ref002">2</xref>]. The prior work of A-ICP [<xref ref-type="bibr" rid="pone.0117688.ref012">12</xref>], which does not directly look up matches from a KD tree due to its anisotropic match criteria, addresses the problem of efficiency by first registering the shapes with an alternative ICP-based algorithm and then performing a follow-up registration using A-ICP. In addition, A-ICP imposes a distance bound on the search radius to limit the pool of match candidates for each sample point, with the pool of match candidates being formed using a KD tree. One drawback of this approach is that locating the best match, as defined by the match criteria, cannot be guaranteed. Further, the search within the pool of match candidates is performed exhaustively.</p>
<p>Besides the need for efficient matching in the correspondence phase, a second implementation concern for IMLP regards solving the optimization problem of the registration phase, which computes the rigid-body transformation that optimally aligns the corresponding point sets obtained from the correspondence phase, while taking into account the generalized noise model. Various closed-form solutions for minimizing the isotropic square-distance metric of the standard ICP algorithm have been presented by Horn [<xref ref-type="bibr" rid="pone.0117688.ref025">25</xref>], Arun et al. [<xref ref-type="bibr" rid="pone.0117688.ref026">26</xref>], and Walker et al. [<xref ref-type="bibr" rid="pone.0117688.ref027">27</xref>], which have standard least-squares solutions. The probability framework incorporated by IMLP and by related anisotropic methods leads to a nonlinear generalized total-least-squares (GTLS) optimization over the transformation parameters in the registration phase, for which no closed-form solution is known. Solving the GTLS problem thus requires more complex iterative methods of nonlinear optimization.</p>
<p>As alluded to above, the prior algorithms of Estépar et al. (GTLS-ICP) [<xref ref-type="bibr" rid="pone.0117688.ref010">10</xref>], Segal et al. (GICP) [<xref ref-type="bibr" rid="pone.0117688.ref011">11</xref>], and Maier-Hein et al. (A-ICP) [<xref ref-type="bibr" rid="pone.0117688.ref012">12</xref>] share in common with IMLP the same GTLS problem for computing optimal alignment between corresponding point sets. Estépar et al. present an ad-hoc solution that incorporates, as a component, the iterative GTLS rotation estimation method of Ohta and Kanatani [<xref ref-type="bibr" rid="pone.0117688.ref028">28</xref>], which is based on Kanataniâs renormalization technique [<xref ref-type="bibr" rid="pone.0117688.ref029">29</xref>]. Kanataniâs method solves the problem of computing rotation when translation is known using a quaternion parameterization of the rotation matrix. Estépar et al. extend this solution to solve the parallel problem of computing translation when rotation is known. Their approach for solving the full GTLS rigid-body alignment problem is then a dual-iterative one that first computes rotation assuming known translation and then computes translation assuming known rotation. This process iterates until both estimates converge. Another solution, which to our knowledge has not been applied in an ICP-based context, is presented in a paper by Matei and Meer [<xref ref-type="bibr" rid="pone.0117688.ref030">30</xref>] regarding their heteroscedastic errors-in-variables (HEIV) estimator. The HEIV estimator is a general-purpose method for solving a wide range of problems in computer vision through iterative solutions of a generalized eigenvector problem. The GTLS rigid-body point-set alignment problem is presented as an example application of this technique in [<xref ref-type="bibr" rid="pone.0117688.ref030">30</xref>]. Their solution is similar to the renormalization approach followed in [<xref ref-type="bibr" rid="pone.0117688.ref028">28</xref>] in that both approaches involve solving eigenvalue problems and both use a quaternion parameterization for rotation. Rather than follow an ad-hoc approach, Segal et al. apply a generic conjugate-gradient solver to optimize the GTLS cost function of GICP, in which rotation is parameterized as three Euler angles (as referenced in distributed source code). Maier-Hein et al. employ an ad-hoc approach presented by Balachandran and Fitzpatrick in [<xref ref-type="bibr" rid="pone.0117688.ref031">31</xref>] and further analyzed in [<xref ref-type="bibr" rid="pone.0117688.ref032">32</xref>], which simultaneously solves for rotation and translation by successive linearization of the rotation matrix using a skew-matrix approximation for small rotation. One limitation of this method is that anisotropic noise is assumed for only one of the point sets, which may lead to inaccurate results when both point sets have anisotropic error distributions.</p>
<p>In this paper, we introduce an alternative approach for solving the GTLS problem of aligning corresponding point sets that supports anisotropic noise in both sets of points. Our approach is based on a modified Gauss-Newton framework that is efficient, stable, and simple to implement using a standard least-squares solver. As demonstrated in the Results and Discussion section of this paper, the proposed Gauss-Newton-based approach has advantages compared to the prior ad-hoc methods of Estépar et al. and Balachandran and Fitzpatrick in terms of accuracy, speed, and stability. A benefit of our method, and of the prior ad-hoc methods, is that only a standard least-squares solver is required for its implementation; thus, the software dependency of a nonlinear optimization library is avoided.</p>
<p>The remainder of this paper is structured as follows. A Background subsection completes the Introduction section by providing an algorithmic summary of the standard ICP algorithm as added background for the reader. The Methods section presents the new algorithms proposed in this paper. It begins by introducing the proposed IMLP algorithm at a high level and follows with subsections that detail our approach for each sub-phase of the algorithm, i.e. our approach to efficiently compute the most-likely matches in the correspondence phase and our approach to solve the GTLS problem of registering corresponding point sets in the registration phase. The Results and Discussion section presents an evaluation of our proposed algorithms with respect to a large body of prior works. Finally, in the Conclusions section we summarize our contributions and present our concluding remarks.</p>
<sec id="sec001a">
<title>Background</title>
<sec id="sec001aa">
<title>Iterative Closest Point (ICP) Algorithm</title>
<p>Let <inline-formula id="pone.0117688.e001"><mml:math id="M1" display="inline" overflow="scroll"><mml:mrow><mml:mi>X</mml:mi> <mml:mo>=</mml:mo> <mml:mo>{</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> be a set of points representing the source shape. Suppose the target shape is represented by Ψ, and let <inline-formula id="pone.0117688.e002"><mml:math id="M2" display="inline" overflow="scroll"><mml:mrow><mml:mi>Y</mml:mi> <mml:mo>=</mml:mo> <mml:mo>{</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> be a set of points chosen from this target shape that are in correspondence with (i.e. matched to) the points in <italic>X</italic>. As previously described, ICP proceeds by iterating between two key steps:</p>
<list list-type="order">
<list-item><p>Compute a set of correspondences <italic>Y</italic> from the target shape using the closest-point operator C<sub>CP</sub> (<xref ref-type="disp-formula" rid="pone.0117688.e003">1</xref>).
<disp-formula id="pone.0117688.e003"><alternatives><graphic id="pone.0117688.e003g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e003"/><mml:math id="M3" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mtext>C</mml:mtext> <mml:mtext>CP</mml:mtext></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:mo>Ψ</mml:mo> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:munder><mml:mtext>argmin</mml:mtext> <mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>∈</mml:mo> <mml:mspace width="0.166667em"/><mml:mo>Ψ</mml:mo></mml:mrow></mml:munder> <mml:msub><mml:mrow><mml:mo>∥</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>∥</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(1)</label></disp-formula></p></list-item>
<list-item><p>Compute the rigid-body spatial transformation, comprised of rotation <italic>R</italic> and translation <inline-formula id="pone.0117688.e004"><mml:math id="M4" display="inline" overflow="scroll"><mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:math></inline-formula> and applied to the source shape <italic>X</italic>, that minimizes the sum of square distances between corresponding points (<xref ref-type="disp-formula" rid="pone.0117688.e005">2</xref>).
<disp-formula id="pone.0117688.e005"><alternatives><graphic id="pone.0117688.e005g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e005"/><mml:math id="M5" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mtext>E</mml:mtext> <mml:mtext>LS</mml:mtext></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>X</mml:mi> <mml:mo>,</mml:mo> <mml:mi>Y</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:munder><mml:mo movablelimits="true" form="prefix">min</mml:mo> <mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:munder> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>n</mml:mi></mml:munderover> <mml:msubsup><mml:mrow><mml:mo>∥</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>∥</mml:mo></mml:mrow> <mml:mn>2</mml:mn> <mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(2)</label></disp-formula></p></list-item>
</list>
<p>The first step may be computed efficiently using a KD-tree search. The second step has a closed-form solution computable via Arun’s method [<xref ref-type="bibr" rid="pone.0117688.ref026">26</xref>]. Algorithm 1 provides a summary of the ICP algorithm.</p>
<p><bold>Algorithm 1.</bold> Iterative Closest Point (ICP)</p>
<p specific-use="line"> <bold>input</bold>: Source shape as point cloud: <inline-formula id="pone.0117688.e006"><mml:math id="M6" display="inline" overflow="scroll"><mml:mrow><mml:mi>X</mml:mi> <mml:mo>=</mml:mo> <mml:mo>{</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line">    Target shape: Ψ</p>
<p specific-use="line">    Initial transformation estimate: <inline-formula id="pone.0117688.e007"><mml:math id="M7" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:msub><mml:mi>R</mml:mi> <mml:mn>0</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mn>0</mml:mn></mml:msub> <mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line"> <bold>output</bold>: Final transformation <inline-formula id="pone.0117688.e008"><mml:math id="M8" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> that aligns the shapes <italic>X</italic> and Ψ</p>
<p specific-use="line"><bold>1</bold> Initialize transformation: <inline-formula id="pone.0117688.e009"><mml:math id="M9" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">]</mml:mo></mml:mrow> <mml:mo>←</mml:mo> <mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:msub><mml:mi>R</mml:mi> <mml:mn>0</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mn>0</mml:mn></mml:msub> <mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line"><bold>2</bold> <bold>while</bold> <italic>not converged</italic> <bold>do</bold></p>
<p specific-use="line"><bold>3</bold>  Compute closest-point correspondences <inline-formula id="pone.0117688.e010"><mml:math id="M10" display="inline" overflow="scroll"><mml:mrow><mml:mi>y</mml:mi> <mml:mo>=</mml:mo> <mml:mo>{</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>Y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>:</p>
<p specific-use="line">    <inline-formula id="pone.0117688.e011"><mml:math id="M11" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>←</mml:mo> <mml:msub><mml:mrow><mml:mtext>C</mml:mtext></mml:mrow> <mml:mrow><mml:mtext>cp</mml:mtext></mml:mrow></mml:msub> <mml:mo stretchy="false">(</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:mo>Ψ</mml:mo> <mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line"><bold>4</bold>  Update the transformation to minimize E<sub>LS</sub>(<italic>X, Y</italic>):</p>
<p specific-use="line">    <inline-formula id="pone.0117688.e012"><mml:math id="M12" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover><mml:mi>t</mml:mi> <mml:mo accent="true">⃗</mml:mo></mml:mover> <mml:mspace width="0.167em"/><mml:mo stretchy="false">]</mml:mo> <mml:mo>←</mml:mo> <mml:munder><mml:mtext mathvariant="normal">argmin</mml:mtext> <mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover><mml:mi>t</mml:mi> <mml:mo accent="true">⃗</mml:mo></mml:mover> <mml:mspace width="0.167em"/><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:munder> <mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>n</mml:mi></mml:munderover></mml:mstyle></mml:mrow> <mml:mo stretchy="false">‖</mml:mo> <mml:msub><mml:mover><mml:mi>y</mml:mi> <mml:mo accent="true">⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>−</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mover><mml:mi>x</mml:mi> <mml:mo accent="true">⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>−</mml:mo> <mml:mover><mml:mi>t</mml:mi> <mml:mo accent="true">⃗</mml:mo></mml:mover> <mml:mspace width="0.167em"/><mml:msubsup><mml:mo stretchy="false">‖</mml:mo> <mml:mn>2</mml:mn> <mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line"><bold>5 end</bold></p>
</sec>
</sec>
</sec>
<sec id="sec002" sec-type="materials|methods">
<title>Methods</title>
<p>In this section, we present the proposed Iterative Most-Likely Point (IMLP) algorithm. We first provide an overview of the method, followed by subsections detailing our approach to each sub-phase of the algorithm, i.e. detailing our efficient search strategy for computing most-likely matches in the correspondence phase and detailing our method for solving the alignment of corresponding point sets in the registration phase.</p>
<p>Source code for the IMLP algorithm and the experimental data used in this paper are provided for download at: <ext-link ext-link-type="uri" xlink:type="simple" xlink:href="https://github.com/sbillin/IMLP">https://github.com/sbillin/IMLP</ext-link>.</p>
<sec id="sec002a">
<title>Iterative Most-Likely Point (IMLP) Algorithm</title>
<p>The probabilistic framework of IMLP incorporates a generalized noise model that accounts for anisotropic errors in both the source- and target-point positions. The errors on the measurements of these points are assumed to be independent, zero-mean, multivariate, Gaussian distributed. Thus, treating correspondence as a parameter to be estimated, the likelihood that a transformed source point <inline-formula id="pone.0117688.e013"><mml:math id="M13" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo> <mml:mi>R</mml:mi> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo>+</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> corresponds to a specific target point <inline-formula id="pone.0117688.e014"><mml:math id="M14" display="inline" overflow="scroll"><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:math></inline-formula> is defined as
<disp-formula id="pone.0117688.e015"><alternatives><graphic id="pone.0117688.e015g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e015"/><mml:math id="M15" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mtext>L</mml:mtext> <mml:mtext>match</mml:mtext></mml:msub> <mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>y</mml:mtext></mml:msub> <mml:mo>,</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow></mml:mtd> <mml:mtd><mml:mo>=</mml:mo></mml:mtd> <mml:mtd/></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mfrac><mml:mn>1</mml:mn> <mml:msqrt><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:mn>2</mml:mn> <mml:mi>π</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mn>3</mml:mn></mml:msup> <mml:mrow><mml:mo>∣</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:msup><mml:mi>R</mml:mi> <mml:mi>T</mml:mi></mml:msup> <mml:mo>+</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>y</mml:mtext></mml:msub> <mml:mo>∣</mml:mo></mml:mrow></mml:mrow></mml:msqrt></mml:mfrac> <mml:msup><mml:mi>e</mml:mi> <mml:mrow><mml:mo>-</mml:mo> <mml:mfrac><mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:mfrac> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mi>R</mml:mi> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow> <mml:mi>T</mml:mi></mml:msup> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:msup><mml:mi>R</mml:mi> <mml:mi>T</mml:mi></mml:msup> <mml:mo>+</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>y</mml:mtext></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mi>R</mml:mi> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msup></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(3)</label></disp-formula>
where <italic>M</italic><sub>x</sub> and <italic>M</italic><sub>y</sub> are known covariance matrices describing the noise-model distributions of the source point <inline-formula id="pone.0117688.e016"><mml:math id="M16" display="inline" overflow="scroll"><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:math></inline-formula>
 and target point <inline-formula id="pone.0117688.e017"><mml:math id="M17" display="inline" overflow="scroll"><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:math></inline-formula>
, respectively. We refer to (<xref ref-type="disp-formula" rid="pone.0117688.e015">3</xref>) as the “match-likelihood function”.</p>
<p>The match-likelihood function establishes the probabilistic foundation for IMLP. In the correspondence phase of the algorithm, a match for each source point is selected from the target shape to maximize the match-likelihood function while considering the transformation parameters <italic>R</italic> and <inline-formula id="pone.0117688.e018"><mml:math id="M18" display="inline" overflow="scroll"><mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:math></inline-formula> as known. In the registration phase of the algorithm, the transformation parameters <italic>R</italic> and <inline-formula id="pone.0117688.e019"><mml:math id="M19" display="inline" overflow="scroll"><mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:math></inline-formula> are then updated to maximize the total likelihood over all matched points while considering the matches as known. It is interesting to note that for the case of uniform, isotropic covariances then maximizing the match-likelihood function reduces to minimizing the square match distances, which is the criteria used by standard ICP. Algorithm 2 provides a summary of the IMLP algorithm, to which we refer back repeatedly in the discussion that follows.</p>
<p><bold>Algorithm 2.</bold> Iterative Most-Likely Point (IMLP)</p>
<p specific-use="line"> <bold>input</bold>: Source shape as point cloud: <inline-formula id="pone.0117688.e020"><mml:math id="M20" display="inline" overflow="scroll"><mml:mrow><mml:mi>X</mml:mi> <mml:mo>=</mml:mo> <mml:mo>{</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line">    Target shape: Ψ</p>
<p specific-use="line">    Measurement-error covariances: <italic>M</italic><sub>X</sub> = {<italic>M</italic><sub>X<italic>i</italic></sub>}, <italic>M</italic><sub>Ψ</sub></p>
<p specific-use="line">    Surface-model covariances: <italic>M</italic><sub>SX</sub> = {<italic>M</italic><sub>Sx<italic>i</italic></sub>}, <italic>M</italic><sub>SΨ</sub></p>
<p specific-use="line">    Initial transformation estimate: <inline-formula id="pone.0117688.e021"><mml:math id="M21" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:msub><mml:mi>R</mml:mi> <mml:mn>0</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mn>0</mml:mn></mml:msub> <mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line">    Upper bound on match uncertainty: <inline-formula id="pone.0117688.e022"><mml:math id="M22" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi> <mml:mrow><mml:mtext>max</mml:mtext></mml:mrow> <mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula>       (default: ∞)</p>
<p specific-use="line">    Chi-square threshold value for outliers: <inline-formula id="pone.0117688.e023"><mml:math id="M23" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>χ</mml:mi> <mml:mrow><mml:mtext>thresh</mml:mtext></mml:mrow> <mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula>     (default: 7.81)</p>
<p specific-use="line"> <bold>output</bold>: Final transformation <inline-formula id="pone.0117688.e024"><mml:math id="M24" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> that aligns the shapes <italic>X</italic> and Ψ</p>
<p specific-use="line"><bold>1</bold> Initialize transformation: <inline-formula id="pone.0117688.e025"><mml:math id="M25" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">]</mml:mo></mml:mrow> <mml:mspace width="1pt"/><mml:mrow><mml:mo>←</mml:mo></mml:mrow> <mml:mspace width="1pt"/><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:msub><mml:mi>R</mml:mi> <mml:mn>0</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mn>0</mml:mn></mml:msub> <mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line"><bold>2</bold> Initialize noise model: <italic>σ</italic><sup>2</sup> ← 0</p>
<p specific-use="line"><bold>3</bold> Compute initial correspondences (<xref ref-type="disp-formula" rid="pone.0117688.e044">Equ. 8</xref>):</p>
<p specific-use="line">   <inline-formula id="pone.0117688.e026"><mml:math id="M26" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>y</mml:mtext></mml:msub> <mml:msub><mml:mrow/> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mrow><mml:mtext>M</mml:mtext></mml:mrow> <mml:mtext>S</mml:mtext></mml:msub> <mml:msub><mml:mrow/> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo stretchy="false">]</mml:mo> <mml:mo>←</mml:mo> <mml:msub><mml:mtext>C</mml:mtext> <mml:mtext>mlp</mml:mtext></mml:msub> <mml:mo stretchy="false">(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:mo>Ψ</mml:mo> <mml:mo>,</mml:mo> <mml:mi>I</mml:mi> <mml:mo>,</mml:mo> <mml:mi>I</mml:mi> <mml:mo>,</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line"><bold>4</bold> Skip to Step 6</p>
<p specific-use="line"><bold>5</bold> Compute most-likely correspondences (<xref ref-type="disp-formula" rid="pone.0117688.e044">Equ. 8</xref>):</p>
<p specific-use="line">   <inline-formula id="pone.0117688.e027"><mml:math id="M27" display="inline" overflow="scroll"><mml:mo stretchy="false">[</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>y</mml:mtext></mml:msub> <mml:msub><mml:mrow/> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>S</mml:mtext></mml:msub> <mml:msub><mml:mrow/> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo stretchy="false">]</mml:mo> <mml:mo>←</mml:mo> <mml:msub><mml:mtext>C</mml:mtext> <mml:mrow><mml:mtext>mlp</mml:mtext></mml:mrow></mml:msub> <mml:mo stretchy="false">(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:mo>Ψ</mml:mo> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:msub><mml:mrow/> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>S</mml:mtext></mml:msub> <mml:msub><mml:mrow/> <mml:mrow><mml:mtext>x</mml:mtext> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo>+</mml:mo> <mml:msup><mml:mi>σ</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mi>I</mml:mi> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mo>Ψ</mml:mo></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>S</mml:mtext> <mml:mo>Ψ</mml:mo></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula></p>
<p specific-use="line"><bold>6</bold> Update the match-uncertainty noise-model term (<xref ref-type="disp-formula" rid="pone.0117688.e034">Equ. 4</xref>):</p>
<p specific-use="line">   <inline-formula id="pone.0117688.e028"><mml:math id="M28" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mi>σ</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mo>←</mml:mo> <mml:mi>min</mml:mi> <mml:mrow><mml:mo stretchy="true">(</mml:mo> <mml:mfrac><mml:mn>1</mml:mn> <mml:msub><mml:mi>N</mml:mi> <mml:mtext mathvariant="normal">inlier</mml:mtext></mml:msub></mml:mfrac> <mml:msub><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mspace width="0.167em"/><mml:mo>∈</mml:mo> <mml:mspace width="0.167em"/><mml:mtext mathvariant="normal">inliers</mml:mtext></mml:mrow></mml:msub> <mml:mo stretchy="false">‖</mml:mo> <mml:msub><mml:mover><mml:mi>y</mml:mi> <mml:mo accent="true">⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>−</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mover><mml:mi>x</mml:mi> <mml:mo accent="true">⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>−</mml:mo> <mml:mover><mml:mi>t</mml:mi> <mml:mo accent="true">⃗</mml:mo></mml:mover> <mml:mspace width="0.167em"/><mml:msubsup><mml:mo stretchy="false">‖</mml:mo> <mml:mn>2</mml:mn> <mml:mn>2</mml:mn></mml:msubsup> <mml:mo>,</mml:mo> <mml:msubsup><mml:mi>σ</mml:mi> <mml:mtext mathvariant="normal">max</mml:mtext> <mml:mn>2</mml:mn></mml:msubsup> <mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line"><bold>7</bold> Identify outliers using a chi-square test (<xref ref-type="disp-formula" rid="pone.0117688.e039">Equ. 6</xref>):</p>
<p specific-use="line">   <inline-formula id="pone.0117688.e029"><mml:math id="M29" display="inline" overflow="scroll"> <mml:mrow><mml:mo stretchy="false">(</mml:mo> <mml:msub><mml:mrow><mml:mover accent="true"> <mml:mi>x</mml:mi> <mml:mo stretchy="true">⃗</mml:mo></mml:mover></mml:mrow> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">⃗</mml:mo></mml:mover></mml:mrow> <mml:mi>i</mml:mi></mml:msub> <mml:mo stretchy="false">)</mml:mo> <mml:msub><mml:mrow><mml:mspace width="4pt"/><mml:mtext>is</mml:mtext> <mml:mspace width="4pt"/><mml:mtext>outlier</mml:mtext> <mml:mspace width="4pt"/><mml:mtext>if</mml:mtext> <mml:mspace width="4pt"/><mml:mtext>E</mml:mtext></mml:mrow> <mml:mrow><mml:mtext>SqrMahalDist</mml:mtext></mml:mrow></mml:msub> <mml:mo stretchy="false">(</mml:mo> <mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo stretchy="true">⃗</mml:mo></mml:mover></mml:mrow> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">⃗</mml:mo></mml:mover></mml:mrow> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>x</mml:mtext> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo>+</mml:mo> <mml:mtext/> <mml:msup><mml:mi>σ</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mi>I</mml:mi> <mml:mo>,</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mtext/> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">⃗</mml:mo></mml:mover> <mml:mo stretchy="false">)</mml:mo> <mml:mo>&gt;</mml:mo> <mml:mtext/> <mml:msubsup><mml:mi>χ</mml:mi> <mml:mrow><mml:mtext>thresh</mml:mtext></mml:mrow> <mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line"> and update the outlier noise-model terms (<xref ref-type="disp-formula" rid="pone.0117688.e041">Equ. 7</xref>):</p>
<p specific-use="line">   <inline-formula id="pone.0117688.e030"><mml:math id="M30" display="inline" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>φ</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>=</mml:mo> <mml:mfenced separators="" open="{" close=""><mml:mtable><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mrow><mml:mn>9</mml:mn> <mml:mo>∥</mml:mo></mml:mrow> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:msubsup><mml:mrow><mml:mspace width="0.166667em"/><mml:mo>∥</mml:mo></mml:mrow> <mml:mn>2</mml:mn> <mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mspace width="1.em"/><mml:mtext>if</mml:mtext> <mml:mspace width="4.pt"/><mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mspace width="4.pt"/><mml:mtext>is</mml:mtext> <mml:mspace width="4.pt"/><mml:mtext>an</mml:mtext> <mml:mspace width="4.pt"/><mml:mtext>outlier</mml:mtext></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="left"><mml:mn>0</mml:mn></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mspace width="1.em"/><mml:mtext>otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mfenced></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula></p>
<p specific-use="line"><bold>8</bold> Set the noise-model covariances for the registration phase:</p>
<p specific-use="line">   <inline-formula id="pone.0117688.e031"><mml:math id="M31" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mtext mathvariant="normal">x</mml:mtext> <mml:mi>i</mml:mi></mml:mrow> <mml:mo>*</mml:mo></mml:msubsup> <mml:mo>←</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext mathvariant="normal">x</mml:mtext> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext mathvariant="normal">Sx</mml:mtext> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo>+</mml:mo> <mml:mfrac><mml:msub><mml:mi>φ</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mn>2</mml:mn></mml:mfrac> <mml:mi>I</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula id="pone.0117688.e032"><mml:math id="M32" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mtext mathvariant="normal">y</mml:mtext> <mml:mi>i</mml:mi></mml:mrow> <mml:mo>*</mml:mo></mml:msubsup> <mml:mo>←</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext mathvariant="normal">y</mml:mtext> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext mathvariant="normal">Sy</mml:mtext> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo>+</mml:mo> <mml:mfrac><mml:msub><mml:mi>φ</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mn>2</mml:mn></mml:mfrac> <mml:mi>I</mml:mi> <mml:mo>+</mml:mo> <mml:msup><mml:mi>σ</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mi>I</mml:mi></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line"><bold>9</bold> Update the transformation to align the corresponding point sets by GTLS (<xref ref-type="disp-formula" rid="pone.0117688.e081">Equ. 20</xref>):</p>
<p specific-use="line">   <inline-formula id="pone.0117688.e033"><mml:math id="M33" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo stretchy="false">]</mml:mo> <mml:mo>←</mml:mo> <mml:munder><mml:mrow><mml:mtext>argmin</mml:mtext></mml:mrow> <mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:munder> <mml:mspace width="4.pt"/><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>n</mml:mi></mml:munderover> <mml:mrow/></mml:mstyle></mml:mrow> <mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>−</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>−</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo stretchy="false">)</mml:mo></mml:mrow> <mml:mi>T</mml:mi></mml:msup> <mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo> <mml:mi>R</mml:mi> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>x</mml:mtext> <mml:mi>i</mml:mi></mml:mrow> <mml:mo>*</mml:mo></mml:msubsup> <mml:msup><mml:mi>R</mml:mi> <mml:mi>T</mml:mi></mml:msup> <mml:mo>+</mml:mo> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mi>i</mml:mi></mml:mrow> <mml:mo>*</mml:mo></mml:msubsup> <mml:mo stretchy="false">)</mml:mo></mml:mrow> <mml:mrow><mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:mo stretchy="false">(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>−</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>−</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line"><bold>10</bold> <bold>if</bold> <italic>not converged</italic> <bold>then</bold> goto Step 5</p>
<p>The measurement-error noise models for the source point set and for a corresponding target point set are defined using two sets of covariance matrices <italic>M</italic><sub>X</sub> = {<italic>M</italic><sub>x<italic>i</italic></sub>} and <italic>M</italic><sub>Y</sub> = {<italic>M</italic><sub>y<italic>i</italic></sub>}, where <italic>M</italic><sub>Y</sub> is drawn from a larger set of covariances, <italic>M</italic><sub>Ψ</sub>, that represents the entire target shape. <italic>M</italic><sub>Ψ</sub> may be either a superset of covariances or a rule for computing a covariance given any point on the target shape.</p>
<p>In addition to the covariances used to model measurement error, IMLP includes explicit support for a second set of noise-model covariances <italic>M</italic><sub>SX</sub> = {<italic>M</italic><sub>Sx<italic>i</italic></sub>} and <italic>M</italic><sub>SY</sub> = {<italic>M</italic><sub>Sy<italic>i</italic></sub>}, which are useful for modeling the locally-linear surface patches surrounding each point of a point-cloud shape model. These “surface-model” covariances are added to the measurement-error covariances to obtain the complete noise model for each point. The idea behind the surface-model covariances is to increase the noise-model variance in the surface-parallel directions in order to encourage match errors to be directed along the surface rather than perpendicular to the surface, thereby achieving closer alignment of the underlying surfaces being represented by the point-cloud shape models. This idea forms the basis of the GICP algorithm [<xref ref-type="bibr" rid="pone.0117688.ref011">11</xref>] and was also investigated in [<xref ref-type="bibr" rid="pone.0117688.ref012">12</xref>]. The IMLP algorithm treats the surface-model covariances separately from the measurement-error covariances in order to exclude the surface model from the outlier detection stage, which was found to improve the algorithm’s ability to reject outliers.</p>
<p>As indicated in the algorithm summary, IMLP’s noise model includes additional dynamically computed terms besides the input covariances. The “match-uncertainty” term (<italic>σ</italic><sup>2</sup>) attempts to account for uncertainty in the match process by adding an isotropic variance to the noise model with a magnitude equal to the estimated amount of misalignment between the source and target shapes. In the initial iterations of the algorithm, the residual error between corresponding points is largely due to shape misalignment; thus, the input covariances may not accurately represent the underlying distribution of match errors at first. As the algorithm iterates and the misalignment is reduced, the input covariances are expected to more accurately represent the distribution of match errors. To account for this effect, we follow a similar approach to Estépar et al. [<xref ref-type="bibr" rid="pone.0117688.ref010">10</xref>] and model the match uncertainty as an isotropic noise term having variance equal to the average square residual distance between the corresponding points. However, unlike [<xref ref-type="bibr" rid="pone.0117688.ref010">10</xref>], which includes all match errors in the estimate, we only include match errors from the current set of inliers when computing the match-uncertainty term
<disp-formula id="pone.0117688.e034"><alternatives><graphic id="pone.0117688.e034g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e034"/><mml:math id="M34" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msup><mml:mi>σ</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mo>=</mml:mo> <mml:mfrac><mml:mn>1</mml:mn> <mml:msub><mml:mi>N</mml:mi> <mml:mtext>inlier</mml:mtext></mml:msub></mml:mfrac> <mml:munder><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mspace width="0.166667em"/><mml:mo>∈</mml:mo> <mml:mspace width="0.166667em"/><mml:mtext>inlier</mml:mtext></mml:mrow></mml:munder> <mml:msubsup><mml:mrow><mml:mo>∥</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>∥</mml:mo></mml:mrow> <mml:mn>2</mml:mn> <mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(4)</label></disp-formula>
which has an intuitive appeal and which we found to improve IMLP’s performance with respect to outlier rejection. Note that <italic>N</italic><sub>inlier</sub> represents the number of matches forming the current set of inliers. A detailed justification of this model for estimating match uncertainty is addressed in [<xref ref-type="bibr" rid="pone.0117688.ref006">6</xref>].</p>
<p>Because the match-uncertainty term is isotropic, it may be added to the noise-model covariances of either the source or target points with the same effect. Since the match uncertainty intuitively affects the choice of correspondences, for the registration phase we choose to add this term to the covariances of the target points in Step 8 of Algorithm 2. However, for the correspondence search phase in Step 5, the match-uncertainty term is added to the covariances of the source points, rather than the target points, because this reduces computation in the correspondence phase. Note that because computing <italic>σ</italic><sup>2</sup> requires having a set of correspondences in-hand, a fully isotropic noise model is used for the initialization of correspondences in Step 3.</p>
<p>The match-uncertainty term described above has importance for the chi-square outlier detection test in Step 7 of Algorithm 2. The match-uncertainty term enables the algorithm to converge robustly and quickly in the case of large initial misalignment by accounting for this misalignment in the noise model and preventing an overabundance of matches from being flagged as outliers based on the measurement-error covariances alone. In the case of registering a source and target shape having only partial overlap, it could happen that the average square match distance remains large even at the properly registered alignment. In this case, it may be desirable to prevent the match-uncertainty term from growing too large. To address this issue, we define a maximum threshold (<inline-formula id="pone.0117688.e035"><mml:math id="M35" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi> <mml:mtext mathvariant="normal">max</mml:mtext> <mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula>) on the match uncertainty as an optional input to the IMLP algorithm. If no value is specified by the user, then the maximum threshold is disabled by setting it to a very large value.</p>
<p>Robustness to outliers is enabled via a chi-square test, which is used to identify outlier matches in Step 7 of Algorithm 2. Under an assumption of correspondence and of generalized Gaussian noise, the square Mahalanobis distance between matched points in 3D space is distributed as the sum of squares of three independent normalized Gaussian distributions, each representing a distribution along a different eigenvector of the noise-model covariance matrix. Thus, under the stated assumptions, the square Mahalanobis match distance has a chi-square distribution with three degrees of freedom [<xref ref-type="bibr" rid="pone.0117688.ref033">33</xref>]. Outliers are therefore detected by comparing each square Mahalanobis match distance
<disp-formula id="pone.0117688.e036"><alternatives><graphic id="pone.0117688.e036g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e036"/><mml:math id="M36" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mtext>E</mml:mtext> <mml:mtext>SqrMahalDist</mml:mtext></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>y</mml:mtext></mml:msub> <mml:mo>,</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mi>R</mml:mi> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow> <mml:mi>T</mml:mi></mml:msup> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:msup><mml:mi>R</mml:mi> <mml:mi>T</mml:mi></mml:msup> <mml:mo>+</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>y</mml:mtext></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mi>R</mml:mi> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(5)</label></disp-formula>
to the value of the inverse cumulative density function (CDF) of a chi-square distribution with three degrees of freedom evaluated at some probability <italic>p</italic>. If a square Mahalanobis match distance exceeds this chi-square inverse CDF value (<inline-formula id="pone.0117688.e037"><mml:math id="M37" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>χ</mml:mi> <mml:mtext mathvariant="normal">thresh</mml:mtext> <mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula>) then that match is considered an outlier. Thus, a matched point-pair, <inline-formula id="pone.0117688.e038"><mml:math id="M38" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, with corresponding noise covariances, <italic>M</italic><sub>x</sub> and <italic>M</italic><sub>y</sub>, is an outlier if
<disp-formula id="pone.0117688.e039"><alternatives><graphic id="pone.0117688.e039g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e039"/><mml:math id="M39" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mtext>E</mml:mtext> <mml:mtext>SqrMahalDist</mml:mtext></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>y</mml:mtext></mml:msub> <mml:mo>,</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow> <mml:mo>&gt;</mml:mo> <mml:mo form="prefix">chi2inv</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>p</mml:mi> <mml:mo>,</mml:mo> <mml:mn>3</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:msubsup><mml:mi>χ</mml:mi> <mml:mtext>thresh</mml:mtext> <mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(6)</label></disp-formula>
where chi2inv(<italic>p</italic>, 3) is the chi-square inverse CDF function with three degrees of freedom evaluated at probability <italic>p</italic>. The chi-square inverse CDF threshold (<inline-formula id="pone.0117688.e040"><mml:math id="M40" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>χ</mml:mi> <mml:mtext mathvariant="normal">thresh</mml:mtext> <mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula>) is specified as an optional input parameter to the IMLP algorithm, which enables the user to adapt the algorithm to different percentages of outliers present in the shape data. Setting this threshold to a very large value effectively disables outlier detection. Disabling outlier detection in this manner may be useful in cases where the data is known to be free from outliers or possibly cases where a large initial misalignment is present, although the match-uncertainty term (<italic>σ</italic><sup>2</sup>) already functions as an automatic mechanism to account for large initial misalignment. When no chi-square inverse CDF threshold is specified by the user, the default threshold of 7.81 is used, which corresponds to a chi-square inverse CDF probability of <italic>p</italic> = 0.95.</p>
<p>To reduce the influence of outliers on the computed registration, a set of outlier noise-model terms ({<italic>φ</italic><sub><italic>i</italic></sub>}) are used to bring additional isotropic variance into the noise models of the matches identified to be outliers. The effect of this added variance is to reduce the influence of the outliers in the registration phase [<xref ref-type="bibr" rid="pone.0117688.ref010">10</xref>], which occurs at Step 9 in Algorithm 2. If a match is determined to be an outlier then the outlier noise term, <italic>φ</italic><sub><italic>i</italic></sub>, corresponding to that match is set equal to the square Euclidean distance between the matched points times some factor; otherwise, the outlier term is set to zero (<xref ref-type="disp-formula" rid="pone.0117688.e041">7</xref>).
<disp-formula id="pone.0117688.e041"><alternatives><graphic id="pone.0117688.e041g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e041"/><mml:math id="M41" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>φ</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>=</mml:mo> <mml:mfenced separators="" open="&#xA;x007B;" close=""><mml:mtable><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mrow><mml:mn>9</mml:mn> <mml:mo>∥</mml:mo></mml:mrow> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:msubsup><mml:mrow><mml:mspace width="0.166667em"/><mml:mo>∥</mml:mo></mml:mrow> <mml:mn>2</mml:mn> <mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mspace width="1.em"/><mml:mtext>if</mml:mtext> <mml:mspace width="4.pt"/><mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mspace width="4.pt"/><mml:mtext>is</mml:mtext> <mml:mspace width="4.pt"/><mml:mtext>an</mml:mtext> <mml:mspace width="4.pt"/><mml:mtext>outlier</mml:mtext></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="left"><mml:mn>0</mml:mn></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mspace width="1.em"/><mml:mtext>otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mfenced></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(7)</label></disp-formula></p>
<p>While we have used the factor 9 in our implementation (which brings the outlier match errors within approximately 1/3 standard deviation relative to their noise models), this factor could be reduced or increased to give respectively more or less weight to the outliers if desired.</p>
<p>Alternatively, to completely remove all outlier influence from the registration phase, any matches identified as outliers could be simply removed from the set of matches used to compute the registration in Step 9 of Algorithm 2. This strategy is preferred for cases such as registering shapes having only partial overlap, since the systematic tug from the large body of non-overlapping points could then be significant enough to affect the final accuracy of the registration. For small to moderate percentages of random outliers, our experience has been that inflating the variance works just as well as disregarding the matches entirely.</p>
<p>In our implementation of IMLP, we terminate the algorithm when the magnitudes of change in the transformation parameters <italic>R</italic> and <inline-formula id="pone.0117688.e042"><mml:math id="M42" display="inline" overflow="scroll"><mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:math></inline-formula> remain below some termination threshold values for two consecutive iterations or when a maximum number of iterations has been reached. For translation <inline-formula id="pone.0117688.e043"><mml:math id="M43" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, the magnitude of change is simply computed as the norm of the change in the translation vector. For rotation (<italic>R</italic>), the Rodrigues form for the change in rotation is computed [<xref ref-type="bibr" rid="pone.0117688.ref034">34</xref>] and the angular component (the norm of the Rodrigues vector) is extracted as the magnitude of angular change. The threshold values used in the studies reported for this paper were 0.001 degrees rotation and 0.001 millimeters translation. We note that alternative termination criteria could also be used as substitute for our own.</p>
<p>Due to modifying the underlying noise models during each iteration, the IMLP algorithm cannot be guaranteed to converge. A similar scenario is encountered for many related ICP-based methods, with an in-depth discussion being found in [<xref ref-type="bibr" rid="pone.0117688.ref004">4</xref>]. Because of the possibility for non-convergence, we have added cycling detection as a further termination condition for IMLP. Cycling is detected by monitoring the value of the cost function being minimized within the registration phase. If the minimal cost computed by the registration phase increases twice within a period of four iterations and if the cost following the second increase is within a small tolerance of the cost following the first increase, then a cycle has been detected. In such cases, the algorithm terminates and returns the registration corresponding to the last iteration in which the cost function decreased. This termination condition is primarily a precaution to ensure computational efficiency, as a cycling condition would terminate at the maximum iteration count in any case.</p>
<p>Concerning IMLP’s ability to converge to the correct global solution, we note that, like other ICP-based methods, it is important to begin the registration close enough to the optimal solution in order to prevent converging to an incorrect solution created by local minima.</p>
</sec>
<sec id="sec002b">
<title>IMLP Correspondence Phase: An Efficient PD-Tree Search Strategy for Computing Most-Likely Correspondences</title>
<p>In this subsection we describe our approach to efficiently compute the most-likely matches from the target shape, being those matches that maximize the match-likelihood function previously defined in (<xref ref-type="disp-formula" rid="pone.0117688.e015">3</xref>) as indicated by the most-likely-point operator
<disp-formula id="pone.0117688.e044"><alternatives><graphic id="pone.0117688.e044g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e044"/><mml:math id="M44" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mtext>C</mml:mtext> <mml:mtext>MLP</mml:mtext></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:mo>Ψ</mml:mo> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mo>Ψ</mml:mo></mml:msub> <mml:mo>,</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:munder><mml:mtext>argmax</mml:mtext> <mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:mspace width="0.166667em"/><mml:msub><mml:mi>M</mml:mi> <mml:mtext>y</mml:mtext></mml:msub> <mml:mo stretchy="false">]</mml:mo></mml:mrow> <mml:mspace width="0.166667em"/><mml:mo>∈</mml:mo> <mml:mspace width="0.166667em"/><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:mo>Ψ</mml:mo> <mml:mo>,</mml:mo> <mml:mspace width="0.166667em"/><mml:msub><mml:mi>M</mml:mi> <mml:mo>Ψ</mml:mo></mml:msub> <mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:munder> <mml:msub><mml:mtext>L</mml:mtext> <mml:mtext>match</mml:mtext></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>y</mml:mtext></mml:msub> <mml:mo>,</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow> <mml:mspace width="5.0pt"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(8)</label></disp-formula></p>
<p>Maximizing the match-likelihood function of (<xref ref-type="disp-formula" rid="pone.0117688.e015">3</xref>) simplifies to minimizing the “match-error function”
<disp-formula id="pone.0117688.e045"><alternatives><graphic id="pone.0117688.e045g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e045"/><mml:math id="M45" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mtext>E</mml:mtext> <mml:mtext>match</mml:mtext></mml:msub> <mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>y</mml:mtext></mml:msub> <mml:mo>,</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo> <mml:mo>=</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mrow><mml:mo form="prefix">log</mml:mo> <mml:mo>∣</mml:mo> <mml:mi>R</mml:mi></mml:mrow> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:msup><mml:mi>R</mml:mi> <mml:mi>T</mml:mi></mml:msup> <mml:mo>+</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>y</mml:mtext></mml:msub> <mml:mrow><mml:mo>∣</mml:mo> <mml:mo>+</mml:mo></mml:mrow> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mi>R</mml:mi> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow> <mml:mi>T</mml:mi></mml:msup> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:msup><mml:mi>R</mml:mi> <mml:mi>T</mml:mi></mml:msup> <mml:mo>+</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>y</mml:mtext></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mi>R</mml:mi> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow> <mml:mspace width="5.0pt"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(9)</label></disp-formula></p>
<p>It is important to not disregard the log term within the match-error function when computing the most-likely match, since the noise-model covariances may vary substantially over the target shape in general. Note that both the magnitude of the target covariances (i.e. the eigenvalues) and the orientation of the target covariances (i.e. the directions of the eigenvectors) may significantly alter the value of the log term. Thus, even if the covariance magnitude is fixed for all target noise models, the log term still has an impact for anisotropic distributions that have different orientations at different points on the target surface. If both the magnitudes and orientations of the noise-model covariances are constant across the entire target shape, then minimizing the match-error function reduces to that of minimizing the square Mahalanobis distance term in (<xref ref-type="disp-formula" rid="pone.0117688.e045">9</xref>).</p>
<p>Algorithms 3 and 4 provide a summary of our efficient strategy for computing the most-likely correspondences. Note that in order to simplify the expressions in the summary we represent the noise-model of a target point by the single covariance <italic>M</italic><sub>y</sub>. However, as previously noted, for the IMLP algorithm a target-point noise model is actually represented by two covariances, <italic>M</italic><sub>y</sub> and <italic>M</italic><sub>Sy</sub>, in order to distinguish between components for the measurement error and for the local surface model. For the purposes of this subsection, no distinction between the noise-model components is required, and we will consider <italic>M</italic><sub>y</sub> to represent the total noise-model of a target point, i.e. (<italic>M</italic><sub>y</sub> + <italic>M</italic><sub>Sy</sub>) as defined in the algorithm summary for IMLP. In an actual implementation having both types of noise-model components defined over the target shape, each type of covariance would be stored and returned separately along with the most-likely match.</p>
<p><bold>Algorithm 3.</bold> PD-Tree Search for Most-Likely Correspondence</p>
<p specific-use="line"> <bold>input</bold>: Source point: <inline-formula id="pone.0117688.e046"><mml:math id="M46" display="inline" overflow="scroll"><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:math></inline-formula></p>
<p specific-use="line">   Source-point noise model: <italic>M</italic><sub>x</sub></p>
<p specific-use="line">   PD tree containing target shape (Ψ) and target noise model (<italic>M</italic><sub>Ψ</sub>): <italic>T</italic></p>
<p specific-use="line">   Current transformation: <inline-formula id="pone.0117688.e047"><mml:math id="M47" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line">   Prior most-likely match for this source point: <inline-formula id="pone.0117688.e048"><mml:math id="M48" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mrow><mml:mtext>pre</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mi>_</mml:mi> <mml:mtext>pre</mml:mtext></mml:mrow></mml:msub> <mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line"> <bold>output</bold>: Most-likely match and its corresponding noise model: <inline-formula id="pone.0117688.e049"><mml:math id="M49" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>y</mml:mtext></mml:msub> <mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line"><bold>1</bold> Initialize most-likely match to the prior match:</p>
<p specific-use="line">   <inline-formula id="pone.0117688.e050"><mml:math id="M50" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:mover accent="true"><mml:mtext>y</mml:mtext> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:msub><mml:mtext>M</mml:mtext> <mml:mtext>y</mml:mtext></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>E</mml:mi> <mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msub> <mml:mo stretchy="false">]</mml:mo> <mml:mo>←</mml:mo> <mml:mo stretchy="false">[</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mrow><mml:mtext>prev</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mi>_</mml:mi> <mml:mtext>prev</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>E</mml:mi> <mml:mrow><mml:mtext>match</mml:mtext></mml:mrow></mml:msub> <mml:mo stretchy="false">(</mml:mo> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mrow><mml:mtext>prev</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mi>_</mml:mi> <mml:mtext>prev</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">)</mml:mo> <mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line"><bold>2</bold> Search for more-likely match in the left child of the PD-tree root node:</p>
<p specific-use="line">   <inline-formula id="pone.0117688.e051"><mml:math id="M51" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:msub><mml:mover accent="true"><mml:mtext>y</mml:mtext> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mrow><mml:mtext>LChild</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mo>_</mml:mo> <mml:mtext>LChild</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>E</mml:mi> <mml:mrow><mml:mtext>LChild</mml:mtext></mml:mrow></mml:msub> <mml:mo stretchy="false">]</mml:mo> <mml:mo>←</mml:mo> <mml:mtext>NodeSearch</mml:mtext> <mml:mspace width="1pt"/><mml:mo stretchy="false">(</mml:mo> <mml:mi>T</mml:mi> <mml:mo>.</mml:mo> <mml:mi>R</mml:mi> <mml:mi>o</mml:mi> <mml:mi>o</mml:mi> <mml:mi>t</mml:mi> <mml:mo>.</mml:mo> <mml:mi>L</mml:mi> <mml:mi>C</mml:mi> <mml:mi>h</mml:mi> <mml:mi>i</mml:mi> <mml:mi>l</mml:mi> <mml:mi>d</mml:mi> <mml:mo>,</mml:mo> <mml:msub><mml:mrow><mml:mtext>E</mml:mtext></mml:mrow> <mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:mo>,</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line"><bold>3</bold> <bold>if</bold> <italic>E</italic><sub><italic>LChild</italic></sub> &lt; <italic>E</italic><sub><italic>best</italic></sub> <bold>then</bold> update most-likely match:</p>
<p specific-use="line">   <inline-formula id="pone.0117688.e052"><mml:math id="M52" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>y</mml:mtext></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>E</mml:mi> <mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msub> <mml:mo stretchy="false">]</mml:mo></mml:mrow> <mml:mo>←</mml:mo> <mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mrow><mml:mtext>LChild</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mi>_</mml:mi> <mml:mtext>LChild</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>E</mml:mi> <mml:mrow><mml:mtext>LChild</mml:mtext></mml:mrow></mml:msub> <mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line"><bold>4</bold> Search for more-likely match in the right child of the PD-tree root node:</p>
<p specific-use="line">   <inline-formula id="pone.0117688.e053"><mml:math id="M53" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:msub><mml:mover accent="true"><mml:mtext>y</mml:mtext> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mrow><mml:mtext>RChild</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mi>_</mml:mi> <mml:mtext>RChild</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>E</mml:mi> <mml:mrow><mml:mtext>RChild</mml:mtext></mml:mrow></mml:msub> <mml:mo stretchy="false">]</mml:mo> <mml:mo>←</mml:mo> <mml:mtext>NodeSearch</mml:mtext> <mml:mspace width="1pt"/><mml:mo stretchy="false">(</mml:mo> <mml:mi>T</mml:mi> <mml:mo>.</mml:mo> <mml:mi>R</mml:mi> <mml:mi>o</mml:mi> <mml:mi>o</mml:mi> <mml:mi>t</mml:mi> <mml:mo>.</mml:mo> <mml:mi>R</mml:mi> <mml:mi>C</mml:mi> <mml:mi>h</mml:mi> <mml:mi>i</mml:mi> <mml:mi>l</mml:mi> <mml:mi>d</mml:mi> <mml:mo>,</mml:mo> <mml:msub><mml:mrow><mml:mtext>E</mml:mtext></mml:mrow> <mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mi>_</mml:mi> <mml:mtext>RChild</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line"><bold>5</bold> <bold>if</bold> <italic>E</italic><sub><italic>RChild</italic></sub> &lt; <italic>E</italic><sub><italic>best</italic></sub> <bold>then</bold> update most-likely match:</p>
<p specific-use="line">   <inline-formula id="pone.0117688.e054"><mml:math id="M54" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>M</mml:mi> <mml:mtext>y</mml:mtext></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>E</mml:mi> <mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msub> <mml:mo stretchy="false">]</mml:mo> <mml:mspace width="1pt"/><mml:mo>←</mml:mo> <mml:mspace width="1pt"/><mml:mo stretchy="false">[</mml:mo> <mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow> <mml:mrow><mml:mtext>RChild</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y_RChild</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>E</mml:mi> <mml:mrow><mml:mtext>RChild</mml:mtext></mml:mrow></mml:msub> <mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></p>
<p>Our search strategy for computing the most-likely correspondences is based on a modified PD tree formed around the target shape. The distinguishing element of a PD-tree data structure, in comparison to the standard KD-tree data structure, is that each node of the tree has its own unconstrained local coordinate system rather than requiring the local coordinate frame of each node to be axis-aligned with a common global coordinate system.</p>
<p>A node of the PD-tree is constructed by first computing the covariance of the positions of all datums assigned to the node. A datum is defined to be one of the smallest principle elements comprising the target shape, such as a point from a point cloud or a triangle from a mesh. After the covariance of datum positions is computed, the local coordinate system of the node is defined by aligning the coordinate axes of the node with the eigenvectors of the covariance matrix and positioning the node origin at the mean datum position. It is customary to align the x-axis along the direction of greatest variance (i.e. along the eigenvector associated with the largest eigenvalue). Finally, a bounding box of minimal size is constructed that is axis-aligned with the local coordinate system of the node and that fully contains all datums within the node. The node is then split along the local x-axis (along the direction of greatest variance) in order to form the left and right child nodes, and the process continues down the tree until either the number of datums within the node or the size of the node’s bounding box falls below a threshold value. To begin this process, the root node of the PD tree is formed by assigning to it all datums comprising the entire target shape.</p>
<p><bold>Algorithm 4.</bold> NodeSearch Function for the PD-Tree Search</p>
<p specific-use="line"> <bold>input</bold>: Node of PD tree being search: 𝓝</p>
<p specific-use="line">   Source point: <inline-formula id="pone.0117688.e055"><mml:math id="M55" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line">   Source-point noise model: <italic>M</italic><sub><italic>x</italic></sub></p>
<p specific-use="line">   Current transformation: <inline-formula id="pone.0117688.e056"><mml:math id="M56" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:mover accent="true"><mml:mrow><mml:mi>t</mml:mi> <mml:mo stretchy="false">]</mml:mo></mml:mrow> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line">   Current best match error: <italic>E</italic><sub>best</sub></p>
<p specific-use="line"> <bold>output</bold>: Best match within node: <inline-formula id="pone.0117688.e057"><mml:math id="M57" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow> <mml:mrow><mml:mtext>node</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line">   Noise model of best match within node: <italic>M</italic><sub>y_node</sub></p>
<p specific-use="line">   Updated best match error: <italic>E</italic><sub>node</sub></p>
<p specific-use="line"><bold>1</bold> Initialize the best match within this node:</p>
<p specific-use="line">   <inline-formula id="pone.0117688.e058"><mml:math id="M58" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:msub><mml:mi>E</mml:mi> <mml:mrow><mml:mtext>node</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow> <mml:mrow><mml:mtext>node</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y_node</mml:mtext></mml:mrow></mml:msub> <mml:mo stretchy="false">]</mml:mo> <mml:mspace width="1pt"/><mml:mo>←</mml:mo> <mml:mspace width="1pt"/><mml:mo stretchy="false">[</mml:mo> <mml:msub><mml:mi>E</mml:mi> <mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:mn>0</mml:mn> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:mn>0</mml:mn> <mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line"><bold>2</bold> Compute an ellipsoid bound (𝓔) centered at the transformed source point <inline-formula id="pone.0117688.e059"><mml:math id="M59" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo> <mml:mi>R</mml:mi> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mspace width="1pt"/><mml:mo>+</mml:mo> <mml:mspace width="1pt"/><mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> within which candidates for a better match may be found:</p>
<p specific-use="line">   <inline-formula id="pone.0117688.e060"><mml:math id="M60" display="inline" overflow="scroll"><mml:mrow><mml:mo>𝓔</mml:mo> <mml:mspace width="1pt"/><mml:mo>=</mml:mo> <mml:mspace width="1pt"/><mml:mo>{</mml:mo> <mml:mover accent="true"><mml:mi>z</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mspace width="1pt"/><mml:mo>|</mml:mo> <mml:mspace width="1pt"/><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo> <mml:mover accent="true"><mml:mi>z</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mspace width="1pt"/><mml:mo>−</mml:mo> <mml:mspace width="1pt"/><mml:mi>R</mml:mi> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mspace width="1pt"/><mml:mo>−</mml:mo> <mml:mspace width="1pt"/><mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">)</mml:mo></mml:mrow> <mml:mi>T</mml:mi></mml:msup> <mml:mspace width="1pt"/><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>sub</mml:mtext></mml:mrow></mml:msub> <mml:mo stretchy="false">)</mml:mo></mml:mrow> <mml:mrow><mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:mspace width="1pt"/><mml:mo stretchy="false">(</mml:mo> <mml:mover accent="true"><mml:mi>z</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mspace width="1pt"/><mml:mo>−</mml:mo> <mml:mspace width="1pt"/><mml:mi>R</mml:mi> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mspace width="1pt"/><mml:mo>−</mml:mo> <mml:mspace width="1pt"/><mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">)</mml:mo> <mml:mspace width="1pt"/><mml:mo>≤</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>E</mml:mi> <mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msub> <mml:mspace width="1pt"/><mml:mo>−</mml:mo> <mml:mspace width="1pt"/><mml:mi>l</mml:mi> <mml:mi>o</mml:mi> <mml:msub><mml:mi>g</mml:mi> <mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:msub> <mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line">   See Equations (<xref ref-type="disp-formula" rid="pone.0117688.e074">13</xref>) and (<xref ref-type="disp-formula" rid="pone.0117688.e075">14</xref>, <xref ref-type="disp-formula" rid="pone.0117688.e076">15</xref>, or <xref ref-type="disp-formula" rid="pone.0117688.e078">17</xref>)</p>
<p specific-use="line"><bold>3 if</bold> 𝓔 <italic>intersects</italic> 𝓝.<italic>OBB</italic> <bold>then</bold></p>
<p specific-use="line"><bold>4</bold>   <bold>if</bold> 𝒩 <italic>is a leaf node</italic> <bold>then</bold></p>
<p specific-use="line"><bold>5</bold>    <bold>foreach</bold> <italic>datum</italic><sub><italic>i</italic></sub> ∈ 𝒩 <bold>do</bold></p>
<p specific-use="line"><bold>6</bold>      Compute the most-likely match on <italic>datum</italic><sub><italic>i</italic></sub> to get:</p>
<p specific-use="line">        <inline-formula id="pone.0117688.e061"><mml:math id="M61" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow> <mml:mrow><mml:mtext>datum</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y_datum</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>E</mml:mi> <mml:mrow><mml:mtext>datum</mml:mtext></mml:mrow></mml:msub> <mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> (<xref ref-type="supplementary-material" rid="pone.0117688.s001">S1 Appendix</xref>)</p>
<p specific-use="line"><bold>7</bold>      <bold>if</bold> <italic>E</italic><sub>datum</sub> &lt; <italic>E</italic><sub>node</sub> <bold>then</bold> update best match in node:</p>
<p specific-use="line">        <inline-formula id="pone.0117688.e062"><mml:math id="M62" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow> <mml:mrow><mml:mi>n</mml:mi> <mml:mi>o</mml:mi> <mml:mi>d</mml:mi> <mml:mi>e</mml:mi></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y_node</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>E</mml:mi> <mml:mrow><mml:mtext>node</mml:mtext></mml:mrow></mml:msub> <mml:mo stretchy="false">]</mml:mo> <mml:mspace width="1pt"/><mml:mo>←</mml:mo> <mml:mspace width="1pt"/><mml:mo stretchy="false">[</mml:mo> <mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow> <mml:mrow><mml:mtext>datum</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y_datum</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>E</mml:mi> <mml:mrow><mml:mtext>datum</mml:mtext></mml:mrow></mml:msub> <mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line"><bold>8</bold>    <bold>end</bold></p>
<p specific-use="line"><bold>9</bold>   <bold>else</bold></p>
<p specific-use="line"><bold>10</bold>    Search left child node:</p>
<p specific-use="line">      <inline-formula id="pone.0117688.e063"><mml:math id="M63" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow> <mml:mrow><mml:mtext>LChild</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y_LChild</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>E</mml:mi> <mml:mrow><mml:mtext>LChild</mml:mtext></mml:mrow></mml:msub> <mml:mo stretchy="false">]</mml:mo> <mml:mspace width="1pt"/><mml:mo>←</mml:mo> <mml:mspace width="1pt"/><mml:mtext>NodeSearch</mml:mtext> <mml:mspace width="1pt"/><mml:mtext>(</mml:mtext> <mml:mo>𝓝</mml:mo> <mml:mo>.</mml:mo> <mml:mi>L</mml:mi> <mml:mi>C</mml:mi> <mml:mi>h</mml:mi> <mml:mi>i</mml:mi> <mml:mi>l</mml:mi> <mml:mi>d</mml:mi> <mml:mo>,</mml:mo> <mml:mi> </mml:mi> <mml:msub><mml:mi>E</mml:mi> <mml:mrow><mml:mtext>node</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>M</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line"><bold>11</bold>    <bold>if</bold> <italic>E</italic><sub>LChild</sub> &lt; <italic>E</italic><sub>node</sub> <bold>then</bold> update the most-likely match for this node:</p>
<p specific-use="line">      <inline-formula id="pone.0117688.e064"><mml:math id="M64" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow> <mml:mrow><mml:mtext>node</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y_node</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>E</mml:mi> <mml:mrow><mml:mtext>node</mml:mtext></mml:mrow></mml:msub> <mml:mo stretchy="false">]</mml:mo> <mml:mspace width="1pt"/><mml:mo>←</mml:mo> <mml:mspace width="1pt"/><mml:mo stretchy="false">[</mml:mo> <mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow> <mml:mrow><mml:mtext>LChild</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y_LChild</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>E</mml:mi> <mml:mrow><mml:mtext>LChild</mml:mtext></mml:mrow></mml:msub> <mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line"><bold>12</bold>    Search right child node:</p>
<p specific-use="line">      <inline-formula id="pone.0117688.e065"><mml:math id="M65" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow> <mml:mrow><mml:mtext>RChild</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y_RChild</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>E</mml:mi> <mml:mrow><mml:mtext>RChild</mml:mtext></mml:mrow></mml:msub> <mml:mo stretchy="false">]</mml:mo> <mml:mspace width="1pt"/><mml:mo>←</mml:mo> <mml:mspace width="1pt"/><mml:mtext>NodeSearch</mml:mtext> <mml:mspace width="1pt"/><mml:mtext>(</mml:mtext> <mml:mo>𝓝</mml:mo> <mml:mo>.</mml:mo> <mml:mi>R</mml:mi> <mml:mi>C</mml:mi> <mml:mi>h</mml:mi> <mml:mi>i</mml:mi> <mml:mi>l</mml:mi> <mml:mi>d</mml:mi> <mml:mo>,</mml:mo> <mml:mi> </mml:mi> <mml:msub><mml:mi>E</mml:mi> <mml:mrow><mml:mtext>node</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>M</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line"><bold>13</bold>    <bold>if</bold> <italic>E</italic><sub>RChild</sub> &lt; <italic>E</italic><sub>node</sub> <bold>then</bold> update most-likely match for this node:</p>
<p specific-use="line">      <inline-formula id="pone.0117688.e066"><mml:math id="M66" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow> <mml:mrow><mml:mtext>node</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y_node</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>E</mml:mi> <mml:mrow><mml:mtext>node</mml:mtext></mml:mrow></mml:msub> <mml:mo stretchy="false">]</mml:mo> <mml:mspace width="1pt"/><mml:mo>←</mml:mo> <mml:mspace width="1pt"/><mml:mo stretchy="false">[</mml:mo> <mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow> <mml:mrow><mml:mtext>RChild</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y_RChild</mml:mtext></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mi>E</mml:mi> <mml:mrow><mml:mtext>RChild</mml:mtext></mml:mrow></mml:msub> <mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></p>
<p specific-use="line"><bold>14</bold>   <bold>end</bold></p>
<p specific-use="line"><bold>15 end</bold></p>
<p specific-use="line"> Node Object Parameters:</p>
<p specific-use="line">  Datums and corresponding noise-model covariances in this node: {<italic>datum</italic><sub><italic>i</italic></sub>, <italic>M</italic><sub>y<italic>i</italic></sub>}</p>
<p specific-use="line">  Oriented bounding box bounding all datums in this node: <italic>OBB</italic></p>
<p specific-use="line">  Node noise model used to form a lower bound on match errors within this node:</p>
<p specific-use="line">    {<italic>λ</italic><sub>node_min, <italic>i</italic></sub>} and either <italic>M</italic><sub>node</sub> or <italic>λ</italic><sub>node_max</sub></p>
<p specific-use="line">    (depends on the bounding method chosen in Step 2 of NodeSearch)</p>
<p>To illustrate the process of computing a most-likely match, suppose that we are given a source point <inline-formula id="pone.0117688.e067"><mml:math id="M67" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> having noise covariance <italic>M</italic><sub>x</sub> and that we are given a current candidate for the most-likely match on the target shape having match error <italic>E</italic><sub>best</sub>. The search for the most-likely correspondence begins at the root node of the PD tree and progressively makes it way down the tree until reaching the leaf nodes. Whenever a leaf node is encountered then match errors are computed for every datum within the leaf node and the current candidate for most-likely match is updated whenever a match error smaller than <italic>E</italic><sub>best</sub> is found. When the search that began at the root node is complete then the final candidate for most-likely match will be the most-likely match.</p>
<p>In order to perform the PD-tree search efficiently, the problem to consider before searching deeper within a given node is whether or not it is possible for a target point located anywhere within the node boundary to produce a match error that is lower than the current best match error, <italic>E</italic><sub>best</sub>. If a lower match error is not possible within the bounds of the node, then that node and all nodes below it may be safely skipped. Consider testing a match for which all inputs of the match-error <xref ref-type="disp-formula" rid="pone.0117688.e045">equation (9)</xref> are known, except the position of the target point <inline-formula id="pone.0117688.e068"><mml:math id="M68" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. Our goal then is to determine whether any point located within the node bounds can produce a match error less than <italic>E</italic><sub>best</sub>. Introducing this inequality into (<xref ref-type="disp-formula" rid="pone.0117688.e045">9</xref>) and shifting the log term to the opposite side defines the equation of an ellipsoid centered at the position of the transformed source point <inline-formula id="pone.0117688.e069"><mml:math id="M69" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo> <mml:mi>R</mml:mi> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mspace width="1pt"/><mml:mo>+</mml:mo> <mml:mspace width="1pt"/><mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as given by
<disp-formula id="pone.0117688.e070"><alternatives><graphic id="pone.0117688.e070g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e070"/><mml:math id="M70" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mi>R</mml:mi> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow> <mml:mi>T</mml:mi></mml:msup> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:msup><mml:mi>R</mml:mi> <mml:mi>T</mml:mi></mml:msup> <mml:mo>+</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>y</mml:mtext></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mi>R</mml:mi> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow> <mml:mo>&lt;</mml:mo> <mml:msub><mml:mi>E</mml:mi> <mml:mtext>best</mml:mtext></mml:msub> <mml:mo>-</mml:mo> <mml:mo form="prefix">log</mml:mo> <mml:mrow><mml:mo>∣</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:msup><mml:mi>R</mml:mi> <mml:mi>T</mml:mi></mml:msup> <mml:mo>+</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>y</mml:mtext></mml:msub> <mml:mo>∣</mml:mo></mml:mrow> <mml:mspace width="5.0pt"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(10)</label></disp-formula></p>
<p>Any target point <inline-formula id="pone.0117688.e071"><mml:math id="M71" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> that produces a match error lower than <italic>E</italic><sub>best</sub> will be located within this ellipsoid boundary. The task now is to determine whether the ellipsoid so defined intersects the oriented bounding box (OBB) of the node. If intersection exists, then it is possible that the node may contain a better match. If intersection does not exist, then the given node and all nodes below it cannot contain a better match and may be skipped in the continuing search. To compute the ellipsoid-OBB intersection test, we employ the efficient method described in [<xref ref-type="bibr" rid="pone.0117688.ref035">35</xref>].</p>
<p>The problem of bounding the match error of a node is actually more complicated than indicated above, because different points on the target shape may have different noise-model covariances. Thus, the covariance <italic>M</italic><sub>y</sub> is not static within a node. To address this issue, a substitute (<italic>M</italic><sub>sub</sub>) for the match covariance (<italic>RM</italic><sub>x</sub> <italic>R</italic><sup><italic>T</italic></sup> + <italic>M</italic><sub>y</sub>) is required that produces a lower bound on the match error for any target point within the node relative to the match error obtained when using the target point’s true noise-model covariance. In other words, the ellipsoid bound that results from applying the substitute covariance <italic>M</italic><sub>sub</sub> in (<xref ref-type="disp-formula" rid="pone.0117688.e070">10</xref>) must fully contain all ellipsoid bounds that result from using any covariance in the set {(<italic>RM</italic><sub>x</sub> <italic>R</italic><sup><italic>T</italic></sup> + <italic>M</italic><sub>y<italic>i</italic></sub>)} for all {<italic>M</italic><sub>y<italic>i</italic></sub>} represented within the node. Note that the covariance expression (<italic>RM</italic><sub>x</sub> <italic>R</italic><sup><italic>T</italic></sup> + <italic>M</italic><sub>y</sub>) appears twice in (<xref ref-type="disp-formula" rid="pone.0117688.e070">10</xref>), within both a log and a square Mahalanobis-distance term. In the discussion that follows, we will consider independent replacements for the covariance expressions within each term.</p>
<sec id="sec002ba">
<title>Log-Component Bound</title>
<p>For the log term in (<xref ref-type="disp-formula" rid="pone.0117688.e070">10</xref>) we seek a lower bound from the set of covariances represented within the node, since smaller log values increase the size of the ellipsoid boundary. Consider the two covariances <italic>RM</italic><sub>x</sub> <italic>R</italic><sup><italic>T</italic></sup> and <italic>M</italic><sub>y</sub> each having known eigenvalues {<italic>λ</italic><sub>x,1</sub>, <italic>λ</italic><sub>x,2</sub>, <italic>λ</italic><sub>x,3</sub>} and {<italic>λ</italic><sub>y,1</sub>, <italic>λ</italic><sub>y,2</sub>, <italic>λ</italic><sub>y,3</sub>}, respectively, being arranged in order of increasing magnitude. A lower bound on the determinant of the sum of the two covariances is then given by
<disp-formula id="pone.0117688.e072"><alternatives><graphic id="pone.0117688.e072g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e072"/><mml:math id="M72" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mrow><mml:mo>∣</mml:mo> <mml:mi>R</mml:mi></mml:mrow> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:msup><mml:mi>R</mml:mi> <mml:mi>T</mml:mi></mml:msup> <mml:mo>+</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mrow><mml:mo>∣</mml:mo> <mml:mo>≥</mml:mo></mml:mrow> <mml:munderover><mml:mo>∏</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mn>3</mml:mn></mml:munderover> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>λ</mml:mi> <mml:mrow><mml:mtext>x</mml:mtext> <mml:mo>,</mml:mo> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>λ</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mo>,</mml:mo> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(11)</label></disp-formula>
as proven in [<xref ref-type="bibr" rid="pone.0117688.ref036">36</xref>]. It is clear from the eigen decompositions of the sum of covariances
<disp-formula id="pone.0117688.e073"><alternatives><graphic id="pone.0117688.e073g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e073"/><mml:math id="M73" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>R</mml:mi> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:msup><mml:mi>R</mml:mi> <mml:mi>T</mml:mi></mml:msup> <mml:mo>+</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>y</mml:mtext></mml:msub> <mml:mo>=</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mi>V</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:mo form="prefix">diag</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>λ</mml:mi> <mml:mrow><mml:mtext>x</mml:mtext> <mml:mo>,</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>λ</mml:mi> <mml:mrow><mml:mtext>x</mml:mtext> <mml:mo>,</mml:mo> <mml:mn>2</mml:mn></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>λ</mml:mi> <mml:mrow><mml:mtext>x</mml:mtext> <mml:mo>,</mml:mo> <mml:mn>3</mml:mn></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:msubsup><mml:mi>V</mml:mi> <mml:mtext>x</mml:mtext> <mml:mi>T</mml:mi></mml:msubsup> <mml:msup><mml:mi>R</mml:mi> <mml:mi>T</mml:mi></mml:msup> <mml:mo>+</mml:mo> <mml:msub><mml:mi>V</mml:mi> <mml:mtext>y</mml:mtext></mml:msub> <mml:mo form="prefix">diag</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>λ</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mo>,</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>λ</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mo>,</mml:mo> <mml:mn>2</mml:mn></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>λ</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mo>,</mml:mo> <mml:mn>3</mml:mn></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:msubsup><mml:mi>V</mml:mi> <mml:mtext>y</mml:mtext> <mml:mi>T</mml:mi></mml:msubsup></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(12)</label></disp-formula>
where diag(<italic>d</italic><sub>1</sub>, …, <italic>d</italic><sub><italic>n</italic></sub>) represents a diagonal matrix with the listed diagonal elements beginning from the upper left-hand corner, that this lower bound is achieved when the eigenvectors of <italic>RM</italic><sub>x</sub> <italic>R</italic><sup><italic>T</italic></sup> are in alignment with the eigenvectors of <italic>M</italic><sub>y</sub> associated by eigenvalue rank, i.e. when <italic>RV</italic><sub>x</sub> = <italic>V</italic><sub>y</sub>. A lower bound on the log term for an entire node is therefore made possible by computing the smallest eigenvalue within each rank order (i.e. each magnitude ordering) among all covariance matrices {<italic>M</italic><sub>y<italic>i</italic></sub>} represented in the node. The log term of (<xref ref-type="disp-formula" rid="pone.0117688.e070">10</xref>) may then be replaced by
<disp-formula id="pone.0117688.e074"><alternatives><graphic id="pone.0117688.e074g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e074"/><mml:math id="M74" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>l</mml:mi> <mml:mi>o</mml:mi> <mml:msub><mml:mi>g</mml:mi> <mml:mtext>min</mml:mtext></mml:msub> <mml:mo>=</mml:mo> <mml:mo form="prefix">log</mml:mo> <mml:munderover><mml:mo>∏</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mn>3</mml:mn></mml:munderover> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>λ</mml:mi> <mml:mrow><mml:mtext>x</mml:mtext> <mml:mo>,</mml:mo> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>λ</mml:mi> <mml:mrow><mml:mtext>node_min</mml:mtext> <mml:mo>,</mml:mo> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(13)</label></disp-formula>
where <italic>λ</italic><sub>x, <italic>i</italic></sub> are the eigenvalues of <italic>Mx</italic> by rank order and <italic>λ</italic><sub>node_min, <italic>i</italic></sub> are the smallest eigenvalues within each rank order among all covariances {<italic>Myi</italic>} represented within the node. For example, <italic>λ</italic><sub>node_min,2</sub>, corresponding to the second rank order, is computed by selecting the smallest value from the set of all second-rank eigenvalues represented within the node.</p>
<p>Note that in order to implement the log bound, eigen decompositions for the source and target noise-model covariances need be computed (or provided) only once, since other noise-model components added by the IMLP algorithm are isotropic and uniformly increase each eigenvalue, which does not require a new eigen decomposition. As an optimization, nodes may use the same <italic>λ</italic><sub>node_min, <italic>i</italic></sub> values as used by their parent node whenever these values remain within some factor of the parent’s values. This enables the bound on the log term to be recomputed only when doing so significantly affects the ellipsoid boundary size rather than recomputing the log bound at every node visited.</p>
</sec>
<sec id="sec002bb">
<title>Mahalanobis-Component Bound Method 1: Spherical Bound</title>
<p>In this and the two following sub-subsections we address the problem of determining a substitute covariance for bounding the square Mahalanobis-distance term in (<xref ref-type="disp-formula" rid="pone.0117688.e070">10</xref>) for a given node. For the square Mahalanobis-distance term, we seek a replacement for the match covariance (<italic>RM</italic><sub>x</sub> <italic>R</italic><sup><italic>T</italic></sup> + <italic>M</italic><sub>y</sub>) that has a variance at least as large in any direction as that of any covariance from the set {(<italic>RM</italic><sub>x</sub> <italic>R</italic><sup><italic>T</italic></sup> + <italic>M</italic><sub>y<italic>i</italic></sub>)} for all {<italic>M</italic><sub>y<italic>i</italic></sub>} represented within the node, since increasing the variance in some direction increases the size of the ellipsoid bound in that direction.</p>
<p>The first method that we describe for bounding the square Mahalanobis-distance term provides the simplest and least compact bound. The idea is to replace the entire match covariance (<italic>RM</italic><sub>x</sub> <italic>R</italic><sup><italic>T</italic></sup> + <italic>M</italic><sub>y</sub>) by the expression (<italic>λ</italic><sub>x_max</sub> + <italic>λ</italic><sub>node_max</sub>)<italic>I</italic> where <italic>λ</italic><sub>x_max</sub> is the largest eigenvalue of the source-point covariance <italic>M</italic><sub>x</sub> and <italic>λ</italic><sub>node_max</sub> is the largest eigenvalue among all target-point covariances {<italic>M</italic><sub>y<italic>i</italic></sub>} represented within the node. Performing this substitution along with the substitution of the log bound simplifies (<xref ref-type="disp-formula" rid="pone.0117688.e070">10</xref>) to
<disp-formula id="pone.0117688.e075"><alternatives><graphic id="pone.0117688.e075g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e075"/><mml:math id="M75" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mi>R</mml:mi> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow> <mml:mi>T</mml:mi></mml:msup> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>λ</mml:mi> <mml:mtext>x_max</mml:mtext></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>λ</mml:mi> <mml:mtext>node_max</mml:mtext></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:mi>I</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mi>R</mml:mi> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow> <mml:mo>&lt;</mml:mo> <mml:msub><mml:mi>E</mml:mi> <mml:mtext>best</mml:mtext></mml:msub> <mml:mo>-</mml:mo> <mml:mi>l</mml:mi> <mml:mi>o</mml:mi> <mml:msub><mml:mi>g</mml:mi> <mml:mtext>min</mml:mtext></mml:msub> <mml:mspace width="5.0pt"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(14)</label></disp-formula></p>
<p>The advantage of this method is that the bounding ellipsoid simplifies to a bounding sphere, which results in a sphere-OBB intersection test with the node, which is simpler and more efficient to compute. The simplicity of this method is offset, however, by the cost associated with forming a less compact bound, since a higher number of node searches are performed as a result.</p>
</sec>
<sec id="sec002bc">
<title>Mahalanobis-Component Bound Method 2: Simple Ellipsoidal Bound</title>
<p>An improvement over the first method for bounding the square Mahalanobis-distance term in (<xref ref-type="disp-formula" rid="pone.0117688.e070">10</xref>) may be achieved by finding a replacement for only <italic>M</italic><sub>y</sub> within the match covariance expression (<italic>RM</italic><sub>x</sub> <italic>R</italic><sup><italic>T</italic></sup>+<italic>M</italic><sub>y</sub>). In this case, <italic>M</italic><sub>y</sub> is replaced by <italic>λ</italic><sub>node_max</sub> <italic>I</italic> where <italic>λ</italic><sub>node_max</sub> is as defined for the first bounding method. Performing this substitution and substituting for the log bound simplifies (<xref ref-type="disp-formula" rid="pone.0117688.e070">10</xref>) to
<disp-formula id="pone.0117688.e076"><alternatives><graphic id="pone.0117688.e076g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e076"/><mml:math id="M76" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mi>R</mml:mi> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow> <mml:mi>T</mml:mi></mml:msup> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:msup><mml:mi>R</mml:mi> <mml:mi>T</mml:mi></mml:msup> <mml:mo>+</mml:mo> <mml:msub><mml:mi>λ</mml:mi> <mml:mtext>node_max</mml:mtext></mml:msub> <mml:mi>I</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mi>R</mml:mi> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow> <mml:mo>&lt;</mml:mo> <mml:msub><mml:mi>E</mml:mi> <mml:mtext>best</mml:mtext></mml:msub> <mml:mo>-</mml:mo> <mml:mi>l</mml:mi> <mml:mi>o</mml:mi> <mml:msub><mml:mi>g</mml:mi> <mml:mtext>min</mml:mtext></mml:msub> <mml:mspace width="5.0pt"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(15)</label></disp-formula></p>
<p>This method produces a bounding ellipsoid that is more compact than the bounding sphere of the prior method, yet remains simple to compute. As done for the log bound, a node may re-use the <italic>λ</italic><sub>node_max</sub> value of a parent node whenever its value remains within some factor of the parent’s value. This enables the ellipsoid bound to be recomputed only when doing so results in a significant reduction of the ellipsoid boundary rather than recomputing the covariance expression at every node visited.</p>
</sec>
<sec id="sec002bd">
<title>Mahalanobis-Component Bound Method 3: Compact Ellipsoidal Bound</title>
<p>This final method for bounding the square Mahalanobis-distance term in (<xref ref-type="disp-formula" rid="pone.0117688.e070">10</xref>) is the most compact but also the most complex bound. As previously mentioned, consider that a substitute for the match covariance must produce a bounding ellipsoid that fully contains all ellipsoid bounds that result when using any covariance from the set {(<italic>RM</italic><sub>x</sub> <italic>R</italic><sup><italic>T</italic></sup>+<italic>M</italic><sub>y<italic>i</italic></sub>)} for all {<italic>M</italic><sub>y<italic>i</italic></sub>} represented within the node. Further, consider that increasing the variance of <italic>M</italic><sub>y</sub> in any direction strictly increases the ellipsoid boundary defined by (<xref ref-type="disp-formula" rid="pone.0117688.e070">10</xref>). The strategy then is to compute a new covariance that has a variance at least as large in all directions as any covariance {<italic>M</italic><sub>y<italic>i</italic></sub>} represented within the node while producing a bounding ellipsoid that is as compact as possible. This may be accomplished by computing a new covariance, <italic>M</italic><sub>node</sub>, that defines the ellipsoid of minimal volume that fully contains the union of all ellipsoids produced by each covariance {<italic>M</italic><sub>y<italic>i</italic></sub>} represented within the node.
<disp-formula id="pone.0117688.e077"><alternatives><graphic id="pone.0117688.e077g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e077"/><mml:math id="M77" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:msub><mml:mi>M</mml:mi> <mml:mtext>node</mml:mtext></mml:msub></mml:mtd> <mml:mtd><mml:mo>=</mml:mo></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:munder><mml:mtext>argmin</mml:mtext> <mml:mi>M</mml:mi></mml:munder> <mml:mrow><mml:mo>∣</mml:mo> <mml:msup><mml:mi>M</mml:mi> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:mo>∣</mml:mo></mml:mrow> <mml:mspace width="4.pt"/><mml:mtext>such</mml:mtext> <mml:mspace width="4.pt"/><mml:mtext>that</mml:mtext> <mml:mspace width="4.pt"/><mml:mtext>the</mml:mtext> <mml:mspace width="4.pt"/><mml:mtext>ellipsoid</mml:mtext> <mml:mspace width="4.pt"/><mml:mtext>defined</mml:mtext> <mml:mspace width="4.pt"/><mml:mtext>by</mml:mtext> <mml:mspace width="4.pt"/><mml:mrow><mml:mo>{</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>∈</mml:mo> <mml:mspace width="0.166667em"/><mml:msup><mml:mi mathvariant="double-struck">R</mml:mi> <mml:mn>3</mml:mn></mml:msup> <mml:mspace width="0.166667em"/><mml:mo>∣</mml:mo> <mml:mspace width="0.166667em"/><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:msup><mml:mspace width="0.166667em"/><mml:mi>T</mml:mi></mml:msup> <mml:msup><mml:mi>M</mml:mi> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>≤</mml:mo> <mml:mn>1</mml:mn> <mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mspace width="4.pt"/><mml:mtext>fully</mml:mtext> <mml:mspace width="4.pt"/><mml:mtext>contains</mml:mtext> <mml:mspace width="4.pt"/><mml:mtext>the</mml:mtext> <mml:mspace width="4.pt"/><mml:mtext>union</mml:mtext> <mml:mspace width="4.pt"/><mml:mtext>of</mml:mtext> <mml:mspace width="4.pt"/><mml:mtext>ellipsoids</mml:mtext> <mml:mspace width="4.pt"/><mml:munder><mml:mo>⋃</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mspace width="0.166667em"/><mml:mo>∈</mml:mo> <mml:mspace width="0.166667em"/><mml:mtext>node</mml:mtext></mml:mrow></mml:munder> <mml:mrow><mml:mo>{</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>∈</mml:mo> <mml:mspace width="0.166667em"/><mml:msup><mml:mi mathvariant="double-struck">R</mml:mi> <mml:mn>3</mml:mn></mml:msup> <mml:mspace width="0.166667em"/><mml:mo>∣</mml:mo> <mml:mspace width="0.166667em"/><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:msup><mml:mspace width="0.166667em"/><mml:mi>T</mml:mi></mml:msup> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mi>i</mml:mi></mml:mrow> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msubsup> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>≤</mml:mo> <mml:mn>1</mml:mn> <mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(16)</label></disp-formula></p>
<p>Note that the covariance, <italic>M</italic>, computed in (<xref ref-type="disp-formula" rid="pone.0117688.e077">16</xref>) is constrained to be a symmetric, positive-definite matrix. A method for approximating the minimal volume bounding ellipsoid of ellipsoids is addressed in [<xref ref-type="bibr" rid="pone.0117688.ref037">37</xref>]. Also note that <italic>M</italic><sub>node</sub> is computed only once for each node when constructing the PD tree and is thereafter stored as a property of the node. Performing the substitutions for <italic>M</italic><sub>node</sub> and for the log bound modifies (<xref ref-type="disp-formula" rid="pone.0117688.e070">10</xref>) to be
<disp-formula id="pone.0117688.e078"><alternatives><graphic id="pone.0117688.e078g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e078"/><mml:math id="M78" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mi>R</mml:mi> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow> <mml:mi>T</mml:mi></mml:msup> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:msup><mml:mi>R</mml:mi> <mml:mi>T</mml:mi></mml:msup> <mml:mo>+</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>node</mml:mtext></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mi>R</mml:mi> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow> <mml:mo>&lt;</mml:mo> <mml:msub><mml:mi>E</mml:mi> <mml:mtext>best</mml:mtext></mml:msub> <mml:mo>-</mml:mo> <mml:mi>l</mml:mi> <mml:mi>o</mml:mi> <mml:msub><mml:mi>g</mml:mi> <mml:mtext>min</mml:mtext></mml:msub> <mml:mspace width="5.0pt"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(17)</label></disp-formula></p>
<p>As before, the covariance expression should be recomputed only when doing so substantially reduces the size of the ellipsoid boundary. Significant reduction of the ellipsoid bound may be determined by comparing the determinant of the node’s <italic>M</italic><sub>node</sub> to the determinant of its parent’s <italic>M</italic><sub>node</sub>. If the node’s determinant is within some factor of the parent’s determinant, then the node may continue to use the same match covariance as its parent.</p>
</sec>
</sec>
<sec id="sec002c">
<title>IMLP Registration Phase: Aligning Corresponding Point Sets by Generalized Total Least Squares</title>
<p>In this section, we present our approach for computing the rigid-body alignment of two corresponding point sets such that the total match likelihood is maximized as defined by
<disp-formula id="pone.0117688.e079"><alternatives><graphic id="pone.0117688.e079g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e079"/><mml:math id="M79" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>L</mml:mi> <mml:mtext>total</mml:mtext></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>X</mml:mi> <mml:mo>,</mml:mo> <mml:mi>Y</mml:mi> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>X</mml:mtext></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>Y</mml:mtext></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:munder><mml:mo movablelimits="true" form="prefix">max</mml:mo> <mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:munder> <mml:munderover><mml:mo>∏</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>n</mml:mi></mml:munderover> <mml:msub><mml:mtext>L</mml:mtext> <mml:mtext>match</mml:mtext></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>x</mml:mtext> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(18)</label></disp-formula>
where the match-likelihood function for a single match (L<sub>match</sub>) was previously defined in (<xref ref-type="disp-formula" rid="pone.0117688.e015">3</xref>). Maximizing the total match likelihood is equivalent to minimizing the total match error defined as
<disp-formula id="pone.0117688.e080"><alternatives><graphic id="pone.0117688.e080g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e080"/><mml:math id="M80" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>n</mml:mi></mml:munderover> <mml:mo form="prefix">log</mml:mo> <mml:mrow><mml:mo>∣</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>x</mml:mtext> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:msup><mml:mi>R</mml:mi> <mml:mi>T</mml:mi></mml:msup> <mml:mo>+</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo>∣</mml:mo></mml:mrow> <mml:mo>+</mml:mo> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>n</mml:mi></mml:munderover> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow> <mml:mi>T</mml:mi></mml:msup> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>x</mml:mtext> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:msup><mml:mi>R</mml:mi> <mml:mi>T</mml:mi></mml:msup> <mml:mo>+</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow> <mml:mspace width="5.0pt"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(19)</label></disp-formula></p>
<p>Unlike in the correspondence phase, the covariance matrices of the target points {<italic>M</italic><sub>y<italic>i</italic></sub>} are now fixed. Although the value of the log term may still be affected by a change in rotation, the impact of rotation on the square Mahalanobis-distance term is far more pronounced. Thus, we may disregard the log term in this phase, which simplifies the optimization considerably to that of minimizing a sum of square Mahalanobis distances
<disp-formula id="pone.0117688.e081"><alternatives><graphic id="pone.0117688.e081g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e081"/><mml:math id="M81" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mtext>E</mml:mtext> <mml:mtext>GTLS</mml:mtext></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>X</mml:mi> <mml:mo>,</mml:mo> <mml:mi>Y</mml:mi> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>X</mml:mtext></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>Y</mml:mtext></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:munder><mml:mo movablelimits="true" form="prefix">min</mml:mo> <mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:munder> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>n</mml:mi></mml:munderover> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow> <mml:mi>T</mml:mi></mml:msup> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>x</mml:mtext> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:msup><mml:mi>R</mml:mi> <mml:mi>T</mml:mi></mml:msup> <mml:mo>+</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mi>R</mml:mi> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(20)</label></disp-formula>
which has the form of a nonlinear generalized total-least-squares problem. This optimization is the same GTLS problem for registering corresponding point sets as found in prior ICP-based algorithms involving anisotropic noise models [<xref ref-type="bibr" rid="pone.0117688.ref010">10</xref>–<xref ref-type="bibr" rid="pone.0117688.ref012">12</xref>]. As mentioned in the introduction, methods of solution for this type of problem follow an iterative approach.</p>
<p>To derive our approach, we first express the problem in alternate form. It can be shown (<xref ref-type="supplementary-material" rid="pone.0117688.s002">S2 Appendix</xref>) that the unconstrained optimization of (<xref ref-type="disp-formula" rid="pone.0117688.e081">20</xref>) is equivalent to the following constrained optimization
<disp-formula id="pone.0117688.e082"><alternatives><graphic id="pone.0117688.e082g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e082"/><mml:math id="M82" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mtext>E</mml:mtext> <mml:mtext>GTLS</mml:mtext></mml:msub> <mml:mo>(</mml:mo> <mml:mi>X</mml:mi> <mml:mo>,</mml:mo> <mml:mi>Y</mml:mi> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>X</mml:mtext></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>Y</mml:mtext></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mtd> <mml:mtd><mml:mo>=</mml:mo></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:munder><mml:mo movablelimits="true" form="prefix">min</mml:mo> <mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:munder> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>n</mml:mi></mml:munderover> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:msubsup><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi> <mml:mrow><mml:mspace width="0.166667em"/><mml:mo>*</mml:mo></mml:mrow></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow> <mml:mi>T</mml:mi></mml:msup> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>x</mml:mtext> <mml:mi>i</mml:mi></mml:mrow> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msubsup> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:msubsup><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi> <mml:mrow><mml:mspace width="0.166667em"/><mml:mo>*</mml:mo></mml:mrow></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>+</mml:mo> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>n</mml:mi></mml:munderover> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:msubsup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi> <mml:mrow><mml:mspace width="0.166667em"/><mml:mo>*</mml:mo></mml:mrow></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow> <mml:mi>T</mml:mi></mml:msup> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mi>i</mml:mi></mml:mrow> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msubsup> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:msubsup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi> <mml:mrow><mml:mspace width="0.166667em"/><mml:mo>*</mml:mo></mml:mrow></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mtext>subject</mml:mtext> <mml:mspace width="4.pt"/><mml:mtext>to:</mml:mtext> <mml:mspace width="1.em"/><mml:msubsup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi> <mml:mrow><mml:mspace width="0.166667em"/><mml:mo>*</mml:mo></mml:mrow></mml:msubsup> <mml:mo>=</mml:mo> <mml:mi>R</mml:mi> <mml:msubsup><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi> <mml:mrow><mml:mspace width="0.166667em"/><mml:mo>*</mml:mo></mml:mrow></mml:msubsup> <mml:mo>+</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(21)</label></disp-formula>
where <inline-formula id="pone.0117688.e083"><mml:math id="M83" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">{</mml:mo> <mml:msubsup><mml:mover><mml:mi>x</mml:mi> <mml:mo accent="true">⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi> <mml:mrow><mml:mspace width="0.167em"/><mml:mo>*</mml:mo></mml:mrow></mml:msubsup> <mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="pone.0117688.e084"><mml:math id="M84" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">{</mml:mo> <mml:msubsup><mml:mover><mml:mi>y</mml:mi> <mml:mo accent="true">⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi> <mml:mrow><mml:mspace width="0.167em"/><mml:mo>*</mml:mo></mml:mrow></mml:msubsup> <mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula> represent the optimizer’s estimates of the unknown, noise-free positions of the source and target point-pairs, which, due to the correspondence assumption, are constrained to have perfect alignment. Thus, our goal is to solve the transformation parameters, <italic>R</italic> and <inline-formula id="pone.0117688.e085"><mml:math id="M85" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, that minimize (<xref ref-type="disp-formula" rid="pone.0117688.e082">21</xref>) subject to a perfect alignment constraint on the unknown, noise-free point positions. The derivation of our strategy was particularly aided by the works of [<xref ref-type="bibr" rid="pone.0117688.ref038">38</xref>, <xref ref-type="bibr" rid="pone.0117688.ref039">39</xref>] regarding the topic of total-least-squares estimation.</p>
<p>The first step in the derivation is to re-express the constraints of (<xref ref-type="disp-formula" rid="pone.0117688.e082">21</xref>) as
<disp-formula id="pone.0117688.e086"><alternatives><graphic id="pone.0117688.e086g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e086"/><mml:math id="M86" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mtext>F</mml:mtext> <mml:mi>i</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:msubsup><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi> <mml:mrow><mml:mspace width="0.166667em"/><mml:mo>*</mml:mo></mml:mrow></mml:msubsup> <mml:mo>,</mml:mo> <mml:msubsup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi> <mml:mrow><mml:mspace width="0.166667em"/><mml:mo>*</mml:mo></mml:mrow></mml:msubsup> <mml:mo>,</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:msubsup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi> <mml:mrow><mml:mspace width="0.166667em"/><mml:mo>*</mml:mo></mml:mrow></mml:msubsup> <mml:mo>-</mml:mo> <mml:mi>R</mml:mi> <mml:msubsup><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi> <mml:mrow><mml:mspace width="0.166667em"/><mml:mo>*</mml:mo></mml:mrow></mml:msubsup> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(22)</label></disp-formula>
and then to linearize these constraints using a first-order Taylor-series expansion centered at the known values <inline-formula id="pone.0117688.e087"><mml:math id="M87" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow> <mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula id="pone.0117688.e088"><mml:math id="M88" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow> <mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, <italic>R</italic><sub>0</sub>, and <inline-formula id="pone.0117688.e089"><mml:math id="M89" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow> <mml:mi>0</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, where <italic>R</italic><sub>0</sub> and <inline-formula id="pone.0117688.e090"><mml:math id="M90" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow> <mml:mi>0</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are initial estimates of the transformation. Note that we define <italic>R</italic><sub><italic>k</italic></sub> and <inline-formula id="pone.0117688.e091"><mml:math id="M91" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow> <mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> to be the estimates of the transformation parameters that are computed at each iteration <italic>k</italic>. Performing a linearization of the rotation matrix leads to the skew approximation form for an incremental rotation as defined by
<disp-formula id="pone.0117688.e092"><alternatives><graphic id="pone.0117688.e092g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e092"/><mml:math id="M92" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mo>Δ</mml:mo> <mml:mi>R</mml:mi> <mml:mo>≈</mml:mo> <mml:mi>I</mml:mi> <mml:mo>+</mml:mo> <mml:mo form="prefix">skew</mml:mo> <mml:mo>(</mml:mo> <mml:mo>Δ</mml:mo> <mml:mover accent="true"><mml:mi>α</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(23)</label></disp-formula>
<disp-formula id="pone.0117688.e093"><alternatives><graphic id="pone.0117688.e093g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e093"/><mml:math id="M93" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mo form="prefix">skew</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>Δ</mml:mo> <mml:mover accent="true"><mml:mi>α</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mfenced open="[" close="]"><mml:mtable><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd> <mml:mtd><mml:mrow><mml:mo>-</mml:mo> <mml:mo>Δ</mml:mo> <mml:msub><mml:mi>α</mml:mi> <mml:mtext>z</mml:mtext></mml:msub></mml:mrow></mml:mtd> <mml:mtd><mml:mrow><mml:mo>Δ</mml:mo> <mml:msub><mml:mi>α</mml:mi> <mml:mtext>y</mml:mtext></mml:msub></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mrow><mml:mo>Δ</mml:mo> <mml:msub><mml:mi>α</mml:mi> <mml:mtext>z</mml:mtext></mml:msub></mml:mrow></mml:mtd> <mml:mtd><mml:mn>0</mml:mn></mml:mtd> <mml:mtd><mml:mrow><mml:mo>-</mml:mo> <mml:mo>Δ</mml:mo> <mml:msub><mml:mi>α</mml:mi> <mml:mtext>x</mml:mtext></mml:msub></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mrow><mml:mo>-</mml:mo> <mml:mo>Δ</mml:mo> <mml:msub><mml:mi>α</mml:mi> <mml:mtext>y</mml:mtext></mml:msub></mml:mrow></mml:mtd> <mml:mtd><mml:mrow><mml:mo>Δ</mml:mo> <mml:msub><mml:mi>α</mml:mi> <mml:mtext>x</mml:mtext></mml:msub></mml:mrow></mml:mtd> <mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mfenced> <mml:mspace width="5.0pt"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(24)</label></disp-formula></p>
<p>This parameterization enables representing small-angle rotations as a 3D vector, <inline-formula id="pone.0117688.e094"><mml:math id="M94" display="inline" overflow="scroll"><mml:mrow><mml:mi>Δ</mml:mi> <mml:mover accent="true"><mml:mi>α</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mspace width="1pt"/><mml:mo>=</mml:mo> <mml:mspace width="1pt"/><mml:msup><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:mi>Δ</mml:mi> <mml:msub><mml:mi>α</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:mi>Δ</mml:mi> <mml:msub><mml:mi>α</mml:mi> <mml:mtext>y</mml:mtext></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:mi>Δ</mml:mi> <mml:msub><mml:mi>α</mml:mi> <mml:mtext>z</mml:mtext></mml:msub> <mml:mo stretchy="false">]</mml:mo></mml:mrow> <mml:mi>T</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>. We also note that using Lie algebra and exponential maps to parameterization the rotation, rather than the skew-approximation form described here, may also be a very effective approach for solving this problem. Note that skew<inline-formula id="pone.0117688.e095"><mml:math id="M95" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">)</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> is simply matrix notation for the cross product <inline-formula id="pone.0117688.e096"><mml:math id="M96" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo> <mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mspace width="1pt"/><mml:mo>×</mml:mo> <mml:mspace width="1pt"/><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>; thus, the positions of <inline-formula id="pone.0117688.e097"><mml:math id="M97" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and <inline-formula id="pone.0117688.e098"><mml:math id="M98" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> may be interchanged by negation, which is implicitly used in forming the Taylor-series expansion of the constraint equations below. Using <inline-formula id="pone.0117688.e099"><mml:math id="M99" display="inline" overflow="scroll"><mml:mrow><mml:mi>Δ</mml:mi> <mml:mover accent="true"><mml:mi>α</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> to represent change in rotation and defining <inline-formula id="pone.0117688.e100"><mml:math id="M100" display="inline" overflow="scroll"><mml:mrow><mml:mi>Δ</mml:mi> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> to be change in translation, with some algebraic manipulation the constraints of (<xref ref-type="disp-formula" rid="pone.0117688.e086">22</xref>) may be linearized to the approximate form
<disp-formula id="pone.0117688.e101"><alternatives><graphic id="pone.0117688.e101g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e101"/><mml:math id="M101" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msubsup><mml:mtext>F</mml:mtext> <mml:mrow><mml:mtext>L</mml:mtext> <mml:mi>i</mml:mi></mml:mrow> <mml:mi>k</mml:mi></mml:msubsup> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:mo>Δ</mml:mo> <mml:mover accent="true"><mml:mi>α</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:mo>Δ</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:msubsup><mml:mtext>F</mml:mtext> <mml:mi>i</mml:mi> <mml:mtext>0</mml:mtext></mml:msubsup> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>R</mml:mi> <mml:mi>k</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>k</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>-</mml:mo> <mml:msub><mml:mi>r</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>R</mml:mi> <mml:mi>k</mml:mi></mml:msub> <mml:msub><mml:mi>r</mml:mi> <mml:mrow><mml:mtext>x</mml:mtext> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo>+</mml:mo> <mml:mo form="prefix">skew</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>R</mml:mi> <mml:mi>k</mml:mi></mml:msub> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>Δ</mml:mo> <mml:mover accent="true"><mml:mi>α</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mo>Δ</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(25)</label></disp-formula>
which is linear with respect to change in rotation <inline-formula id="pone.0117688.e102"><mml:math id="M102" display="inline" overflow="scroll"><mml:mrow><mml:mi>Δ</mml:mi> <mml:mover accent="true"><mml:mi>α</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and change in translation <inline-formula id="pone.0117688.e103"><mml:math id="M103" display="inline" overflow="scroll"><mml:mrow><mml:mi>Δ</mml:mi> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. Here we define <inline-formula id="pone.0117688.e104"><mml:math id="M104" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mtext mathvariant="normal">F</mml:mtext> <mml:mi>i</mml:mi> <mml:mn>0</mml:mn></mml:msubsup> <mml:mo stretchy="false">(</mml:mo> <mml:msub><mml:mover><mml:mi>x</mml:mi> <mml:mo accent="true">⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mover><mml:mi>y</mml:mi> <mml:mo accent="true">⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>R</mml:mi> <mml:mi>k</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mover><mml:mi>t</mml:mi> <mml:mo accent="true">⃗</mml:mo></mml:mover> <mml:mi>k</mml:mi></mml:msub> <mml:mo stretchy="false">)</mml:mo> <mml:mo>=</mml:mo> <mml:msub><mml:mover><mml:mi>y</mml:mi> <mml:mo accent="true">⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>−</mml:mo> <mml:msub><mml:mi>R</mml:mi> <mml:mi>k</mml:mi></mml:msub> <mml:msub><mml:mover><mml:mi>x</mml:mi> <mml:mo accent="true">⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>−</mml:mo> <mml:msub><mml:mover><mml:mi>t</mml:mi> <mml:mo accent="true">⃗</mml:mo></mml:mover> <mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula id="pone.0117688.e105"><mml:math id="M105" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>r</mml:mi> <mml:mrow><mml:mtext mathvariant="normal">y</mml:mtext> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo>=</mml:mo> <mml:msub><mml:mover><mml:mi>y</mml:mi> <mml:mo accent="true">⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>−</mml:mo> <mml:msubsup><mml:mover><mml:mi>y</mml:mi> <mml:mo accent="true">⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi> <mml:mrow><mml:mspace width="0.167em"/><mml:mo>*</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>, <inline-formula id="pone.0117688.e106"><mml:math id="M106" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>r</mml:mi> <mml:mrow><mml:mtext mathvariant="normal">x</mml:mtext> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo>=</mml:mo> <mml:msub><mml:mover><mml:mi>x</mml:mi> <mml:mo accent="true">⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>−</mml:mo> <mml:msubsup><mml:mover><mml:mi>x</mml:mi> <mml:mo accent="true">⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi> <mml:mrow><mml:mspace width="0.167em"/><mml:mo>*</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>, <inline-formula id="pone.0117688.e107"><mml:math id="M107" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>R</mml:mi> <mml:mrow><mml:mi>k</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>=</mml:mo> <mml:mspace width="1pt"/><mml:mo stretchy="false">(</mml:mo> <mml:mi>Δ</mml:mi> <mml:mi>R</mml:mi> <mml:mo stretchy="false">)</mml:mo> <mml:msub><mml:mi>R</mml:mi> <mml:mi>k</mml:mi></mml:msub> <mml:mspace width="1pt"/><mml:mo>≈</mml:mo> <mml:mspace width="1pt"/><mml:mo stretchy="false">(</mml:mo> <mml:mi>I</mml:mi> <mml:mspace width="1pt"/><mml:mo>+</mml:mo> <mml:mspace width="1pt"/><mml:mtext>skew(</mml:mtext> <mml:mi>Δ</mml:mi> <mml:mover accent="true"><mml:mi>α</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">)</mml:mo> <mml:mo stretchy="false">)</mml:mo> <mml:msub><mml:mi>R</mml:mi> <mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, and <inline-formula id="pone.0117688.e108"><mml:math id="M108" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow> <mml:mrow><mml:mi>k</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mspace width="1pt"/><mml:mo>=</mml:mo> <mml:mspace width="1pt"/><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow> <mml:mi>k</mml:mi></mml:msub> <mml:mspace width="1pt"/><mml:mo>+</mml:mo> <mml:mspace width="1pt"/><mml:mi>Δ</mml:mi> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, where <italic>k</italic> denotes an iteration of the optimization procedure.</p>
<p>The next step in the derivation is to apply the method of Lagrange multipliers to enforce the linearized constraints while minimizing the cost function. The Lagrange function becomes
<disp-formula id="pone.0117688.e109"><alternatives><graphic id="pone.0117688.e109g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e109"/><mml:math id="M109" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>𝓛</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>Δ</mml:mo> <mml:mover accent="true"><mml:mi>α</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:mo>Δ</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:mi>λ</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>n</mml:mi></mml:munderover> <mml:msubsup><mml:mi>r</mml:mi> <mml:mrow><mml:mtext>x</mml:mtext> <mml:mi>i</mml:mi></mml:mrow> <mml:mi>T</mml:mi></mml:msubsup> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>x</mml:mtext> <mml:mi>i</mml:mi></mml:mrow> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msubsup> <mml:msub><mml:mi>r</mml:mi> <mml:mrow><mml:mtext>x</mml:mtext> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo>+</mml:mo> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>n</mml:mi></mml:munderover> <mml:msubsup><mml:mi>r</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mi>i</mml:mi></mml:mrow> <mml:mi>T</mml:mi></mml:msubsup> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mi>i</mml:mi></mml:mrow> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msubsup> <mml:msub><mml:mi>r</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo>+</mml:mo> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>n</mml:mi></mml:munderover> <mml:msubsup><mml:mi>λ</mml:mi> <mml:mi>i</mml:mi> <mml:mi>T</mml:mi></mml:msubsup> <mml:msubsup><mml:mtext>F</mml:mtext> <mml:mrow><mml:mtext>L</mml:mtext> <mml:mi>i</mml:mi></mml:mrow> <mml:mi>k</mml:mi></mml:msubsup> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:mo>Δ</mml:mo> <mml:mover accent="true"><mml:mi>α</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:mo>Δ</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(26)</label></disp-formula>
where <italic>λ</italic> = {<italic>λ</italic><sub><italic>i</italic></sub>} represents the set of Lagrange multipliers with each <italic>λ</italic><sub><italic>i</italic></sub> being a 3-vector. Next is solving for the zero derivatives of the Lagrange function with respect to the residuals {<italic>r</italic><sub>x<italic>i</italic></sub>} and {<italic>r</italic><sub>y<italic>i</italic></sub>}, the change in transformation parameters <inline-formula id="pone.0117688.e110"><mml:math id="M110" display="inline" overflow="scroll"><mml:mrow><mml:mi>Δ</mml:mi> <mml:mover accent="true"><mml:mi>α</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and <inline-formula id="pone.0117688.e111"><mml:math id="M111" display="inline" overflow="scroll"><mml:mrow><mml:mi>Δ</mml:mi> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, and the Lagrange multipliers. After making substitutions between these differential equations, we finally obtain (<xref ref-type="disp-formula" rid="pone.0117688.e113">27</xref>) for computing an incremental update of the transformation parameters <inline-formula id="pone.0117688.e112"><mml:math id="M112" display="inline" overflow="scroll"><mml:mrow><mml:mi>Δ</mml:mi> <mml:mi>p</mml:mi> <mml:mspace width="1pt"/><mml:mo>=</mml:mo> <mml:mspace width="1pt"/><mml:msup><mml:mrow><mml:mo stretchy="false">[</mml:mo> <mml:mi>Δ</mml:mi> <mml:mover accent="true"><mml:mi>α</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:mspace width="1pt"/><mml:mi>Δ</mml:mi> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">]</mml:mo></mml:mrow> <mml:mi>T</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>.
<disp-formula id="pone.0117688.e113"><alternatives><graphic id="pone.0117688.e113g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e113"/><mml:math id="M113" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="center"><mml:mrow><mml:msup><mml:mi>J</mml:mi> <mml:mi>T</mml:mi></mml:msup> <mml:msup><mml:mi>M</mml:mi> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:mi>J</mml:mi> <mml:mo>Δ</mml:mo> <mml:mi>p</mml:mi> <mml:mo>=</mml:mo> <mml:mo>-</mml:mo> <mml:msup><mml:mi>J</mml:mi> <mml:mi>T</mml:mi></mml:msup> <mml:msup><mml:mi>M</mml:mi> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:msup><mml:mi>F</mml:mi> <mml:mn>0</mml:mn></mml:msup></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mo>Δ</mml:mo> <mml:mi>p</mml:mi> <mml:mo>=</mml:mo> <mml:mfenced open="[" close="]"><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mo>Δ</mml:mo> <mml:mover accent="true"><mml:mi>α</mml:mi> <mml:mo>⃗</mml:mo></mml:mover></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mrow><mml:mo>Δ</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mfenced> <mml:mspace width="1.em"/><mml:msup><mml:mi>F</mml:mi> <mml:mn>0</mml:mn></mml:msup> <mml:mo>=</mml:mo> <mml:mfenced open="[" close="]"><mml:mtable><mml:mtr><mml:mtd><mml:msubsup><mml:mi>F</mml:mi> <mml:mn>1</mml:mn> <mml:mn>0</mml:mn></mml:msubsup></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mo>⋮</mml:mo></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:msubsup><mml:mi>F</mml:mi> <mml:mi>n</mml:mi> <mml:mn>0</mml:mn></mml:msubsup></mml:mtd></mml:mtr></mml:mtable></mml:mfenced> <mml:mspace width="1.em"/><mml:mi>J</mml:mi> <mml:mo>=</mml:mo> <mml:mfenced open="[" close="]"><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mo form="prefix">skew</mml:mo> <mml:mo>(</mml:mo> <mml:msub><mml:mi>R</mml:mi> <mml:mi>k</mml:mi></mml:msub> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mtd> <mml:mtd><mml:mrow><mml:mo>-</mml:mo> <mml:mi>I</mml:mi></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mo>⋮</mml:mo></mml:mtd> <mml:mtd><mml:mo>⋮</mml:mo></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mrow><mml:mo form="prefix">skew</mml:mo> <mml:mo>(</mml:mo> <mml:msub><mml:mi>R</mml:mi> <mml:mi>k</mml:mi></mml:msub> <mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>n</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mtd> <mml:mtd><mml:mrow><mml:mo>-</mml:mo> <mml:mi>I</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mfenced> <mml:mspace width="1.em"/><mml:mi>M</mml:mi> <mml:mo>=</mml:mo> <mml:mfenced open="[" close="]"><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msubsup><mml:mi>F</mml:mi> <mml:mtext>x</mml:mtext> <mml:mn>0</mml:mn></mml:msubsup> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:msup><mml:mrow><mml:msubsup><mml:mi>F</mml:mi> <mml:mtext>x</mml:mtext> <mml:mn>0</mml:mn></mml:msubsup></mml:mrow> <mml:mi>T</mml:mi></mml:msup> <mml:mo>+</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mtext>y</mml:mtext></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mfenced></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msubsup><mml:mi>F</mml:mi> <mml:mtext>x</mml:mtext> <mml:mn>0</mml:mn></mml:msubsup> <mml:mo>=</mml:mo> <mml:mfenced open="[" close="]"><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mo>-</mml:mo> <mml:msub><mml:mi>R</mml:mi> <mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:mtd> <mml:mtd/><mml:mtd/></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd><mml:mo>⋱</mml:mo></mml:mtd> <mml:mtd/></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd/><mml:mtd><mml:mrow><mml:mo>-</mml:mo> <mml:msub><mml:mi>R</mml:mi> <mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mfenced> <mml:mspace width="1.em"/><mml:msub><mml:mi>M</mml:mi> <mml:mtext>x</mml:mtext></mml:msub> <mml:mo>=</mml:mo> <mml:mfenced open="[" close="]"><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>x</mml:mtext> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd> <mml:mtd/><mml:mtd/></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd><mml:mo>⋱</mml:mo></mml:mtd> <mml:mtd/></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd/><mml:mtd><mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>x</mml:mtext> <mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mfenced> <mml:mspace width="1.em"/><mml:msub><mml:mi>M</mml:mi> <mml:mtext>y</mml:mtext></mml:msub> <mml:mo>=</mml:mo> <mml:mfenced open="[" close="]"><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd> <mml:mtd/><mml:mtd/></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd><mml:mo>⋱</mml:mo></mml:mtd> <mml:mtd/></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd/><mml:mtd><mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mtext>y</mml:mtext> <mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mfenced></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(27)</label></disp-formula></p>
<p>Here <italic>F</italic><sup>0</sup> is defined as a stacked vector of match residuals, <italic>J</italic> is the Jacobian matrix of the constraints relative to the transformation parameters, and <italic>M</italic> is the complete covariance matrix for all matches. Since the match errors are assumed to be independent between matches, <italic>M</italic> has a 3 x 3 symmetric, positive-definite, block-diagonal structure for points in 3D. Simplifying this solution for registrations in 2D is trivial.</p>
<p>The resulting expression in (<xref ref-type="disp-formula" rid="pone.0117688.e113">27</xref>) is a linear system of six equations having the recognizable form <italic>Ax</italic> = <italic>b</italic>, where <italic>A</italic> is 6 x 6 symmetric. This expression is further recognized to have the form of an update equation from the nonlinear Gauss-Newton method of nonlinear optimization. The solution to (<xref ref-type="disp-formula" rid="pone.0117688.e082">21</xref>) is computed by iteratively solving (<xref ref-type="disp-formula" rid="pone.0117688.e113">27</xref>) using standard least squares, with each solution providing an incremental update (Δ<italic>p</italic>) for the current transformation parameter estimates <italic>R</italic><sub><italic>k</italic></sub> and <inline-formula id="pone.0117688.e114"><mml:math id="M114" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow> <mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, which are updated as
<disp-formula id="pone.0117688.e115"><alternatives><graphic id="pone.0117688.e115g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e115"/><mml:math id="M115" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>R</mml:mi> <mml:mrow><mml:mi>k</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>=</mml:mo> <mml:mo form="prefix">R</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>Δ</mml:mo> <mml:mover accent="true"><mml:mi>α</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow> <mml:msub><mml:mi>R</mml:mi> <mml:mi>k</mml:mi></mml:msub> <mml:mspace width="0.166667em"/><mml:mo>,</mml:mo> <mml:mspace width="1.em"/><mml:msub><mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mrow><mml:mi>k</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>=</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover> <mml:mi>k</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:mo>Δ</mml:mo> <mml:mover accent="true"><mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo></mml:mover></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(28)</label></disp-formula>
where <inline-formula id="pone.0117688.e116"><mml:math id="M116" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi> <mml:mo stretchy="false">(</mml:mo> <mml:mi>Δ</mml:mi> <mml:mover accent="true"><mml:mi>α</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is as defined in the following paragraph. The linear system of (<xref ref-type="disp-formula" rid="pone.0117688.e113">27</xref>) is re-solved following each update until the transformation estimates converge. This approach is nearly equivalent to the standard Gauss-Newton method, with a modification being that the covariance matrices are updated at each iteration.</p>
<p>In (<xref ref-type="disp-formula" rid="pone.0117688.e115">28</xref>) we define <inline-formula id="pone.0117688.e117"><mml:math id="M117" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi> <mml:mo stretchy="false">(</mml:mo> <mml:mi>Δ</mml:mi> <mml:mover accent="true"><mml:mi>α</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to be a rotation matrix computed using the Rodrigues rotation formula [<xref ref-type="bibr" rid="pone.0117688.ref034">34</xref>] about an axis oriented along <inline-formula id="pone.0117688.e118"><mml:math id="M118" display="inline" overflow="scroll"><mml:mrow><mml:mi>Δ</mml:mi> <mml:mover accent="true"><mml:mi>α</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and having a rotation angle of <inline-formula id="pone.0117688.e119"><mml:math id="M119" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo> <mml:mo>|</mml:mo> <mml:mi>Δ</mml:mi> <mml:mover accent="true"><mml:mi>α</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo>|</mml:mo> <mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> radians. Using the Rodrigues form <inline-formula id="pone.0117688.e120"><mml:math id="M120" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi> <mml:mo stretchy="false">(</mml:mo> <mml:mi>Δ</mml:mi> <mml:mover accent="true"><mml:mi>α</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> rather than the skew approximation form <inline-formula id="pone.0117688.e121"><mml:math id="M121" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo> <mml:mi>I</mml:mi> <mml:mspace width="1pt"/><mml:mo>+</mml:mo> <mml:mspace width="1pt"/><mml:mtext>skew(</mml:mtext> <mml:mi>Δ</mml:mi> <mml:mover accent="true"><mml:mi>α</mml:mi> <mml:mo stretchy="true">→</mml:mo></mml:mover> <mml:mo stretchy="false">)</mml:mo> <mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> ensures that <italic>R</italic><sub><italic>k</italic>+1</sub> always satisfies the conditions for being a valid rotation matrix.</p>
<p>Since the linear system of (<xref ref-type="disp-formula" rid="pone.0117688.e113">27</xref>) is symmetric, an efficient and stable approach for solving the least-squares iterates is to use Cholesky or <italic>LDL</italic><sup><italic>T</italic></sup> decomposition. In our implementation we employ the more general SVD decomposition, since the symmetric decompositions were not supported by the numerical libraries used in our implementation. Because the linear system is small, SVD also provides reasonable efficiency. Note that, in the interest of efficiency, it is important to take advantage of the sparse structure of <italic>M</italic> when computing the matrix operations required to form this linear system.</p>
<p>We define the termination condition to be when the magnitude of incremental change in the transformation parameters fall below threshold values. In our implementation, we use convergence thresholds of 0.001 mm translation and 0.001 degrees rotation, but this may be defined by the user.</p>
<p>A summary of the approach described above for solving the GTLS problem of aligning two corresponding point sets is provided below as Algorithm 5.</p>
<p><bold>Algorithm 5.</bold> GTLS Registration of Corresponding Point Sets</p>
<p specific-use="line"> <bold>input</bold>: Corresponding source and target point sets: <inline-formula id="pone.0117688.e122"><mml:math id="M122" display="inline" overflow="scroll"><mml:mrow> <mml:mi>X</mml:mi> <mml:mo>=</mml:mo> <mml:mo>{</mml:mo> <mml:msub> <mml:mover accent="true"> <mml:mi>x</mml:mi> <mml:mo>⃗</mml:mo> </mml:mover> <mml:mi>i</mml:mi> </mml:msub> <mml:mo>}</mml:mo> <mml:mo>,</mml:mo> <mml:mi>Y</mml:mi> <mml:mo>=</mml:mo> <mml:mo>{</mml:mo> <mml:msub> <mml:mover accent="true"> <mml:mi>y</mml:mi> <mml:mo>⃗</mml:mo> </mml:mover> <mml:mi>i</mml:mi> </mml:msub> <mml:mo>}</mml:mo> </mml:mrow> </mml:math> </inline-formula></p>
<p specific-use="line">    Noise-model covariances for the source and target points:</p>
<p specific-use="line">      <italic>M</italic><sub>x</sub> = {<italic>M</italic><sub>x<italic>i</italic></sub>, <italic>M</italic><sub>Y</sub> = {<italic>M</italic><sub>y<italic>i</italic></sub>}</p>
<p specific-use="line">    Initial transformation estimate: <inline-formula id="pone.0117688.e123"><mml:math id="M123" display="inline" overflow="scroll"><mml:mrow> <mml:mo stretchy="false">[</mml:mo> <mml:msub> <mml:mi>R</mml:mi> <mml:mi>0</mml:mi> </mml:msub> <mml:mo>,</mml:mo> <mml:msub> <mml:mover accent="true"> <mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo> </mml:mover> <mml:mi>0</mml:mi> </mml:msub> <mml:mo stretchy="false">]</mml:mo> </mml:mrow> </mml:math> </inline-formula></p>
<p specific-use="line"> <bold>output</bold>: Final transformation that aligns the corresponding point sets: <inline-formula id="pone.0117688.e124"><mml:math id="M124" display="inline" overflow="scroll"><mml:mrow> <mml:mo stretchy="false">[</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"> <mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo> </mml:mover> <mml:mo stretchy="false">]</mml:mo> </mml:mrow> </mml:math> </inline-formula></p>
<p specific-use="line"><bold>1</bold> Initialize the transformation: <inline-formula id="pone.0117688.e125"><mml:math id="M125" display="inline" overflow="scroll"><mml:mrow> <mml:mo stretchy="false">[</mml:mo> <mml:msub> <mml:mi>R</mml:mi> <mml:mi>k</mml:mi> </mml:msub> <mml:mo>,</mml:mo> <mml:msub> <mml:mover accent="true"> <mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo> </mml:mover> <mml:mi>k</mml:mi> </mml:msub> <mml:mo stretchy="false">]</mml:mo> <mml:mo>←</mml:mo> <mml:mo stretchy="false">[</mml:mo> <mml:msub> <mml:mi>R</mml:mi> <mml:mn>0</mml:mn> </mml:msub> <mml:mo>,</mml:mo> <mml:msub> <mml:mover accent="true"> <mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo> </mml:mover> <mml:mn>0</mml:mn> </mml:msub> <mml:mo stretchy="false">]</mml:mo> </mml:mrow> </mml:math> </inline-formula></p>
<p specific-use="line"><bold>2</bold> Compute <italic>F</italic><sup>0</sup> using <italic>X, Y, R</italic><sub><italic>k</italic></sub>, and <inline-formula id="pone.0117688.e126"><mml:math id="M126" display="inline" overflow="scroll"><mml:mrow> <mml:msub> <mml:mover accent="true"> <mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo> </mml:mover> <mml:mi>k</mml:mi> </mml:msub> </mml:mrow> </mml:math> </inline-formula></p>
<p specific-use="line"><bold>3</bold> Compute <italic>J</italic> using <italic>R</italic><sub><italic>k</italic></sub> and <italic>X</italic></p>
<p specific-use="line"><bold>4</bold> Solve incremental transformation <inline-formula id="pone.0117688.e127"><mml:math id="M127" display="inline" overflow="scroll"><mml:mrow> <mml:mo>Δ</mml:mo> <mml:mi>p</mml:mi> <mml:mo>=</mml:mo> <mml:mrow> <mml:msup> <mml:mrow> <mml:mo stretchy="false">[</mml:mo> <mml:mo>Δ</mml:mo> <mml:mover accent="true"> <mml:mi>α</mml:mi> <mml:mo>⃗</mml:mo> </mml:mover> <mml:mo>,</mml:mo> <mml:mo>Δ</mml:mo> <mml:mover accent="true"> <mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo> </mml:mover> <mml:mo stretchy="false">]</mml:mo> </mml:mrow> <mml:mi>T</mml:mi> </mml:msup> </mml:mrow> </mml:mrow> </mml:math> </inline-formula> by standard least squares (<xref ref-type="disp-formula" rid="pone.0117688.e113">27</xref>)</p>
<p specific-use="line"><bold>5</bold> Update the transformation parameters: <inline-formula id="pone.0117688.e128"><mml:math id="M128" display="inline" overflow="scroll"><mml:mrow> <mml:mo stretchy="false">[</mml:mo> <mml:msub> <mml:mi>R</mml:mi> <mml:mi>k</mml:mi> </mml:msub> <mml:mo>,</mml:mo> <mml:msub> <mml:mover accent="true"> <mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo> </mml:mover> <mml:mi>k</mml:mi> </mml:msub> <mml:mo stretchy="false">]</mml:mo> <mml:mo>←</mml:mo> <mml:mo stretchy="false">[</mml:mo> <mml:mtext>R</mml:mtext> <mml:mo>(</mml:mo> <mml:mo>Δ</mml:mo> <mml:mover accent="true"> <mml:mi>α</mml:mi> <mml:mo>⃗</mml:mo> </mml:mover> <mml:mo>)</mml:mo> <mml:msub> <mml:mi>R</mml:mi> <mml:mi>k</mml:mi> </mml:msub> <mml:mo>,</mml:mo> <mml:msub> <mml:mover accent="true"> <mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo> </mml:mover> <mml:mi>k</mml:mi> </mml:msub> <mml:mo>+</mml:mo> <mml:mo>Δ</mml:mo> <mml:mover accent="true"> <mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo> </mml:mover> <mml:mo stretchy="false">]</mml:mo> </mml:mrow> </mml:math> </inline-formula></p>
<p specific-use="line"><bold>6</bold> <bold>if</bold> <inline-formula id="pone.0117688.e129"><mml:math id="M129" display="inline" overflow="scroll"><mml:mrow> <mml:mo>‖</mml:mo> <mml:mo>Δ</mml:mo> <mml:mover accent="true"> <mml:mi>α</mml:mi> <mml:mo>⃗</mml:mo> </mml:mover> <mml:mo>‖</mml:mo> <mml:mo>≤</mml:mo> <mml:mo>Δ</mml:mo> <mml:msub> <mml:mi>α</mml:mi> <mml:mtext>threshold</mml:mtext> </mml:msub> <mml:mi mathvariant="italic">and</mml:mi> <mml:mo>‖</mml:mo> <mml:mo>Δ</mml:mo> <mml:mover accent="true"> <mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo> </mml:mover> <mml:mo>‖</mml:mo> <mml:mo>≤</mml:mo> <mml:mo>Δ</mml:mo> <mml:msub> <mml:mi>t</mml:mi> <mml:mrow> <mml:mi>t</mml:mi> <mml:mi>h</mml:mi> <mml:mi>r</mml:mi> <mml:mi>e</mml:mi> <mml:mi>s</mml:mi> <mml:mi>h</mml:mi> <mml:mi>o</mml:mi> <mml:mi>l</mml:mi> <mml:mi>d</mml:mi> </mml:mrow> </mml:msub> </mml:mrow> </mml:math> </inline-formula> <bold>then</bold></p>
<p specific-use="line"><bold>7</bold>  Goto Step 2</p>
<p specific-use="line"><bold>8 end</bold></p>
<p specific-use="line"><bold>9</bold> Return the final transformation: <inline-formula id="pone.0117688.e130"><mml:math id="M130" display="inline" overflow="scroll"><mml:mrow> <mml:mo stretchy="false">[</mml:mo> <mml:mi>R</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"> <mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo> </mml:mover> <mml:mo stretchy="false">]</mml:mo> <mml:mo>←</mml:mo> <mml:mo stretchy="false">[</mml:mo> <mml:msub> <mml:mi>R</mml:mi> <mml:mi>k</mml:mi> </mml:msub> <mml:mo>,</mml:mo> <mml:msub> <mml:mover accent="true"> <mml:mi>t</mml:mi> <mml:mo>⃗</mml:mo> </mml:mover> <mml:mi>k</mml:mi> </mml:msub> <mml:mo stretchy="false">]</mml:mo> </mml:mrow> </mml:math></inline-formula></p>
</sec>
</sec>
<sec id="sec003" sec-type="conclusions">
<title>Results and Discussion</title>
<p>In this section, we present our experimental results. We compare the IMLP algorithm to several competing methods under a wide range of test conditions including various isotropic and anisotropic noise levels, with and without outliers, and using different (i.e. mesh and point cloud) representations of various target shapes. Other methods evaluated for comparison with IMLP include standard ICP [<xref ref-type="bibr" rid="pone.0117688.ref001">1</xref>], a robust variant of ICP [<xref ref-type="bibr" rid="pone.0117688.ref004">4</xref>] (which we refer to as “Robust ICP”), GICP [<xref ref-type="bibr" rid="pone.0117688.ref011">11</xref>], and CPD [<xref ref-type="bibr" rid="pone.0117688.ref020">20</xref>]. For the non-outlier cases, near comparison is also made with GTLS-ICP [<xref ref-type="bibr" rid="pone.0117688.ref010">10</xref>] and A-ICP [<xref ref-type="bibr" rid="pone.0117688.ref012">12</xref>] using variants of our own method, IMLP-CP and IMLP-MD, respectively.</p>
<p>The two variants on IMLP directly compare the most-likely match criterion of IMLP with the closest-point (CP) match criterion used by GTLS-ICP and the Mahalanobis-distance (MD) match criterion used by A-ICP. Since only the matching phase of IMLP-CP and IMLP-MD has been modified with respect to IMLP, this comparison directly evaluates the merit of the three criterion for computing matches: closest-point matching (GTLS-ICP, IMLP-CP), Mahalanobis-distance matching (A-ICP, IMLP-MD), and most-likely-point matching (IMLP).</p>
<p>GICP and CPD appear in the experiments involving a point-cloud target shape and not in the experiments involving a mesh target shape. This is because CPD is limited by design to point-cloud-to-point-cloud registration, and GICP as well is most suited to the context of registering non-continuous representations of two surfaces (i.e. point clouds).</p>
<p>For the GICP and CPD algorithms, we have used the implementations made publicly available by their respective authors. For the remaining algorithms (standard ICP, Robust ICP, IMLP, IMLP-CP, IMLP-MD) our own implementations have been used. Minor changes were made to the source code of GICP and CPD in order to use the same termination criterion across all compared methods and, in the case of GICP, to orient the surface-model covariances directly along the known surface normal at each point rather than estimating the surface normals from neighboring points in the point-cloud. These various implementations are based on single-threaded programming in C++. Thus, all methods were evaluated on level ground in terms of the efficiency of the runtime environment, with an exception being that the CPD algorithm ran multi-threaded under certain settings (discussed later in the results). As a further minor caveat, the CPD implementation uses Matlab as a front-end while incorporating a C-compiled mex library for the heavy-lifting.</p>
<p>All registration methods were configured to terminate when the magnitude of change in the transformation parameters remain below threshold levels for two consecutive iterations or when a maximum iteration count is reached. The transformation thresholds were set to 0.001 mm translation and 0.001 degrees rotation with a maximum iteration count of 100 iterations (except where noted in the results). An advantage of using transformation thresholds as the basis for termination is that the need to normalize across the various cost functions employed by each algorithm is completely averted.</p>
<p>The algorithms that we have programmed (standard ICP, Robust ICP, IMLP, IMLP-CP, IMLP-MD) use the CISST [<xref ref-type="bibr" rid="pone.0117688.ref040">40</xref>] and WildMagic5 [<xref ref-type="bibr" rid="pone.0117688.ref041">41</xref>] C++ libraries for numerical linear algebra and standard least-squares computations. WildMagic5 is used for its efficient, non-iterative method of computing the eigen decomposition of a 3 x 3, symmetric, positive-definite matrix.</p>
<p>Before presenting a comparison of the algorithms described above, we begin the results section by evaluating our approach to solving the GTLS problem of registering two corresponding point sets. The proposed Gauss-Newton-based approach is compared to the prior methods of Estepar et al. [<xref ref-type="bibr" rid="pone.0117688.ref010">10</xref>] and Balachandran and Fitzpatrick [<xref ref-type="bibr" rid="pone.0117688.ref031">31</xref>], which have also been proposed to solve this specific problem. However, one limitation of the method as described by Balachandran and Fitzpatrick is that anisotropic noise is limited to the local coordinates of only one point set. All three methods share a commonality of being easy to program using a basic linear algebra library supporting a standard least-squares solver.</p>
<sec id="sec003a">
<title>Experiment 1: Generalized Total-Least-Squares Methods for Registering Corresponding Point Sets</title>
<p>In this study, we evaluate the proposed Gauss-Newton-based approach for computing the optimal rigid-body alignment that registers two corresponding point sets under anisotropic measurement error, which was described in the IMLP Registration Phase subsection of the Methods section. As previously stated, this problem forms a GTLS optimization problem that must be solved in the registration phases of the IMLP algorithm and of closely related prior works. We evaluate the proposed GTLS method on the basis of efficiency, accuracy, and stability relative to the prior methods proposed for solving this problem by Estepar et al. [<xref ref-type="bibr" rid="pone.0117688.ref010">10</xref>] and Balachandran and Fitzpatrick [<xref ref-type="bibr" rid="pone.0117688.ref031">31</xref>]. These results are also compared to the closed-form, least-squares solution for the isotropic noise case [<xref ref-type="bibr" rid="pone.0117688.ref026">26</xref>], which constitutes the registration phase of the standard ICP algorithm.</p>
<p>Each method was evaluated using a Matlab-based implementation. For the method of Balachandran and Fitzpatrick, we use the Matlab source code included in their paper [<xref ref-type="bibr" rid="pone.0117688.ref031">31</xref>]. For the other methods we have created our own Matlab implementations, including an implementation of the rotation estimation method of Ohta and Kanatani [<xref ref-type="bibr" rid="pone.0117688.ref028">28</xref>], which is a sub-component of the method by Estepar et al.</p>
<p>A high degree of instability was initially encountered when using the method of Estepar et al. with large translational offsets. We found that a small modification sufficed to fix the issue, which involved applying their translation estimate prior to the first estimate for rotation. This modification was used throughout our study.</p>
<p>As previously noted, one limitation of the method by Balachandran and Fitzpatrick is that this method employs a single noise covariance that remains fixed as the algorithm iterates, due to the assumption of anisotropic noise in only one point set. Although noise in both point sets may be initially considered by combining the noise models to form a single covariance prior to calling their method (as in the covariance expressions of (<xref ref-type="disp-formula" rid="pone.0117688.e045">9</xref>) for example), in this case the accuracy of the method still diminishes relative to the magnitude of rotational misalignment because the effective noise covariance is not updated as the method iterates.</p>
<p>Because of this limitation, we conduct a two-part study. The first study (Experiment 1A) investigates anisotropic noise present in both the source and target point sets. The second study (Experiment 1B) investigates anisotropic noise present in only the target point set with isotropic noise present in the source point set. For the second study, the assumption of a fixed effective covariance becomes correct, since a change in the orientation of the source points has no impact. We have included the method of Balachandran and Fitzpatrick in the evaluation of both studies, while computing an effective noise covariance as described in the foregoing paragraph.</p>
<p>The method of Balachandran and Fitzpatrick specifies initializing the anisotropic registration with the isotropic-noise solution before optimizing with respect to the GTLS cost function. We have performed a portion of the experiments both with and without isotropic initialization applied prior to each GTLS method. In order to better investigate the merit of the numerical machinery behind each GTLS approach, isotropic initialization was not used in Experiment 1A. In order to investigate the impact of initialization on each GTLS method, experiments were conducted both with and without isotropic initialization in Experiment 1B.</p>
<p>In order to compare all methods on level ground, several concerns had to be addressed. The first concern regards the termination criteria used by each method, which was defined (or modified) to be when the magnitude of change in the estimated transformation parameters falls below 0.0001 mm and 0.0001 degrees or when the number of iterations exceeds 60. For the method of Estepar et al., a maximum iteration threshold of 20 was applied to the inner loop (i.e. to the rotation estimation component employing the method of Ohta and Kanatani) while the full outer loop was assigned the same maximum iteration threshold as the other GTLS methods. In practice, we found that these maximum iteration thresholds were only reached under the condition of instability; thus, the iteration threshold was also used to automatically detect and count the occurrence of instability for each method.</p>
<p>The next concern regards the form of input afforded to each method. Every GTLS method compared requires some form of decomposition to be performed on the covariance matrices that define the anisotropic noise model, and these decompositions differ between the methods. To provide equal treatment, we use the noise covariances as base-line input for each GTLS method. Since the implementation by Balachandran and Fitzpatrick was programmed to use pre-computed decompositions (i.e. the inverse square root) of the covariance matrices as input, we have added the required calculation to their method and changed the input to use the covariance matrices directly.</p>
<p>Another concern affecting runtime performance regards the style of Matlab coding. To obtain the best possible runtime performance from each method, all matrix operations were fully vectorized in Matlab code, with the only exception being that a loop over the number of points-pairs was required in order to compute the inverse square root of the covariance matrices for the method of Balachandran and Fitzpatrick, as no solution was identified to fully vectorize this operation across all point-pairs. We have normalized for the runtime impact of this loop in Experiment 1B, which compares the method of Balachandran and Fitzpatrick on its own turf (i.e. with anisotropic noise in only one point set), by using a loop to compute the covariance decompositions required by the other GTLS methods as well. This loop-normalization was not performed for Experiment 1A, however, as the runtime comparison with Balachandran and Fitzpatrick is already largely incongruent for that study due to their assumption of a fixed covariance (i.e. anisotropic noise in only one point set), whereas the other GTLS methods re-compute the covariance decompositions in every iteration. Another reason that fully vectorized implementations are used in Experiment 1A is in order to assess the full potential of the other methods.</p>
<p>As a final leveling of the playing field, a runtime normalization was applied in Experiment 1B for the assumption of a fixed covariance (i.e. anisotropic noise in only one point set). This was accomplished by creating variants of the implementations of the proposed Gauss-Newton-based method and of the method by Estepar et al. that assume, like the method of Balachandran and Fitzpatrick, that the effective noise covariance remains fixed for any orientation of the source point set. This test therefore provides a reasonable relative comparison of the runtimes that can be expected from each of the various GTLS optimization schemes.</p>
<p>Experiments for the various studies comprising Experiment 1 were conducted by first generating two noisy point sets with known correspondence and known ground-truth alignment, second applying a random misalignment between the point sets, and third registering the point sets using each registration method. To form a pair of corresponding point sets, a set of 50 points was randomly generated being uniformly distributed within the interval [-100, 100] mm along each dimension in 3D space. These points served as the ground-truth points and also provided the ground-truth alignment of the two point sets. From this single set of ground-truth points, two different noisy point sets were generated by addition of zero-mean, multivariate, Gaussian noise, while using a different covariance for each point set. The two points generated from each ground-truth point were assigned as correspondences between the two point sets. The covariances were generated at random by forming a diagonal matrix of eigenvalues and multiplying on either side by a random rotation and its transpose
<disp-formula id="pone.0117688.e131"><alternatives><graphic id="pone.0117688.e131g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0117688.e131"/><mml:math id="M131" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtext>Random</mml:mtext> <mml:mspace width="4.pt"/><mml:mtext>Covariance</mml:mtext> <mml:mo>=</mml:mo> <mml:mi>R</mml:mi> <mml:mspace width="1pt"/><mml:mo form="prefix">diag</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>λ</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>λ</mml:mi> <mml:mn>2</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>λ</mml:mi> <mml:mn>3</mml:mn></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:msup><mml:mi>R</mml:mi> <mml:mi>T</mml:mi></mml:msup> <mml:mspace width="5.0pt"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(29)</label></disp-formula></p>
<p>In Experiment 1A, involving anisotropic noise in both point sets, the eigenvalues of the noise covariances were set equal to [0.5, 0.5, 2] mm<sup>2</sup>, with different random rotations being used for each set of points. In Experiment 1B, involving anisotropic noise in only one (the target) point set, these same eigenvalues were used for noising the target points, whereas isotropic noise was generated for the source points by setting all eigenvalues equal to 0.25 mm<sup>2</sup>.</p>
<p>For each study, the randomized trials were divided into several bins according to the magnitude of initial misalignment in translation and rotation. For each bin, 1000 randomized trials were performed and the results were averaged. For every trial, different sets of points, noise models, and misalignment were randomly generated and identically applied to each registration method. Registration accuracy was evaluated by computing the average distance between the un-noised point correspondences following each registration. We report this value as the registration error (RE).</p>
<p>The results of Experiment 1A, which incorporates anisotropic noise in both point sets, are presented in <xref ref-type="table" rid="pone.0117688.t001">Table 1</xref>. In this study, two levels of translational misalignment were investigated on the intervals [10, 20] mm and [90, 100] mm, along with five cases of rotational misalignment, which as a group covered the entire interval of [0, 180] degrees.</p>
<table-wrap id="pone.0117688.t001" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0117688.t001</object-id>
<label>Table 1</label>
<caption>
<title>Rigid-body registration results for corresponding point sets with anisotropic noise present in both sets of points. (Experiment 1A).</title>
</caption>
<alternatives>
<graphic id="pone.0117688.t001g" mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.t001"/>
<table frame="box" rules="all" border="0">
<colgroup span="1">
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
</colgroup>
<thead>
<tr>
<th align="left" rowspan="1" colspan="1"><bold>Trans. (mm)</bold></th>
<th align="center" colspan="5" rowspan="1"><bold>[10, 20]</bold></th>
<th align="center" colspan="5" rowspan="1"><bold>[90, 100]</bold></th>
</tr>
<tr>
<th align="left" rowspan="1" colspan="1"><bold>Rot. (deg.)</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Alg.</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Iter.</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Runtime</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>RE</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Inst.</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Alg.</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Iter.</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Runtime</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>RE</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Inst.</bold></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" rowspan="1" colspan="1">[0, 15]</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0001</td>
<td align="char" char="." rowspan="1" colspan="1">0.439</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0001</td>
<td align="char" char="." rowspan="1" colspan="1">0.442</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Estepar</td>
<td align="char" char="." rowspan="1" colspan="1">15.1</td>
<td align="char" char="." rowspan="1" colspan="1">0.0106</td>
<td align="char" char="." rowspan="1" colspan="1">0.423</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Estepar</td>
<td align="char" char="." rowspan="1" colspan="1">15.1</td>
<td align="char" char="." rowspan="1" colspan="1">0.0106</td>
<td align="char" char="." rowspan="1" colspan="1">0.424</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Balach.</td>
<td align="char" char="." rowspan="1" colspan="1">28.1</td>
<td align="char" char="." rowspan="1" colspan="1">0.0060</td>
<td align="char" char="." rowspan="1" colspan="1">0.423</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Balach.</td>
<td align="char" char="." rowspan="1" colspan="1">32.9</td>
<td align="char" char="." rowspan="1" colspan="1">0.0068</td>
<td align="char" char="." rowspan="1" colspan="1">0.424</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="char" char="." rowspan="1" colspan="1">3.8</td>
<td align="char" char="." rowspan="1" colspan="1">0.0014</td>
<td align="char" char="." rowspan="1" colspan="1">0.422</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="char" char="." rowspan="1" colspan="1">3.8</td>
<td align="char" char="." rowspan="1" colspan="1">0.0013</td>
<td align="char" char="." rowspan="1" colspan="1">0.423</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">[15, 45]</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0001</td>
<td align="char" char="." rowspan="1" colspan="1">0.443</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0001</td>
<td align="char" char="." rowspan="1" colspan="1">0.442</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Estepar</td>
<td align="char" char="." rowspan="1" colspan="1">17.2</td>
<td align="char" char="." rowspan="1" colspan="1">0.0120</td>
<td align="char" char="." rowspan="1" colspan="1">0.432</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Estepar</td>
<td align="char" char="." rowspan="1" colspan="1">17.2</td>
<td align="char" char="." rowspan="1" colspan="1">0.0120</td>
<td align="char" char="." rowspan="1" colspan="1">0.431</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Balach.</td>
<td align="char" char="." rowspan="1" colspan="1">34.1</td>
<td align="char" char="." rowspan="1" colspan="1">0.0070</td>
<td align="char" char="." rowspan="1" colspan="1">0.428</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Balach.</td>
<td align="char" char="." rowspan="1" colspan="1">37.5</td>
<td align="char" char="." rowspan="1" colspan="1">0.0076</td>
<td align="char" char="." rowspan="1" colspan="1">0.427</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="char" char="." rowspan="1" colspan="1">4.4</td>
<td align="char" char="." rowspan="1" colspan="1">0.0015</td>
<td align="char" char="." rowspan="1" colspan="1">0.424</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="char" char="." rowspan="1" colspan="1">4.4</td>
<td align="char" char="." rowspan="1" colspan="1">0.0015</td>
<td align="char" char="." rowspan="1" colspan="1">0.423</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">[45, 90]</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0001</td>
<td align="char" char="." rowspan="1" colspan="1">0.442</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0001</td>
<td align="char" char="." rowspan="1" colspan="1">0.435</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Estepar</td>
<td align="char" char="." rowspan="1" colspan="1">18.8</td>
<td align="char" char="." rowspan="1" colspan="1">0.0131</td>
<td align="char" char="." rowspan="1" colspan="1">0.456</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Estepar</td>
<td align="char" char="." rowspan="1" colspan="1">18.8</td>
<td align="char" char="." rowspan="1" colspan="1">0.0130</td>
<td align="char" char="." rowspan="1" colspan="1">0.450</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Balach.</td>
<td align="char" char="." rowspan="1" colspan="1">38.1</td>
<td align="char" char="." rowspan="1" colspan="1">0.0078</td>
<td align="char" char="." rowspan="1" colspan="1">0.442</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Balach.</td>
<td align="char" char="." rowspan="1" colspan="1">40.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.0081</td>
<td align="char" char="." rowspan="1" colspan="1">0.436</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="char" char="." rowspan="1" colspan="1">5.1</td>
<td align="char" char="." rowspan="1" colspan="1">0.0017</td>
<td align="char" char="." rowspan="1" colspan="1">0.424</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="char" char="." rowspan="1" colspan="1">5.1</td>
<td align="char" char="." rowspan="1" colspan="1">0.0017</td>
<td align="char" char="." rowspan="1" colspan="1">0.416</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">[90, 150]</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0001</td>
<td align="char" char="." rowspan="1" colspan="1">0.446</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0001</td>
<td align="char" char="." rowspan="1" colspan="1">0.439</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Estepar</td>
<td align="char" char="." rowspan="1" colspan="1">22.9</td>
<td align="char" char="." rowspan="1" colspan="1">0.0154</td>
<td align="char" char="." rowspan="1" colspan="1">0.469</td>
<td align="left" rowspan="1" colspan="1">2</td>
<td align="left" rowspan="1" colspan="1">Estepar</td>
<td align="char" char="." rowspan="1" colspan="1">23.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.0157</td>
<td align="char" char="." rowspan="1" colspan="1">0.466</td>
<td align="left" rowspan="1" colspan="1">2</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Balach.</td>
<td align="char" char="." rowspan="1" colspan="1">39.4</td>
<td align="char" char="." rowspan="1" colspan="1">0.0080</td>
<td align="char" char="." rowspan="1" colspan="1">0.448</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Balach.</td>
<td align="char" char="." rowspan="1" colspan="1">41.9</td>
<td align="char" char="." rowspan="1" colspan="1">0.0084</td>
<td align="char" char="." rowspan="1" colspan="1">0.444</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="char" char="." rowspan="1" colspan="1">6.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.0021</td>
<td align="char" char="." rowspan="1" colspan="1">0.430</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="char" char="." rowspan="1" colspan="1">6.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.0021</td>
<td align="char" char="." rowspan="1" colspan="1">0.421</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">[150, 180]</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0001</td>
<td align="char" char="." rowspan="1" colspan="1">0.444</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0001</td>
<td align="char" char="." rowspan="1" colspan="1">0.442</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Estepar</td>
<td align="char" char="." rowspan="1" colspan="1">28.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0184</td>
<td align="char" char="." rowspan="1" colspan="1">0.475</td>
<td align="left" rowspan="1" colspan="1">60</td>
<td align="left" rowspan="1" colspan="1">Estepar</td>
<td align="char" char="." rowspan="1" colspan="1">27.6</td>
<td align="char" char="." rowspan="1" colspan="1">0.0181</td>
<td align="char" char="." rowspan="1" colspan="1">0.477</td>
<td align="left" rowspan="1" colspan="1">59</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Balach.</td>
<td align="char" char="." rowspan="1" colspan="1">42.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0085</td>
<td align="char" char="." rowspan="1" colspan="1">0.439</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Balach.</td>
<td align="char" char="." rowspan="1" colspan="1">44.5</td>
<td align="char" char="." rowspan="1" colspan="1">0.0088</td>
<td align="char" char="." rowspan="1" colspan="1">0.441</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="char" char="." rowspan="1" colspan="1">8.8</td>
<td align="char" char="." rowspan="1" colspan="1">0.0028</td>
<td align="char" char="." rowspan="1" colspan="1">0.424</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="char" char="." rowspan="1" colspan="1">8.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.0028</td>
<td align="char" char="." rowspan="1" colspan="1">0.426</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
</tbody>
</table>
</alternatives>
<table-wrap-foot>
<fn id="t001fn001">
<p>Results report the efficiency (number of iterations and runtime (seconds)), registration error (RE) (mm), and instability (% of trials) of the GTLS registration method proposed in this paper compared to the closed-form isotropic solution [<xref ref-type="bibr" rid="pone.0117688.ref026">26</xref>] and the prior GTLS methods of Estepar et al. [<xref ref-type="bibr" rid="pone.0117688.ref010">10</xref>] and Balachandran and Fitzpatrick [<xref ref-type="bibr" rid="pone.0117688.ref031">31</xref>]. The tests are binned according to the magnitude of initial misalignment in translation (mm) and rotation (degrees); each bin represents average values measured over 1000 randomized trials.</p></fn>
</table-wrap-foot>
</table-wrap>
<p>As seen in the results, the proposed Gauss-Newton-based method achieves lower registration error than all compared methods across all test cases. The proposed method also maintains consistent registration error across all misalignments studied, achieving significant improvement with respect to the isotropic solution in every case. In contrast, the prior anisotropic methods of Estepar et al. and of Balachandran and Fitzpatrick worsen in accuracy as rotational misalignment increases and tend to provide larger registration errors than even the isotropic solution for rotational misalignments on the interval [45, 90] degrees and beyond.</p>
<p>The proposed method’s runtime is also several times more efficient than the other anisotropic solutions; computing a solution requires much fewer iterations (4–9) compared to the methods of Estepar et al. (15–28) and Balachandran and Fitzpatrick (28–45). Note that the iteration count for the method of Estepar et al. is reported as the total number of evaluations of its inner loop, which is where the vast majority of computation takes place for that method.</p>
<p>Another significant observation regarding the results of Experimant 1A is that the proposed method and that of Balachandran and Fitzpatrick are stable under all conditions tested, whereas the method of Estepar et al. encounters frequent instability for large rotational misalignment, with the portion of unstable trials reaching 60% for the largest rotation interval of [150, 180] degrees.</p>
<p>For the method of Balachandrian and Fitzpatrick, the increase in registration error with respect to rotation is understood to result from the assumption of a constant noise covariance as described earlier. However, it is not clear why the method of Estepar et al. exhibits a similar issue. To shed more light on this and on the issue of instability we include a third study (Experiment 1C) in this section.</p>
<p>
<xref ref-type="table" rid="pone.0117688.t002">Table 2</xref> presents the results of Experiment 1B, which incorporates anisotropic noise in only one point set and isotropic noise in the other. In this study, translational misalignment is limited to a large interval of [90, 100] mm, while the test cases for rotational misalignment remain unchanged. The trials for this experiment are conducted twice: once with and once without initializing the anisotropic methods to the isotropic noise solution; other test conditions (the exact point sets, noise, etc.) remain identical between the two types of trials.</p>
<table-wrap id="pone.0117688.t002" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0117688.t002</object-id>
<label>Table 2</label>
<caption>
<title>Rigid-body registration results for corresponding point sets with anisotropic noise present in one set of points and isotropic noise present in the other. (Experiment 1B).</title>
</caption>
<alternatives>
<graphic id="pone.0117688.t002g" mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.t002"/>
<table frame="box" rules="all" border="0">
<colgroup span="1">
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
</colgroup>
<thead>
<tr>
<th align="left" rowspan="1" colspan="1"/>
<th align="center" colspan="5" rowspan="1"><bold>Without Isotropic Initialization</bold></th>
<th align="center" colspan="5" rowspan="1"><bold>With Isotropic Initialization</bold></th>
</tr>
<tr>
<th align="left" rowspan="1" colspan="1"><bold>Rot. (deg.)</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Alg.</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Iter.</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Runtime</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>RE</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Inst.</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Alg.</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Iter.</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Runtime</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>RE</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Inst.</bold></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" rowspan="1" colspan="1">[0, 15]</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0001</td>
<td align="char" char="." rowspan="1" colspan="1">0.349</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="left" rowspan="1" colspan="1">-</td>
<td align="left" rowspan="1" colspan="1">-</td>
<td align="left" rowspan="1" colspan="1">-</td>
<td align="left" rowspan="1" colspan="1">-</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Estepar</td>
<td align="char" char="." rowspan="1" colspan="1">14.6</td>
<td align="char" char="." rowspan="1" colspan="1">0.0100</td>
<td align="char" char="." rowspan="1" colspan="1">0.332</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Estepar</td>
<td align="left" rowspan="1" colspan="1">10.4</td>
<td align="char" char="." rowspan="1" colspan="1">0.0080</td>
<td align="char" char="." rowspan="1" colspan="1">0.332</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Balach.</td>
<td align="char" char="." rowspan="1" colspan="1">32.9</td>
<td align="char" char="." rowspan="1" colspan="1">0.0068</td>
<td align="char" char="." rowspan="1" colspan="1">0.333</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Balach.</td>
<td align="left" rowspan="1" colspan="1">14.8</td>
<td align="char" char="." rowspan="1" colspan="1">0.0039</td>
<td align="char" char="." rowspan="1" colspan="1">0.332</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="char" char="." rowspan="1" colspan="1">3.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.0011</td>
<td align="char" char="." rowspan="1" colspan="1">0.332</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="left" rowspan="1" colspan="1">2.9</td>
<td align="char" char="." rowspan="1" colspan="1">0.0012</td>
<td align="char" char="." rowspan="1" colspan="1">0.332</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">[15, 45]</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0001</td>
<td align="char" char="." rowspan="1" colspan="1">0.347</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="left" rowspan="1" colspan="1">1</td>
<td align="char" char="." rowspan="1" colspan="1">0.0001</td>
<td align="char" char="." rowspan="1" colspan="1">0.347</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Estepar</td>
<td align="char" char="." rowspan="1" colspan="1">17.1</td>
<td align="char" char="." rowspan="1" colspan="1">0.0115</td>
<td align="char" char="." rowspan="1" colspan="1">0.338</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Estepar</td>
<td align="left" rowspan="1" colspan="1">10.8</td>
<td align="char" char="." rowspan="1" colspan="1">0.0076</td>
<td align="char" char="." rowspan="1" colspan="1">0.338</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Balach.</td>
<td align="char" char="." rowspan="1" colspan="1">37.5</td>
<td align="char" char="." rowspan="1" colspan="1">0.0076</td>
<td align="char" char="." rowspan="1" colspan="1">0.330</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Balach.</td>
<td align="left" rowspan="1" colspan="1">14.6</td>
<td align="char" char="." rowspan="1" colspan="1">0.0036</td>
<td align="char" char="." rowspan="1" colspan="1">0.329</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="char" char="." rowspan="1" colspan="1">4.2</td>
<td align="char" char="." rowspan="1" colspan="1">0.0012</td>
<td align="char" char="." rowspan="1" colspan="1">0.330</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="left" rowspan="1" colspan="1">2.9</td>
<td align="char" char="." rowspan="1" colspan="1">0.0011</td>
<td align="char" char="." rowspan="1" colspan="1">0.330</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">[45, 90]</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0001</td>
<td align="char" char="." rowspan="1" colspan="1">0.341</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="left" rowspan="1" colspan="1">1</td>
<td align="char" char="." rowspan="1" colspan="1">0.0001</td>
<td align="char" char="." rowspan="1" colspan="1">0.341</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Estepar</td>
<td align="char" char="." rowspan="1" colspan="1">18.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.0125</td>
<td align="char" char="." rowspan="1" colspan="1">0.352</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Estepar</td>
<td align="left" rowspan="1" colspan="1">10.8</td>
<td align="char" char="." rowspan="1" colspan="1">0.0077</td>
<td align="char" char="." rowspan="1" colspan="1">0.352</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Balach.</td>
<td align="char" char="." rowspan="1" colspan="1">40.2</td>
<td align="char" char="." rowspan="1" colspan="1">0.0081</td>
<td align="char" char="." rowspan="1" colspan="1">0.325</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Balach.</td>
<td align="left" rowspan="1" colspan="1">14.4</td>
<td align="char" char="." rowspan="1" colspan="1">0.0037</td>
<td align="char" char="." rowspan="1" colspan="1">0.325</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="char" char="." rowspan="1" colspan="1">5.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0013</td>
<td align="char" char="." rowspan="1" colspan="1">0.325</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="left" rowspan="1" colspan="1">2.9</td>
<td align="char" char="." rowspan="1" colspan="1">0.0011</td>
<td align="char" char="." rowspan="1" colspan="1">0.325</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">[90, 150]</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0001</td>
<td align="char" char="." rowspan="1" colspan="1">0.345</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="left" rowspan="1" colspan="1">1</td>
<td align="char" char="." rowspan="1" colspan="1">0.0001</td>
<td align="char" char="." rowspan="1" colspan="1">0.345</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Estepar</td>
<td align="char" char="." rowspan="1" colspan="1">22.6</td>
<td align="char" char="." rowspan="1" colspan="1">0.0149</td>
<td align="char" char="." rowspan="1" colspan="1">0.366</td>
<td align="left" rowspan="1" colspan="1">2</td>
<td align="left" rowspan="1" colspan="1">Estepar</td>
<td align="left" rowspan="1" colspan="1">11.8</td>
<td align="char" char="." rowspan="1" colspan="1">0.0082</td>
<td align="char" char="." rowspan="1" colspan="1">0.365</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Balach.</td>
<td align="char" char="." rowspan="1" colspan="1">41.9</td>
<td align="char" char="." rowspan="1" colspan="1">0.0084</td>
<td align="char" char="." rowspan="1" colspan="1">0.330</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Balach.</td>
<td align="left" rowspan="1" colspan="1">14.6</td>
<td align="char" char="." rowspan="1" colspan="1">0.0037</td>
<td align="char" char="." rowspan="1" colspan="1">0.330</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="char" char="." rowspan="1" colspan="1">6.1</td>
<td align="char" char="." rowspan="1" colspan="1">0.0015</td>
<td align="char" char="." rowspan="1" colspan="1">0.330</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="left" rowspan="1" colspan="1">2.9</td>
<td align="char" char="." rowspan="1" colspan="1">0.0011</td>
<td align="char" char="." rowspan="1" colspan="1">0.330</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">[150, 180]</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0001</td>
<td align="char" char="." rowspan="1" colspan="1">0.350</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="left" rowspan="1" colspan="1">1</td>
<td align="char" char="." rowspan="1" colspan="1">0.0001</td>
<td align="char" char="." rowspan="1" colspan="1">0.350</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Estepar</td>
<td align="char" char="." rowspan="1" colspan="1">26.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.0173</td>
<td align="char" char="." rowspan="1" colspan="1">0.373</td>
<td align="left" rowspan="1" colspan="1">60</td>
<td align="left" rowspan="1" colspan="1">Estepar</td>
<td align="left" rowspan="1" colspan="1">16.2</td>
<td align="char" char="." rowspan="1" colspan="1">0.0109</td>
<td align="char" char="." rowspan="1" colspan="1">0.385</td>
<td align="left" rowspan="1" colspan="1">10</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Balach.</td>
<td align="char" char="." rowspan="1" colspan="1">44.5</td>
<td align="char" char="." rowspan="1" colspan="1">0.0089</td>
<td align="char" char="." rowspan="1" colspan="1">0.333</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Balach.</td>
<td align="left" rowspan="1" colspan="1">14.5</td>
<td align="char" char="." rowspan="1" colspan="1">0.0037</td>
<td align="char" char="." rowspan="1" colspan="1">0.333</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="char" char="." rowspan="1" colspan="1">8.5</td>
<td align="char" char="." rowspan="1" colspan="1">0.0018</td>
<td align="char" char="." rowspan="1" colspan="1">0.333</td>
<td align="left" rowspan="1" colspan="1">0</td>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="left" rowspan="1" colspan="1">2.9</td>
<td align="char" char="." rowspan="1" colspan="1">0.0011</td>
<td align="char" char="." rowspan="1" colspan="1">0.333</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
</tbody>
</table>
</alternatives>
<table-wrap-foot>
<fn id="t002fn001">
<p>Results report the efficiency (number of iterations and runtime (seconds)), registration error (RE) (mm), and instability (% of trials) of the GTLS method proposed in this paper compared to the closed-form isotropic solution [<xref ref-type="bibr" rid="pone.0117688.ref026">26</xref>] and the prior GTLS methods of Estepar et al. [<xref ref-type="bibr" rid="pone.0117688.ref010">10</xref>] and Balachandran and Fitzpatrick [<xref ref-type="bibr" rid="pone.0117688.ref031">31</xref>]. The tests are binned according to the magnitude of initial misalignment in rotation (degrees), with all bins having a translational misalignment in the range [90, 100] mm; each bin represents average values measured over 1000 randomized trials.</p></fn>
</table-wrap-foot>
</table-wrap>
<p>As seen in <xref ref-type="table" rid="pone.0117688.t002">Table 2</xref>, the outcome is similar to the earlier study, with the most notable difference being that the method of Balachandran and Fitzpatrick computes an equally accurate registration as the proposed method, which confirms that the high registration errors encountered for this method in the prior study resulted from its assumption of anisotropic noise in only one point set. Concerning the method of Estepar et al., the increase in registration error with respect to rotational misalignment remains, which indicates a different source of error for this method.</p>
<p>It is also interesting to note, concerning the method of Estepar et al., that although the occurrence of unstable trials is reduced by initialization to the isotropic solution, the problem of instability does not go away at the largest range of rotational misalignment.</p>
<p>The proposed method remains largely more efficient than the other anisotropic methods, both with and without initialization to the isotropic solution. It is interesting to note that initialization to the isotropic solution approximately halves the runtime of the method by Balachandran and Fitzpatrick whereas the runtime for the proposed method is reduced by much less, even though the relative decrease in the number of iterations for each method is more similar. This observation indicates that the proposed method has low computational complexity beyond that of computing the initial covariance decompositions (recall for this study that the effective covariances are assumed to be constant), whereas the method of Balachandran and Fitzpatrick retains significantly more overhead per iteration following the initial covariance decompositions. Isotropic initialization also significantly reduces the runtime of the method by Estepar et al. to a little more than half its value otherwise.</p>
<p><xref ref-type="table" rid="pone.0117688.t003">Table 3</xref> presents the results of the final study in this series, Experiment 1C, which is intended to further investigate the registration error and instability issues encountered by the method of Estepar et al. relative to increases in rotational offset. This study evaluates only the rotational component of their method. That is, comparison is made concerning the GTLS rotational estimation method of Ohta and Kanatani [<xref ref-type="bibr" rid="pone.0117688.ref028">28</xref>] relative to the proposed Gauss-Newton-based GTLS method and relative to the rotation computed under an isotropic noise assumption. For this comparison, the proposed method and the isotropic solution were modified to estimate only parameters of rotation, assuming translation to be zero. This study was conducted in similar fashion as Experiment 1A, except that only rotational misalignment was applied between the two point sets.</p>
<table-wrap id="pone.0117688.t003" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0117688.t003</object-id>
<label>Table 3</label>
<caption>
<title>Rotation-only registration results for corresponding point sets with anisotropic noise present in both sets of points. (Experiment 1C).</title>
</caption>
<alternatives>
<graphic id="pone.0117688.t003g" mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.t003"/>
<table frame="box" rules="all" border="0">
<colgroup span="1">
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
</colgroup>
<thead>
<tr>
<th align="left" rowspan="1" colspan="1"><bold>Rot. (deg.)</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Alg.</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Iter.</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Runtime</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>RE</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Inst.</bold></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" rowspan="1" colspan="1">[0, 15]</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0000</td>
<td align="char" char="." rowspan="1" colspan="1">0.304</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Kanatani</td>
<td align="char" char="." rowspan="1" colspan="1">4.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0025</td>
<td align="char" char="." rowspan="1" colspan="1">0.279</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="char" char="." rowspan="1" colspan="1">3.8</td>
<td align="char" char="." rowspan="1" colspan="1">0.0013</td>
<td align="char" char="." rowspan="1" colspan="1">0.278</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">[15, 45]</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0000</td>
<td align="char" char="." rowspan="1" colspan="1">0.292</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Kanatani</td>
<td align="char" char="." rowspan="1" colspan="1">4.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0025</td>
<td align="char" char="." rowspan="1" colspan="1">0.283</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="char" char="." rowspan="1" colspan="1">4.4</td>
<td align="char" char="." rowspan="1" colspan="1">0.0015</td>
<td align="char" char="." rowspan="1" colspan="1">0.269</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">[45, 90]</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0000</td>
<td align="char" char="." rowspan="1" colspan="1">0.295</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Kanatani</td>
<td align="char" char="." rowspan="1" colspan="1">4.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0025</td>
<td align="char" char="." rowspan="1" colspan="1">0.313</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="char" char="." rowspan="1" colspan="1">5.1</td>
<td align="char" char="." rowspan="1" colspan="1">0.0017</td>
<td align="char" char="." rowspan="1" colspan="1">0.271</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">[90, 150]</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0000</td>
<td align="char" char="." rowspan="1" colspan="1">0.292</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Kanatani</td>
<td align="char" char="." rowspan="1" colspan="1">4.5</td>
<td align="char" char="." rowspan="1" colspan="1">0.0028</td>
<td align="char" char="." rowspan="1" colspan="1">0.323</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="char" char="." rowspan="1" colspan="1">6.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.0020</td>
<td align="char" char="." rowspan="1" colspan="1">0.265</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">[150, 180]</td>
<td align="left" rowspan="1" colspan="1">Isotropic</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0000</td>
<td align="char" char="." rowspan="1" colspan="1">0.286</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Kanatani</td>
<td align="char" char="." rowspan="1" colspan="1">6.1</td>
<td align="char" char="." rowspan="1" colspan="1">0.0038</td>
<td align="char" char="." rowspan="1" colspan="1">0.360</td>
<td align="left" rowspan="1" colspan="1">10</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Proposed</td>
<td align="char" char="." rowspan="1" colspan="1">8.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.0028</td>
<td align="char" char="." rowspan="1" colspan="1">0.263</td>
<td align="left" rowspan="1" colspan="1">0</td>
</tr>
</tbody>
</table>
</alternatives>
<table-wrap-foot>
<fn id="t003fn001">
<p>Results report the efficiency (number of iterations and runtime (seconds)), registration error (RE) (mm), and instability (% of trials) of the GTLS method proposed in this paper (modified to computer only rotation) compared to the closed-form isotropic solution [<xref ref-type="bibr" rid="pone.0117688.ref026">26</xref>] and the prior GTLS rotation estimation method of Ohta and Kanatani [<xref ref-type="bibr" rid="pone.0117688.ref028">28</xref>]. The tests are binned according to the magnitude of initial misalignment in rotation (degrees) with translational misalignment being zero; each bin represents average values measured over 1000 randomized trials.</p></fn>
</table-wrap-foot>
</table-wrap>
<p>As seen in <xref ref-type="table" rid="pone.0117688.t003">Table 3</xref>, the method of Ohta and Kanatani exhibits the same increase in registration error relative to rotational misalignment as encountered by the method of Estepar et al. Further, the rotation estimation exhibits similar instability under large rotational misalignment. This indicates that a source of error and instability for the method of Estepar et al. lies in the rotation estimation component.</p>
<p>The rotation estimation method in this case uses a quaternion parameterization for rotation that is optimized by applying the renormalization method of Kanatani [<xref ref-type="bibr" rid="pone.0117688.ref029">29</xref>]. Matei and Meer [<xref ref-type="bibr" rid="pone.0117688.ref030">30</xref>] have presented a technique called heteroscedastic errors-in-variables (HEIV) estimator, which is closely related to the renormalization method of Kanatani, in which they present a similarly parameterized method for computing the full rigid-body alignment of two point sets under anisotropic noise. In their work, they point out a discontinuity in the quaternion representation for rotation that produces instability for rotational misalignments close to +/- 180 degrees. It is possible that the rotation estimation method of Kanatani suffers from a similar issue, though we have not verified this further.</p>
</sec>
<sec id="sec003b">
<title>Experiment 2: Registering a Mesh Target</title>
<p>In this study, we evaluate the performance of the IMLP algorithm for registering a target shape represented by a triangular mesh. The experiment is divided into two sub-experiments (Experiments 2A and 2B) in order to evaluate the algorithm’s performance under different magnitudes of shape misalignment. The shape being registered in both cases is a human hip model segmented from CT imaging to form a surface mesh (<xref ref-type="fig" rid="pone.0117688.g001">Fig. 1A</xref>).</p>
<fig id="pone.0117688.g001" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0117688.g001</object-id>
<label>Fig 1</label>
<caption>
<title>Human hip- and femur-bone meshes used in the registration studies.</title>
<p>The red points represent a typical randomly generated source shape as sampled from the mesh surface. (A): The hip mesh is used in registration Experiments 2–5. (B): The femur mesh is used for the sub-shape registration study of Experiment 6, where points for the source shape are sampled from the shaded region of the mesh.</p>
</caption>
<graphic mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.g001"/>
</fig>
<p>The experiments are conducted by randomly generating a set of 100 noisy points from the mesh surface to form a source shape and applying a random misalignment between the source shape and the mesh. The source points are then registered back to the mesh, which forms the target shape. This approach enables accurate assessment of the registration error under varying noise conditions, since both the ground-truth alignment and the generative noise models are known.</p>
<p>Nine different test cases were conducted to evaluate each of the nine different noise models defined in <xref ref-type="table" rid="pone.0117688.t004">Table 4</xref>, which specifies the variance of multivariate Gaussian noise generated in the surface-normal vs. surface-parallel directions at each source point. Thus, the noise applied to each source point was conditioned relative to the orientation of the surface at that point. The first three test cases apply isotropic noise, the next three tests cases apply anisotropic noise of high surface-normal variance, and the final three test cases apply anisotropic noise of high surface-parallel variance, each in order of increasing magnitude of variance and increasing anisotropy. Within each of the nine test cases, 300 randomized registration trials were conducted, each involving new randomly generated points, noise, and misalignment. All compared algorithms were executed once per trial under identical test conditions (i.e. identical shape, noise, and misalignment) as generated for that trial.</p>
<table-wrap id="pone.0117688.t004" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0117688.t004</object-id>
<label>Table 4</label>
<caption>
<title>Generative noise models (test cases) used in the randomized registration trials of Experiments 2–5.</title>
</caption>
<alternatives>
<graphic id="pone.0117688.t004g" mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.t004"/>
<table frame="box" rules="all" border="0">
<colgroup span="1">
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
</colgroup>
<thead>
<tr>
<th align="left" rowspan="1" colspan="1"><bold>Test Case</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>1</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>2</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>3</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>4</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>5</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>6</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>7</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>8</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>9</bold></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" rowspan="1" colspan="1"><bold>Surface-Normal Std. Dev. (mm)</bold></td>
<td align="char" char="." rowspan="1" colspan="1">0.5</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.5</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.5</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><bold>Surface-Parallel Std. Dev. (mm)</bold></td>
<td align="char" char="." rowspan="1" colspan="1">0.5</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.5</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.5</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
</tr>
</tbody>
</table>
</alternatives>
<table-wrap-foot>
<fn id="t004fn001">
<p>This table defines the standard deviation of noise generated in the surface-normal and surface-parallel directions for each point of the source shapes in Experiments 2–5.</p></fn>
</table-wrap-foot>
</table-wrap>
<p>Registration errors were measured by randomly sampling a set of 100 non-noisy points from the mesh surface to be used in validation. Following registration, the average distance between the registered and known ground-truth positions of the validation points is measured and recorded as the target registration error (TRE). The average TRE is then reported within each test case for each algorithm. To prevent TRE outliers from skewing the averages, only successful registrations are included in the reported TRE averages. A registration trial is considered successful if the TRE is within 10 mm. The number of registration failures for each algorithm is also counted and reported within each test case. This procedure is followed for all the registration studies that follow in this paper.</p>
<p>The entire experiment was conducted twice for two different intervals of random initial misalignment: once for the misalignment interval of [15, 30] mm translation and [15, 30] degrees rotation (Experiment 2A) and again for the misalignment interval of [30, 60] mm translation and [30, 60] degrees rotation (Experiment 2B). These random misalignments were generated along random translational directions and random rotational axes.</p>
<p>This experiment compares the algorithms of standard ICP [<xref ref-type="bibr" rid="pone.0117688.ref001">1</xref>], IMLP, and the two variants IMLP-CP and IMLP-MD, which, as described in the introduction to the Results and Discussion section, provide near comparison to the GTLS-ICP [<xref ref-type="bibr" rid="pone.0117688.ref010">10</xref>] and A-ICP [<xref ref-type="bibr" rid="pone.0117688.ref012">12</xref>] algorithms, respectively. For IMLP (and variants), the measurement-noise covariances of the source points were set to correspond with the generative noise models defined in <xref ref-type="table" rid="pone.0117688.t004">Table 4</xref>, while the measurement covariances for the target shape were set to zero, since no noise was added to the mesh. Because the mesh fully represents the continuous surface of the target, IMLP’s (and variants’) surface-model covariances were set to zero, as these are intended for registering non-continuous (i.e. point-cloud) surface representations. Outlier detection was disabled by setting IMLP’s (and variants’) chi-square inverse CDF threshold (<inline-formula id="pone.0117688.e132"><mml:math id="M132" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>χ</mml:mi> <mml:mtext mathvariant="normal">thresh</mml:mtext> <mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula>) to a large value.</p>
<p>Results for Experiments 2A and 2B are presented in <xref ref-type="fig" rid="pone.0117688.g002">Figs. 2A and 2B</xref> for each range of misalignment. Similar results are obtained in both cases. As expected, the average TREs for the first three test cases are identical among all algorithms since, in this case, the noise model of IMLP reduces to the Euclidean-distance computations of standard ICP. For the anisotropic-noise test cases, the IMLP algorithm consistently achieves slightly improved or approximately equivalent registration accuracy compared to ICP. For this study, the Mahalanobis distance matching variant (IMLP-MD) computes approximately the same registration errors as IMLP, whereas the closest-point matching variant (IMLP-CP) generally performs worse, even performing worse than standard ICP for the test cases involving high variance of noise in the surface-normal direction.</p>
<fig id="pone.0117688.g002" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0117688.g002</object-id>
<label>Fig 2</label>
<caption>
<title>Registration errors for registering a mesh target shape. (Experiment 2).</title>
<p>Source shapes were randomly generated from a mesh model of a human hip (<xref ref-type="fig" rid="pone.0117688.g001">Fig. 1A</xref>), misaligned by (A): [15, 30] mm / degrees and (B): [30, 60] mm / degrees, and registered back to the mesh. The test cases represent the different noise models used to generate noise on the source shape (<xref ref-type="table" rid="pone.0117688.t004">Table 4</xref>). For each test case, 300 randomized trials were conducted, with successful registrations being used to compute an average target registration error (TRE). The error bars provide approximate standard deviations of the reported average TRE values. The proposed IMLP algorithm was evaluated relative to standard ICP [<xref ref-type="bibr" rid="pone.0117688.ref001">1</xref>] and relative to near-comparisons of GTLS-ICP [<xref ref-type="bibr" rid="pone.0117688.ref010">10</xref>] and A-ICP [<xref ref-type="bibr" rid="pone.0117688.ref012">12</xref>] using IMLP-CP and IMLP-MD, which modify IMLP’s most-likely match criteria to that of closest-point and Mahalanobis-distance matching, respectively.</p>
</caption>
<graphic mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.g002"/>
</fig>
<p>The error bars displayed in <xref ref-type="fig" rid="pone.0117688.g002">Fig. 2</xref> (and in other figures throughout this section) are approximations for the standard deviations of each displayed TRE average. They are calculated by computing the standard deviation of the TREs for a given average and dividing by the square root of the number of trials used to compute that average. This is the procedure for calculating the standard deviation of a sample mean for independent identically distributed (iid) Gaussian data [<xref ref-type="bibr" rid="pone.0117688.ref033">33</xref>]. We have verified that the histograms of TREs for successful trials reasonably resemble those of Gaussian distributions, in general; thus, the displayed standard deviations may be considered as close approximations.</p>
<p><xref ref-type="table" rid="pone.0117688.t005">Table 5</xref> lists the percentage of registration failures for each algorithm and test case in Experiment 2B. For Experiment 2A, the failure rates were 0% in all cases. As seen in the table, the algorithms performed near equally with a maximum overall failure rate of 2%.</p>
<table-wrap id="pone.0117688.t005" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0117688.t005</object-id>
<label>Table 5</label>
<caption>
<title>Registration failure rates for registering a mesh target shape. (Experiment 2B).</title>
</caption>
<alternatives>
<graphic id="pone.0117688.t005g" mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.t005"/>
<table frame="box" rules="all" border="0">
<colgroup span="1">
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
</colgroup>
<thead>
<tr>
<th align="left" rowspan="1" colspan="1"><bold>Alg.</bold></th>
<th align="center" colspan="9" rowspan="1"><bold>Failure Rate (%) by Test Case</bold></th>
</tr>
<tr>
<th align="left" rowspan="1" colspan="1"/>
<th align="left" rowspan="1" colspan="1"><bold>1</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>2</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>3</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>4</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>5</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>6</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>7</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>8</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>9</bold></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" rowspan="1" colspan="1">ICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">IMLP-CP</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">IMLP-MD</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">IMLP</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
</tr>
</tbody>
</table>
</alternatives>
<table-wrap-foot>
<fn id="t005fn001">
<p>Source shapes were randomly generated from a mesh model of a human hip (<xref ref-type="fig" rid="pone.0117688.g001">Fig. 1A</xref>), misaligned by [15, 30] mm / degrees in (Experiment 2A) and [30, 60] mm / degrees in (Experiment 2B), and registered directly back to the mesh. The test cases represent the different noise models used to generate noise on the source shape (<xref ref-type="table" rid="pone.0117688.t004">Table 4</xref>). For each test case, 300 randomized trials were conducted, with the percent of unsuccessful registrations (TRE &gt; 10 mm) being shown in this table. The proposed IMLP algorithm was evaluated relative to standard ICP [<xref ref-type="bibr" rid="pone.0117688.ref001">1</xref>] and relative to near-comparisons of GTLS-ICP [<xref ref-type="bibr" rid="pone.0117688.ref010">10</xref>] and A-ICP [<xref ref-type="bibr" rid="pone.0117688.ref012">12</xref>] using IMLP-CP and IMLP-MD, which modify IMLPâs most-likely match criteria to that of closest-point and Mahalanobis-distance matching, respectively. Failure rates for Experiment 2A (which are not shown in this table) were 0% for all algorithms and test cases.</p></fn>
</table-wrap-foot>
</table-wrap>
<p>
<xref ref-type="table" rid="pone.0117688.t006">Table 6</xref> presents a runtime analysis for the successful registrations within each experiment. Due to its greater complexity, IMLP has a runtime of approximately 3.5x that of ICP on average.</p>
<table-wrap id="pone.0117688.t006" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0117688.t006</object-id>
<label>Table 6</label>
<caption>
<title>Runtimes for registering a mesh target shape. (Experiment 2).</title>
</caption>
<alternatives>
<graphic id="pone.0117688.t006g" mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.t006"/>
<table frame="box" rules="all" border="0">
<colgroup span="1">
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
</colgroup>
<thead>
<tr>
<th align="left" rowspan="1" colspan="1"><bold>Exp.</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Alg.</bold></th>
<th align="center" colspan="9" rowspan="1"><bold>Average Runtimes (sec.) by Test Case</bold></th>
</tr>
<tr>
<th align="left" rowspan="1" colspan="1"/>
<th align="left" rowspan="1" colspan="1"/>
<th align="left" rowspan="1" colspan="1"><bold>1</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>2</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>3</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>4</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>5</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>6</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>7</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>8</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>9</bold></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" rowspan="1" colspan="1">2A</td>
<td align="left" rowspan="1" colspan="1">ICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.086</td>
<td align="char" char="." rowspan="1" colspan="1">0.094</td>
<td align="char" char="." rowspan="1" colspan="1">0.109</td>
<td align="char" char="." rowspan="1" colspan="1">0.107</td>
<td align="char" char="." rowspan="1" colspan="1">0.119</td>
<td align="char" char="." rowspan="1" colspan="1">0.115</td>
<td align="char" char="." rowspan="1" colspan="1">0.087</td>
<td align="char" char="." rowspan="1" colspan="1">0.097</td>
<td align="char" char="." rowspan="1" colspan="1">0.095</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP-CP</td>
<td align="char" char="." rowspan="1" colspan="1">0.194</td>
<td align="char" char="." rowspan="1" colspan="1">0.204</td>
<td align="char" char="." rowspan="1" colspan="1">0.228</td>
<td align="char" char="." rowspan="1" colspan="1">0.252</td>
<td align="char" char="." rowspan="1" colspan="1">0.287</td>
<td align="char" char="." rowspan="1" colspan="1">0.263</td>
<td align="char" char="." rowspan="1" colspan="1">0.138</td>
<td align="char" char="." rowspan="1" colspan="1">0.157</td>
<td align="char" char="." rowspan="1" colspan="1">0.118</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP-MD</td>
<td align="char" char="." rowspan="1" colspan="1">0.270</td>
<td align="char" char="." rowspan="1" colspan="1">0.299</td>
<td align="char" char="." rowspan="1" colspan="1">0.323</td>
<td align="char" char="." rowspan="1" colspan="1">0.389</td>
<td align="char" char="." rowspan="1" colspan="1">0.437</td>
<td align="char" char="." rowspan="1" colspan="1">0.401</td>
<td align="char" char="." rowspan="1" colspan="1">0.226</td>
<td align="char" char="." rowspan="1" colspan="1">0.249</td>
<td align="char" char="." rowspan="1" colspan="1">0.219</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP</td>
<td align="char" char="." rowspan="1" colspan="1">0.352</td>
<td align="char" char="." rowspan="1" colspan="1">0.377</td>
<td align="char" char="." rowspan="1" colspan="1">0.407</td>
<td align="char" char="." rowspan="1" colspan="1">0.499</td>
<td align="char" char="." rowspan="1" colspan="1">0.543</td>
<td align="char" char="." rowspan="1" colspan="1">0.569</td>
<td align="char" char="." rowspan="1" colspan="1">0.258</td>
<td align="char" char="." rowspan="1" colspan="1">0.239</td>
<td align="char" char="." rowspan="1" colspan="1">0.202</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">2B</td>
<td align="left" rowspan="1" colspan="1">ICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.142</td>
<td align="char" char="." rowspan="1" colspan="1">0.147</td>
<td align="char" char="." rowspan="1" colspan="1">0.165</td>
<td align="char" char="." rowspan="1" colspan="1">0.145</td>
<td align="char" char="." rowspan="1" colspan="1">0.16</td>
<td align="char" char="." rowspan="1" colspan="1">0.168</td>
<td align="char" char="." rowspan="1" colspan="1">0.135</td>
<td align="char" char="." rowspan="1" colspan="1">0.142</td>
<td align="char" char="." rowspan="1" colspan="1">0.166</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP-CP</td>
<td align="char" char="." rowspan="1" colspan="1">0.285</td>
<td align="char" char="." rowspan="1" colspan="1">0.286</td>
<td align="char" char="." rowspan="1" colspan="1">0.322</td>
<td align="char" char="." rowspan="1" colspan="1">0.346</td>
<td align="char" char="." rowspan="1" colspan="1">0.351</td>
<td align="char" char="." rowspan="1" colspan="1">0.343</td>
<td align="char" char="." rowspan="1" colspan="1">0.221</td>
<td align="char" char="." rowspan="1" colspan="1">0.222</td>
<td align="char" char="." rowspan="1" colspan="1">0.196</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP-MD</td>
<td align="char" char="." rowspan="1" colspan="1">0.339</td>
<td align="char" char="." rowspan="1" colspan="1">0.372</td>
<td align="char" char="." rowspan="1" colspan="1">0.381</td>
<td align="char" char="." rowspan="1" colspan="1">0.462</td>
<td align="char" char="." rowspan="1" colspan="1">0.496</td>
<td align="char" char="." rowspan="1" colspan="1">0.467</td>
<td align="char" char="." rowspan="1" colspan="1">0.298</td>
<td align="char" char="." rowspan="1" colspan="1">0.311</td>
<td align="char" char="." rowspan="1" colspan="1">0.275</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP</td>
<td align="char" char="." rowspan="1" colspan="1">0.444</td>
<td align="char" char="." rowspan="1" colspan="1">0.454</td>
<td align="char" char="." rowspan="1" colspan="1">0.495</td>
<td align="char" char="." rowspan="1" colspan="1">0.588</td>
<td align="char" char="." rowspan="1" colspan="1">0.638</td>
<td align="char" char="." rowspan="1" colspan="1">0.686</td>
<td align="char" char="." rowspan="1" colspan="1">0.425</td>
<td align="char" char="." rowspan="1" colspan="1">0.480</td>
<td align="char" char="." rowspan="1" colspan="1">0.379</td>
</tr>
</tbody>
</table>
</alternatives>
<table-wrap-foot>
<fn id="t006fn001">
<p>Average runtimes of successful registrations from Experiment 2 are reported, where 300 randomized trials were conducted for each test case. Each test case represents a different generative noise model (<xref ref-type="table" rid="pone.0117688.t004">Table 4</xref>) applied to points of the source shape. Results are reported for initial shape misalignments of [15, 30] mm / degrees (Experiment 2A) and [30, 60] mm / degrees (Experiment 2B). The algorithms compared include single-threaded implementations of ICP [<xref ref-type="bibr" rid="pone.0117688.ref001">1</xref>], IMLP, and the two IMLP variants IMLP-CP and IMLP-MD.</p></fn>
</table-wrap-foot>
</table-wrap>
</sec>
<sec id="sec003c">
<title>Experiment 3: Registering a Mesh Target with Outliers</title>
<p>Experiment 3 follows the same procedure as Experiment 2, using the same target shape and equivalent test cases (noise models) and numbers of trials. However, in this study the source shape is corrupted with additional points added as outliers. This experiment is again divided into two studies (Experiments 3A and 3B), one for each range of misalignment. Each study is further divided into sub-studies with varying percentages of outliers including 5%, 10%, 20%, and 30% outliers, which we refer to as sub-experiments i-iv, respectively. Since the purpose of this study is to evaluate the merit of IMLP’s outlier mechanism, the IMLP variants (which have the same outlier mechanism) are not evaluated. Robust ICP [<xref ref-type="bibr" rid="pone.0117688.ref004">4</xref>] is also added to the set of compared algorithms.</p>
<p>The additional outlier samples were generated for each trial by randomly selecting points on the mesh surface and projecting each point outward from the mesh by a random distance on the interval [10, 20] mm.</p>
<p>IMLP’s outlier detection was enabled by setting its chi-square inverse CDF threshold (<inline-formula id="pone.0117688.e133"><mml:math id="M133" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>χ</mml:mi> <mml:mtext mathvariant="normal">thresh</mml:mtext> <mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula>) to the values of {7.81, 6.25, 4.64, 3.66} for sub-experiments i-iv, respectively. These values correspond to chi-square inverse CDF probabilities of {0.95, 0.9, 0.8, 0.7}, which were chosen to directly correspond to the percentage of outliers in each test case.</p>
<p>For Robust ICP we follow the suggestion of its author and relate the user parameter <italic>D</italic>, which is used to determine when a registration is good, to the resolution of the shape data. This was accomplished by computing the average distance between a triangle center point and that of its neighbors in the mesh (in this case approximately 1.8 mm). We also set the user parameter <inline-formula id="pone.0117688.e134"><mml:math id="M134" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>D</mml:mi> <mml:mtext mathvariant="normal">max</mml:mtext> <mml:mn>0</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula>, which controls the maximum tolerable match distance of the first iteration, to a large value in order to take all matches into consideration in the first iteration, which afforded the algorithm the best chance at computing a successful registration.</p>
<p>The registration accuracy for this study is presented in Figs. <xref ref-type="fig" rid="pone.0117688.g003">3</xref> and <xref ref-type="fig" rid="pone.0117688.g004">4</xref> for Experiments 3A and 3B, respectively. Figs. <xref ref-type="fig" rid="pone.0117688.g003">3</xref> and <xref ref-type="fig" rid="pone.0117688.g004">4</xref> are each divided into four sub-figures (A-D) corresponding to sub-experiments (i-iv) of Experiments 3A and 3B, respectively, for each level of outliers. The analysis to produce these results was conducted in the same manner as described for Experiment 2. As seen in the figures, IMLP widely outperforms ICP in terms of TRE for all test cases and performs marginally better overall than Robust ICP for 5% and 10% outliers and much better than Robust ICP at higher levels of outliers, where the TRE for Robust ICP approaches and even surpasses that of standard ICP. In contrast, IMLP’s TRE remains fairly stable up to 20% outliers and begins to increase at the 30% level.</p>
<fig id="pone.0117688.g003" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0117688.g003</object-id>
<label>Fig 3</label>
<caption>
<title>Registration errors for registering a source shape containing outliers to a mesh target under moderate misalignment. (Experiment 3A).</title>
<p>Source shapes were randomly generated from the hip mesh (<xref ref-type="fig" rid="pone.0117688.g001">Fig. 1A</xref>), misaligned by [15, 30] mm / degrees, and registered back to the mesh. The test cases represent the different noise models used to generate noise on the source shape (<xref ref-type="table" rid="pone.0117688.t004">Table 4</xref>). Outliers were added to the source shape constituting (A): 5%, (B): 10%, (C): 20%, and (D): 30% of the source points. For each test case, 300 randomized trials were conducted, with successful registrations being used to compute an average target registration error (TRE). The error bars provide approximate standard deviations of the reported average TRE values. The proposed IMLP algorithm was evaluated relative to standard ICP [<xref ref-type="bibr" rid="pone.0117688.ref001">1</xref>] and relative to a robust variant of ICP [<xref ref-type="bibr" rid="pone.0117688.ref004">4</xref>].</p>
</caption>
<graphic mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.g003"/>
</fig>
<fig id="pone.0117688.g004" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0117688.g004</object-id>
<label>Fig 4</label>
<caption>
<title>Registration errors for registering a source shape containing outliers to a mesh target under large misalignment. (Experiment 3B).</title>
<p>Source shapes were randomly generated from the hip mesh (<xref ref-type="fig" rid="pone.0117688.g001">Fig. 1A</xref>), misaligned by [30, 60] mm / degrees, and registered back to the mesh. The test cases represent the different noise models used to generate noise on the source shape (<xref ref-type="table" rid="pone.0117688.t004">Table 4</xref>). Outliers were added to the source shape constituting (A): 5%, (B): 10%, (C): 20%, and (D): 30% of the source points. For each test case, 300 randomized trials were conducted, with successful registrations being used to compute an average target registration error (TRE). The error bars provide approximate standard deviations of the reported average TRE values. The proposed IMLP algorithm was evaluated relative to standard ICP [<xref ref-type="bibr" rid="pone.0117688.ref001">1</xref>] and relative to a robust variant of ICP [<xref ref-type="bibr" rid="pone.0117688.ref004">4</xref>].</p>
</caption>
<graphic mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.g004"/>
</fig>
<p>The registration failure rates shown in <xref ref-type="table" rid="pone.0117688.t007">Table 7</xref> for this study indicate that although standard ICP is the worst algorithm in terms of TRE, it has the highest registration success rate. At the lesser misalignment range, the failure rates of all algorithms are below 1% for up to 10% outliers, with IMLP having marginally higher failure rates at the 20% outlier level. At 30% outliers, the failure rate of IMLP increases significantly, accompanied by a marginal increase in the failure rate of Robust ICP. For the large misalignment range a different pattern emerges with Robust ICP exhibiting high failure rates across all outlier levels, whereas IMLP maintains low failure rates for up to 10% outliers. The failure rate of standard ICP increases marginally at this offset range yet still remains quite low.</p>
<table-wrap id="pone.0117688.t007" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0117688.t007</object-id>
<label>Table 7</label>
<caption>
<title>Registration failure rates for registering a mesh target shape with outliers. (Experiment 3).</title>
</caption>
<alternatives>
<graphic id="pone.0117688.t007g" mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.t007"/>
<table frame="box" rules="all" border="0">
<colgroup span="1">
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
</colgroup>
<thead>
<tr>
<th align="left" rowspan="1" colspan="1"><bold>Exp.</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Outliers</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Alg.</bold></th>
<th align="center" colspan="9" rowspan="1"><bold>Failure Rates (%) by Test Case</bold></th>
</tr>
<tr>
<th align="left" rowspan="1" colspan="1"/>
<th align="left" rowspan="1" colspan="1"/>
<th align="left" rowspan="1" colspan="1"/>
<th align="left" rowspan="1" colspan="1"><bold>1</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>2</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>3</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>4</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>5</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>6</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>7</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>8</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>9</bold></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" rowspan="1" colspan="1">3A-i</td>
<td align="left" rowspan="1" colspan="1">5%</td>
<td align="left" rowspan="1" colspan="1">ICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Robust ICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">3A-ii</td>
<td align="left" rowspan="1" colspan="1">10%</td>
<td align="left" rowspan="1" colspan="1">ICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Robust ICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">3A-iii</td>
<td align="left" rowspan="1" colspan="1">20%</td>
<td align="left" rowspan="1" colspan="1">ICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Robust ICP</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP</td>
<td align="char" char="." rowspan="1" colspan="1">4.0</td>
<td align="char" char="." rowspan="1" colspan="1">2.7</td>
<td align="char" char="." rowspan="1" colspan="1">4.0</td>
<td align="char" char="." rowspan="1" colspan="1">4.3</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
<td align="char" char="." rowspan="1" colspan="1">3.7</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">3.7</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">3A-iv</td>
<td align="left" rowspan="1" colspan="1">30%</td>
<td align="left" rowspan="1" colspan="1">ICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Robust ICP</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">3.0</td>
<td align="char" char="." rowspan="1" colspan="1">2.7</td>
<td align="char" char="." rowspan="1" colspan="1">5.0</td>
<td align="char" char="." rowspan="1" colspan="1">3.7</td>
<td align="char" char="." rowspan="1" colspan="1">2.7</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP</td>
<td align="char" char="." rowspan="1" colspan="1">28.0</td>
<td align="char" char="." rowspan="1" colspan="1">15.0</td>
<td align="char" char="." rowspan="1" colspan="1">11.0</td>
<td align="char" char="." rowspan="1" colspan="1">25.0</td>
<td align="char" char="." rowspan="1" colspan="1">13.3</td>
<td align="char" char="." rowspan="1" colspan="1">9.3</td>
<td align="char" char="." rowspan="1" colspan="1">22.3</td>
<td align="char" char="." rowspan="1" colspan="1">13.0</td>
<td align="char" char="." rowspan="1" colspan="1">13.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">3B-i</td>
<td align="left" rowspan="1" colspan="1">5%</td>
<td align="left" rowspan="1" colspan="1">ICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">2.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Robust ICP</td>
<td align="char" char="." rowspan="1" colspan="1">12.3</td>
<td align="char" char="." rowspan="1" colspan="1">12.3</td>
<td align="char" char="." rowspan="1" colspan="1">6.3</td>
<td align="char" char="." rowspan="1" colspan="1">5.0</td>
<td align="char" char="." rowspan="1" colspan="1">14.0</td>
<td align="char" char="." rowspan="1" colspan="1">10.0</td>
<td align="char" char="." rowspan="1" colspan="1">9.7</td>
<td align="char" char="." rowspan="1" colspan="1">10.0</td>
<td align="char" char="." rowspan="1" colspan="1">9.7</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">2.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">3B-ii</td>
<td align="left" rowspan="1" colspan="1">10%</td>
<td align="left" rowspan="1" colspan="1">ICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Robust ICP</td>
<td align="char" char="." rowspan="1" colspan="1">11.7</td>
<td align="char" char="." rowspan="1" colspan="1">7.7</td>
<td align="char" char="." rowspan="1" colspan="1">9.3</td>
<td align="char" char="." rowspan="1" colspan="1">11.7</td>
<td align="char" char="." rowspan="1" colspan="1">10.0</td>
<td align="char" char="." rowspan="1" colspan="1">12.7</td>
<td align="char" char="." rowspan="1" colspan="1">8.7</td>
<td align="char" char="." rowspan="1" colspan="1">7.0</td>
<td align="char" char="." rowspan="1" colspan="1">8.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP</td>
<td align="char" char="." rowspan="1" colspan="1">3.0</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">3.0</td>
<td align="char" char="." rowspan="1" colspan="1">5.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">3.3</td>
<td align="char" char="." rowspan="1" colspan="1">2.3</td>
<td align="char" char="." rowspan="1" colspan="1">2.3</td>
<td align="char" char="." rowspan="1" colspan="1">2.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">3B-iii</td>
<td align="left" rowspan="1" colspan="1">20%</td>
<td align="left" rowspan="1" colspan="1">ICP</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Robust ICP</td>
<td align="char" char="." rowspan="1" colspan="1">9.0</td>
<td align="char" char="." rowspan="1" colspan="1">11.3</td>
<td align="char" char="." rowspan="1" colspan="1">6.7</td>
<td align="char" char="." rowspan="1" colspan="1">8.0</td>
<td align="char" char="." rowspan="1" colspan="1">13.0</td>
<td align="char" char="." rowspan="1" colspan="1">11.0</td>
<td align="char" char="." rowspan="1" colspan="1">9.0</td>
<td align="char" char="." rowspan="1" colspan="1">13.0</td>
<td align="char" char="." rowspan="1" colspan="1">10.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP</td>
<td align="char" char="." rowspan="1" colspan="1">26.0</td>
<td align="char" char="." rowspan="1" colspan="1">17.0</td>
<td align="char" char="." rowspan="1" colspan="1">9.7</td>
<td align="char" char="." rowspan="1" colspan="1">18.3</td>
<td align="char" char="." rowspan="1" colspan="1">16.3</td>
<td align="char" char="." rowspan="1" colspan="1">14.3</td>
<td align="char" char="." rowspan="1" colspan="1">26.7</td>
<td align="char" char="." rowspan="1" colspan="1">16.3</td>
<td align="char" char="." rowspan="1" colspan="1">16.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">3B-iv</td>
<td align="left" rowspan="1" colspan="1">30%</td>
<td align="left" rowspan="1" colspan="1">ICP</td>
<td align="char" char="." rowspan="1" colspan="1">2.7</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">2.3</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">2.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
<td align="char" char="." rowspan="1" colspan="1">2.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Robust ICP</td>
<td align="char" char="." rowspan="1" colspan="1">12.7</td>
<td align="char" char="." rowspan="1" colspan="1">17.3</td>
<td align="char" char="." rowspan="1" colspan="1">12.7</td>
<td align="char" char="." rowspan="1" colspan="1">12.3</td>
<td align="char" char="." rowspan="1" colspan="1">13.7</td>
<td align="char" char="." rowspan="1" colspan="1">14.3</td>
<td align="char" char="." rowspan="1" colspan="1">10.3</td>
<td align="char" char="." rowspan="1" colspan="1">11.3</td>
<td align="char" char="." rowspan="1" colspan="1">12.7</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP</td>
<td align="char" char="." rowspan="1" colspan="1">75.0</td>
<td align="char" char="." rowspan="1" colspan="1">65.3</td>
<td align="char" char="." rowspan="1" colspan="1">47.0</td>
<td align="char" char="." rowspan="1" colspan="1">62.7</td>
<td align="char" char="." rowspan="1" colspan="1">52.3</td>
<td align="char" char="." rowspan="1" colspan="1">53.0</td>
<td align="char" char="." rowspan="1" colspan="1">75.3</td>
<td align="char" char="." rowspan="1" colspan="1">55.3</td>
<td align="char" char="." rowspan="1" colspan="1">57.7</td>
</tr>
</tbody>
</table>
</alternatives>
<table-wrap-foot>
<fn id="t007fn001">
<p>Source shapes were randomly generated from a mesh model of a human hip (<xref ref-type="fig" rid="pone.0117688.g001">Fig. 1A</xref>), misaligned by [15, 30] mm / degrees in (Experiment 3A) and [30, 60] mm / degrees in (Experiment 3B), and registered back to the mesh. The test cases represent the different noise models used to generate noise on the source shape (<xref ref-type="table" rid="pone.0117688.t004">Table 4</xref>). Outliers were added to the source shape constituting 5% (-i), 10% (-ii), 20% (-iii), and 30% (-iv) of the source points. For each test case, 300 randomized trials were conducted, with the percent of unsuccessful registrations (TRE &gt; 10 mm) being shown in this table. The proposed IMLP algorithm was evaluated relative to standard ICP [<xref ref-type="bibr" rid="pone.0117688.ref001">1</xref>] and relative to a robust variant of ICP [<xref ref-type="bibr" rid="pone.0117688.ref004">4</xref>].</p></fn>
</table-wrap-foot>
</table-wrap>
</sec>
<sec id="sec003d">
<title>Experiment 4: Registering a Point-Cloud Target</title>
<p>In this study, we investigate the performance of the IMLP algorithm for registering a target shape represented by a point cloud. Because the registration only involves point-cloud shapes, several additional algorithms can be compared. In this experiment, we evaluate standard ICP [<xref ref-type="bibr" rid="pone.0117688.ref001">1</xref>], GICP [<xref ref-type="bibr" rid="pone.0117688.ref011">11</xref>], CPD [<xref ref-type="bibr" rid="pone.0117688.ref020">20</xref>], IMLP, and the two variants IMLP-CP and IMLP-MD.</p>
<p>A dense point cloud formed from the center points of every triangle in the human hip mesh (<xref ref-type="fig" rid="pone.0117688.g001">Fig. 1A</xref>) is used as the target shape. Besides this change, the test conditions remain as described for Experiment 2. This study is likewise divided into two parts representing different random misalignment intervals: [15, 30] mm / degrees (Experiment 4A) and [30, 60] mm / degrees (Experiment 4B).</p>
<p>In contrast to Experiment 2, the surface-model covariances of IMLP (and variants) are enabled in this study and defined to have standard deviations of 0.5 mm in the surface-normal direction and 5 mm in the surface-parallel directions. Recall that these covariances provide a linear local approximation of the unmeasured surface surrounding each sampled point in order to improve registration accuracy. The measurement-error covariances remain as defined in Experiment 2.</p>
<p>The GICP algorithm also employs a local surface model surrounding each sampled point and uses its covariance matrices for this sole purpose. The covariance scaling parameter (<italic>ϵ</italic>) of GICP is set to 0.01, which is equal to the ratio of surface-normal vs. surface-parallel variances defined for IMLP. The surface-model used to evaluate GICP is therefore equivalent to the surface-model used by IMLP, because the optimizations performed by GICP do not change with respect to a global scaling of its covariances. We also tested GICP’s default <italic>ε</italic> value of 0.001, but found 0.01 to provide higher accuracy in this study.</p>
<p>Outlier detection is disabled by setting the chi-square inverse CDF threshold of IMLP to a large value and setting the outlier weight of CPD to zero. The maximum match search distance of GICP is also set to a large value in order to not exclude any matches from consideration. Rigid-body transformation without scaling was selected as the CPD registration method, with the target point cloud being used as the GMM centroids and the source point cloud being used as the data points. This choice of roles was found to be important, as reversing the roles of the source and target points produced substantially higher registration errors.</p>
<p>The registration accuracies achieved by each algorithm for this experiment are presented in <xref ref-type="fig" rid="pone.0117688.g005">Fig. 5</xref>. Similar results were obtained for both ranges of initial misalignment. As seen in the figure, IMLP achieves significantly better registration accuracy than any other algorithm across all test cases for both ranges of misalignment, with exception of CPD for which IMLP achieves comparatively better accuracy in more than half of the test cases considered. Note that unlike Experiment 2A, in this experiment IMLP strongly outperforms ICP even for the initial test cases involving isotropic measurement noise. The reason for this stems from the surface-model covariances used to model unmeasured surface regions surrounding each sample point.</p>
<fig id="pone.0117688.g005" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0117688.g005</object-id>
<label>Fig 5</label>
<caption>
<title>Registration errors for registering a point-cloud target shape. (Experiment 4).</title>
<p>Source shapes were randomly generated from a mesh model of a human hip (<xref ref-type="fig" rid="pone.0117688.g001">Fig. 1A</xref>), misaligned by (A): [15, 30] mm / degrees and (B): [30, 60] mm / degrees, and registered back to a point-cloud representation of the mesh. The test cases represent different noise models used to generate noise on the source shape (<xref ref-type="table" rid="pone.0117688.t004">Table 4</xref>). For each test case, 300 randomized trials were conducted, with successful registrations being used to compute an average target registration error (TRE). The error bars provide approximate standard deviations of the reported average TRE values. The proposed IMLP algorithm was evaluated relative to standard ICP [<xref ref-type="bibr" rid="pone.0117688.ref001">1</xref>], GICP [<xref ref-type="bibr" rid="pone.0117688.ref011">11</xref>], and CPD [<xref ref-type="bibr" rid="pone.0117688.ref020">20</xref>], as well as relative to near-comparisons of GTLS-ICP [<xref ref-type="bibr" rid="pone.0117688.ref010">10</xref>] and A-ICP [<xref ref-type="bibr" rid="pone.0117688.ref012">12</xref>] using the two variants IMLP-CP and IMLP-MD, which modify IMLP’s most-likely match criteria to that of closest-point and Mahalanobis-distance matching, respectively.</p>
</caption>
<graphic mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.g005"/>
</fig>
<p>The advantage of IMLP’s most-likely-point matching criteria is particularly highlighted in comparison to the two variants of IMLP that evaluate modifications of its match criteria, i.e. closest-point matching (IMLP-CP) and Mahalanobis-distance matching (IMLP-MD). IMLP achieves significantly, and in some cases substantially, higher accuracy than either of these variants for all test cases considered. Compared to GICP, IMLP also attains a notable accuracy improvement in all test cases, which further underscores the advantage of IMLP’s most-likely-point matching criteria and of its modeling of measurement error.</p>
<p>It is remarkable that the Mahalanobis-distance matching criteria (IMLP-MD) has worse accuracy in this experiment than closest-point matching (IMLP-CP) and, for some test cases, shows no improvement over standard ICP. This result is surprising, especially given that the reverse was true in Experiment 2A, which involved registering to a mesh rather than a point-cloud target.</p>
<p>
<xref ref-type="table" rid="pone.0117688.t008">Table 8</xref> lists the registration failure rates of each algorithm for the large misalignment range of Experiment 4B. For Experiment 4A, no registration failures were indicated except for standard ICP, which had one failure in the second test case. As shown in the table, all algorithms achieve very low failure rates, with GICP being marginally higher than the others and CPD having the best performance with no registration failures.</p>
<table-wrap id="pone.0117688.t008" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0117688.t008</object-id>
<label>Table 8</label>
<caption>
<title>Registration failure rates for registering a point-cloud target shape. (Experiment 4B).</title>
</caption>
<alternatives>
<graphic id="pone.0117688.t008g" mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.t008"/>
<table frame="box" rules="all" border="0">
<colgroup span="1">
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
</colgroup>
<thead>
<tr>
<th align="left" rowspan="1" colspan="1"><bold>Alg.</bold></th>
<th align="center" colspan="9" rowspan="1"><bold>Failure Rate (%) by Test Case</bold></th>
</tr>
<tr>
<th align="left" rowspan="1" colspan="1"/>
<th align="left" rowspan="1" colspan="1"><bold>1</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>2</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>3</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>4</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>5</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>6</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>7</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>8</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>9</bold></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" rowspan="1" colspan="1">ICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">IMLP-CP</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">IMLP-MD</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">GICP</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">2.7</td>
<td align="char" char="." rowspan="1" colspan="1">3.7</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">CPD</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">IMLP</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
</tr>
</tbody>
</table>
</alternatives>
<table-wrap-foot>
<fn id="t008fn001">
<p>Source shapes were randomly generated from a mesh model of a human hip (<xref ref-type="fig" rid="pone.0117688.g001">Fig. 1A</xref>), misaligned by [15, 30] mm / degrees in (Experiment 4A) and [30, 60] mm / degrees in (Experiment 4B), and registered back to a point-cloud representation of the mesh. The test cases represent different noise models used to generate noise on the source shape (<xref ref-type="table" rid="pone.0117688.t004">Table 4</xref>). For each test case, 300 randomized trials were conducted, with the percent of unsuccessful registrations (TRE &gt; 10 mm) being shown in this table. The proposed IMLP algorithm was evaluated relative to standard ICP [<xref ref-type="bibr" rid="pone.0117688.ref001">1</xref>], GICP [<xref ref-type="bibr" rid="pone.0117688.ref011">11</xref>], and CPD [<xref ref-type="bibr" rid="pone.0117688.ref020">20</xref>], as well as relative to near-comparisons of GTLS-ICP [<xref ref-type="bibr" rid="pone.0117688.ref010">10</xref>] and A-ICP [<xref ref-type="bibr" rid="pone.0117688.ref012">12</xref>] using IMLP-CP and IMLP-MD, which modify IMLP’s most-likely match criteria to that of closest-point and Mahalanobis-distance matching, respectively. Failure rates for Experiment 4A (which are not shown in the table) were 0% for all algorithms and test cases, except for test case 2, where standard ICP incurred one registration failure.</p></fn>
</table-wrap-foot>
</table-wrap>
<p><xref ref-type="table" rid="pone.0117688.t009">Table 9</xref> presents a runtime comparison of each algorithm. Standard ICP is the most efficient algorithm, with IMLP-CP coming second at approximately twice the runtime on average. While not shown in the table, the runtime of GICP is also on-par with that of IMLP-CP. The runtime of GICP is excluded from the table because it was executed within a Live Linux distribution running on a USB flash drive with persistent storage, which occasionally stuttered during execution causing inflated runtime averages. Although IMLP’s runtime is approximately 9 times that of standard ICP in this study, IMLP is up to 60 times more efficient than CPD and 45 times more efficient on average. Using the input settings applied to CPD in this study, it was observed that CPD utilized 100% of both cores on the dual-core test platform, unlike the other algorithms which ran single-threaded. Thus, after normalizing for multithreading, IMLP is approximately two orders of magnitude more efficient than CPD.</p>
<table-wrap id="pone.0117688.t009" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0117688.t009</object-id>
<label>Table 9</label>
<caption>
<title>Runtimes for registering a point-cloud target shape. (Experiment 4).</title>
</caption>
<alternatives>
<graphic id="pone.0117688.t009g" mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.t009"/>
<table frame="box" rules="all" border="0">
<colgroup span="1">
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
</colgroup>
<thead>
<tr>
<th align="left" rowspan="1" colspan="1"><bold>Exp.</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Alg.</bold></th>
<th align="center" colspan="9" rowspan="1"><bold>Average Runtimes (sec.) by Test Case</bold></th>
</tr>
<tr>
<th align="left" rowspan="1" colspan="1"/>
<th align="left" rowspan="1" colspan="1"/>
<th align="left" rowspan="1" colspan="1"><bold>1</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>2</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>3</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>4</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>5</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>6</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>7</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>8</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>9</bold></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" rowspan="1" colspan="1">4A</td>
<td align="left" rowspan="1" colspan="1">ICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.009</td>
<td align="char" char="." rowspan="1" colspan="1">0.009</td>
<td align="char" char="." rowspan="1" colspan="1">0.010</td>
<td align="char" char="." rowspan="1" colspan="1">0.009</td>
<td align="char" char="." rowspan="1" colspan="1">0.010</td>
<td align="char" char="." rowspan="1" colspan="1">0.009</td>
<td align="char" char="." rowspan="1" colspan="1">0.009</td>
<td align="char" char="." rowspan="1" colspan="1">0.009</td>
<td align="char" char="." rowspan="1" colspan="1">0.009</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP-CP</td>
<td align="char" char="." rowspan="1" colspan="1">0.015</td>
<td align="char" char="." rowspan="1" colspan="1">0.016</td>
<td align="char" char="." rowspan="1" colspan="1">0.019</td>
<td align="char" char="." rowspan="1" colspan="1">0.016</td>
<td align="char" char="." rowspan="1" colspan="1">0.020</td>
<td align="char" char="." rowspan="1" colspan="1">0.019</td>
<td align="char" char="." rowspan="1" colspan="1">0.015</td>
<td align="char" char="." rowspan="1" colspan="1">0.017</td>
<td align="char" char="." rowspan="1" colspan="1">0.015</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP-MD</td>
<td align="char" char="." rowspan="1" colspan="1">0.068</td>
<td align="char" char="." rowspan="1" colspan="1">0.078</td>
<td align="char" char="." rowspan="1" colspan="1">0.093</td>
<td align="char" char="." rowspan="1" colspan="1">0.079</td>
<td align="char" char="." rowspan="1" colspan="1">0.097</td>
<td align="char" char="." rowspan="1" colspan="1">0.093</td>
<td align="char" char="." rowspan="1" colspan="1">0.067</td>
<td align="char" char="." rowspan="1" colspan="1">0.079</td>
<td align="char" char="." rowspan="1" colspan="1">0.069</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">GICP</td>
<td align="left" rowspan="1" colspan="1">-</td>
<td align="left" rowspan="1" colspan="1">-</td>
<td align="left" rowspan="1" colspan="1">-</td>
<td align="left" rowspan="1" colspan="1">-</td>
<td align="left" rowspan="1" colspan="1">-</td>
<td align="left" rowspan="1" colspan="1">-</td>
<td align="left" rowspan="1" colspan="1">-</td>
<td align="left" rowspan="1" colspan="1">-</td>
<td align="left" rowspan="1" colspan="1">-</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">CPD (2 cores)</td>
<td align="char" char="." rowspan="1" colspan="1">3.465</td>
<td align="char" char="." rowspan="1" colspan="1">4.346</td>
<td align="char" char="." rowspan="1" colspan="1">4.336</td>
<td align="char" char="." rowspan="1" colspan="1">3.864</td>
<td align="char" char="." rowspan="1" colspan="1">4.340</td>
<td align="char" char="." rowspan="1" colspan="1">4.374</td>
<td align="char" char="." rowspan="1" colspan="1">4.238</td>
<td align="char" char="." rowspan="1" colspan="1">4.650</td>
<td align="char" char="." rowspan="1" colspan="1">4.484</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP</td>
<td align="char" char="." rowspan="1" colspan="1">0.068</td>
<td align="char" char="." rowspan="1" colspan="1">0.082</td>
<td align="char" char="." rowspan="1" colspan="1">0.102</td>
<td align="char" char="." rowspan="1" colspan="1">0.078</td>
<td align="char" char="." rowspan="1" colspan="1">0.103</td>
<td align="char" char="." rowspan="1" colspan="1">0.099</td>
<td align="char" char="." rowspan="1" colspan="1">0.067</td>
<td align="char" char="." rowspan="1" colspan="1">0.084</td>
<td align="char" char="." rowspan="1" colspan="1">0.073</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">4B</td>
<td align="left" rowspan="1" colspan="1">ICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.013</td>
<td align="char" char="." rowspan="1" colspan="1">0.013</td>
<td align="char" char="." rowspan="1" colspan="1">0.013</td>
<td align="char" char="." rowspan="1" colspan="1">0.013</td>
<td align="char" char="." rowspan="1" colspan="1">0.013</td>
<td align="char" char="." rowspan="1" colspan="1">0.013</td>
<td align="char" char="." rowspan="1" colspan="1">0.012</td>
<td align="char" char="." rowspan="1" colspan="1">0.012</td>
<td align="char" char="." rowspan="1" colspan="1">0.013</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP-CP</td>
<td align="char" char="." rowspan="1" colspan="1">0.023</td>
<td align="char" char="." rowspan="1" colspan="1">0.025</td>
<td align="char" char="." rowspan="1" colspan="1">0.028</td>
<td align="char" char="." rowspan="1" colspan="1">0.025</td>
<td align="char" char="." rowspan="1" colspan="1">0.028</td>
<td align="char" char="." rowspan="1" colspan="1">0.028</td>
<td align="char" char="." rowspan="1" colspan="1">0.024</td>
<td align="char" char="." rowspan="1" colspan="1">0.025</td>
<td align="char" char="." rowspan="1" colspan="1">0.024</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP-MD</td>
<td align="char" char="." rowspan="1" colspan="1">0.100</td>
<td align="char" char="." rowspan="1" colspan="1">0.109</td>
<td align="char" char="." rowspan="1" colspan="1">0.126</td>
<td align="char" char="." rowspan="1" colspan="1">0.112</td>
<td align="char" char="." rowspan="1" colspan="1">0.127</td>
<td align="char" char="." rowspan="1" colspan="1">0.129</td>
<td align="char" char="." rowspan="1" colspan="1">0.100</td>
<td align="char" char="." rowspan="1" colspan="1">0.109</td>
<td align="char" char="." rowspan="1" colspan="1">0.099</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">GICP</td>
<td align="left" rowspan="1" colspan="1">-</td>
<td align="left" rowspan="1" colspan="1">-</td>
<td align="left" rowspan="1" colspan="1">-</td>
<td align="left" rowspan="1" colspan="1">-</td>
<td align="left" rowspan="1" colspan="1">-</td>
<td align="left" rowspan="1" colspan="1">-</td>
<td align="left" rowspan="1" colspan="1">-</td>
<td align="left" rowspan="1" colspan="1">-</td>
<td align="left" rowspan="1" colspan="1">-</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">CPD (2 cores)</td>
<td align="char" char="." rowspan="1" colspan="1">3.584</td>
<td align="char" char="." rowspan="1" colspan="1">4.408</td>
<td align="char" char="." rowspan="1" colspan="1">4.490</td>
<td align="char" char="." rowspan="1" colspan="1">4.279</td>
<td align="char" char="." rowspan="1" colspan="1">4.327</td>
<td align="char" char="." rowspan="1" colspan="1">4.545</td>
<td align="char" char="." rowspan="1" colspan="1">4.378</td>
<td align="char" char="." rowspan="1" colspan="1">4.731</td>
<td align="char" char="." rowspan="1" colspan="1">4.874</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP</td>
<td align="char" char="." rowspan="1" colspan="1">0.101</td>
<td align="char" char="." rowspan="1" colspan="1">0.111</td>
<td align="char" char="." rowspan="1" colspan="1">0.134</td>
<td align="char" char="." rowspan="1" colspan="1">0.115</td>
<td align="char" char="." rowspan="1" colspan="1">0.136</td>
<td align="char" char="." rowspan="1" colspan="1">0.133</td>
<td align="char" char="." rowspan="1" colspan="1">0.103</td>
<td align="char" char="." rowspan="1" colspan="1">0.118</td>
<td align="char" char="." rowspan="1" colspan="1">0.106</td>
</tr>
</tbody>
</table>
</alternatives>
<table-wrap-foot>
<fn id="t009fn001">
<p>Average runtimes of successful registrations from Experiment 4 are reported, where 300 randomized trials were conducted for each test case. Each test case represents a different generative noise model (<xref ref-type="table" rid="pone.0117688.t004">Table 4</xref>) applied to points of the source shape. Results are also reported for initial shape misalignments of [15, 30] mm / degrees (Experiment 4A) and [30, 60] mm / degrees (Experiment 4B). The algorithms compared include single-threaded implementations of ICP [<xref ref-type="bibr" rid="pone.0117688.ref001">1</xref>], GICP [<xref ref-type="bibr" rid="pone.0117688.ref011">11</xref>], IMLP, and the two IMLP variants IMLP-CP and IMLP-MD. A multi-threaded implementation of CPD [<xref ref-type="bibr" rid="pone.0117688.ref020">20</xref>] is also reported, which made full utilization of 2 cores.</p></fn>
</table-wrap-foot>
</table-wrap>
<p>In this study, the runtime difference between ICP and IMLP is greater than observed in Experiment 2A regarding a mesh target. This happens because the node search of the correspondence phase is simplified in this study by not having to compute the closest point on a triangle when computing the distance to a single datum in the PD tree. Although this provides a performance boost to both algorithms, the effect on ICP is much more pronounced since this computation occupies a greater percentage of ICP’s overall runtime.</p>
</sec>
<sec id="sec003e">
<title>Experiment 5: Registering a Point-Cloud Target with Outliers</title>
<p>Experiment 5 follows a similar test scenario as Experiment 4, except that the source point set is corrupted with additional points added as outliers. These outliers are generated in the same manner as Experiment 3. Likewise, this experiment is divided into two studies (Experiments 5A and 5B) corresponding to each range of misalignment and further sub-divided for different percentages of outliers including 5%, 10%, 20%, and 30%, which are referred to as sub-experiments i-iv, respectively. As in Experiment 3, the two variants on IMLP are not included in this outlier study, whereas Robust ICP is added.</p>
<p>For IMLP the chi-square inverse CDF threshold is set according to the percentage of outliers as previously described in Experiment 3. Both the surface-model and measurement-error covariances are used in this study in the same manner as was described in Experiment 4. The user-defined parameters for Robust ICP are also configured as in Experiment 3. Following the lead of CPDâs authors, we set the outlier weight to 0.5. In this case, the target point cloud is assigned as the data points and the source point cloud as the GMM centroids, which is the reverse of Experiment 3, as it was observed that this setting produced substantially lower registration error for the case of non-zero outlier weighting. Concerning the GICP algorithm, although a user-defined parameter is provided for limiting the match-search distance, this mechanism is intended for partial-shape registration rather than outlier handling. Although limiting the match-search distance to 10 mm (to eliminate the outliers positioned between 10 and 20 mm from the surface) improves the registration accuracy for some trials, this also causes registration failure in most cases. Thus, GICP is compared in this study by setting its maximum search distance to a large value and considering it to be a non-robust algorithm.</p>
<p>The TRE achieved by each algorithm in this study is presented in <xref ref-type="fig" rid="pone.0117688.g006">Fig. 6</xref> for the range of small misalignments (Experiment 5A) and in <xref ref-type="fig" rid="pone.0117688.g007">Fig. 7</xref> for the range of large misalignments (Experiment 5B). Figs. <xref ref-type="fig" rid="pone.0117688.g006">6</xref> and <xref ref-type="fig" rid="pone.0117688.g007">7</xref> are each divided into four sub-figures (A-D) corresponding to sub-experiments (i-iv) of Experiments 5A and 5B, respectively, for each level of outliers. As in the prior studies, the TRE outcomes for each misalignment range are very similar. As seen in the figures, IMLP achieves large improvement in registration accuracy relative to the other algorithms for up to 20% outliers, even in comparison to CPD, which has a very effective outlier rejection capability. For the 30% outlier case, IMLP continues to provide accurate results and compares approximately equal to CPD. Compared to Robust ICP, IMLP is substantially more accurate in all test cases and frequently achieves less than half the registration error and below. As expected, standard ICP and GICP perform poorly, since they are non-robust techniques and do not include mechanisms to account for outliers. Robust ICP fairs much better than the non-robust methods for outlier compositions of 10% and below, but produces higher registration error than standard ICP for the outlier percentages above 10%.</p>
<fig id="pone.0117688.g006" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0117688.g006</object-id>
<label>Fig 6</label>
<caption>
<title>Registration errors for registering a source shape containing outliers to a point-cloud target under moderate misalignment. (Experiment 5A).</title>
<p>Source shapes were randomly generated from a mesh model of a human hip (<xref ref-type="fig" rid="pone.0117688.g001">Fig. 1A</xref>), misaligned by [15, 30] mm / degrees, and registered back to a point-cloud representation of the mesh. The test cases represent different noise models used to generate noise on the source shape (<xref ref-type="table" rid="pone.0117688.t004">Table 4</xref>). Outliers were added to the source shape constituting (A): 5%, (B): 10%, (C): 20%, and (D): 30% of the source points. For each test case, 300 randomized trials were conducted, with successful registrations being used to compute an average target registration error (TRE). The error bars provide approximate standard deviations of the reported average TRE values. The proposed IMLP algorithm was evaluated relative to standard ICP [<xref ref-type="bibr" rid="pone.0117688.ref001">1</xref>], GICP [<xref ref-type="bibr" rid="pone.0117688.ref011">11</xref>], a robust variant of ICP [<xref ref-type="bibr" rid="pone.0117688.ref004">4</xref>], and CPD [<xref ref-type="bibr" rid="pone.0117688.ref020">20</xref>].</p>
</caption>
<graphic mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.g006"/>
</fig>
<fig id="pone.0117688.g007" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0117688.g007</object-id>
<label>Fig 7</label>
<caption>
<title>Registration errors for registering a source shape containing outliers to a point-cloud target under large misalignment. (Experiment 5B).</title>
<p>Source shapes were randomly generated from a mesh model of a human hip (<xref ref-type="fig" rid="pone.0117688.g001">Fig. 1A</xref>), misaligned by [30, 60] mm / degrees, and registered back to a point-cloud representation of the mesh. The test cases represent different noise models used to generate noise on the source shape (<xref ref-type="table" rid="pone.0117688.t004">Table 4</xref>). Outliers were added to the source shape constituting (A): 5%, (B): 10%, (C): 20%, and (D): 30% of the source points. For each test case, 300 randomized trials were conducted, with successful registrations being used to compute an average target registration error (TRE). The error bars provide approximate standard deviations of the reported average TRE values. The proposed IMLP algorithm was evaluated relative to standard ICP [<xref ref-type="bibr" rid="pone.0117688.ref001">1</xref>], GICP [<xref ref-type="bibr" rid="pone.0117688.ref011">11</xref>], a robust variant of ICP [<xref ref-type="bibr" rid="pone.0117688.ref004">4</xref>], and CPD [<xref ref-type="bibr" rid="pone.0117688.ref020">20</xref>].</p>
</caption>
<graphic mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.g007"/>
</fig>
<p><xref ref-type="table" rid="pone.0117688.t010">Table 10</xref> shows the rate of registration failure for both ranges of misalignment. For small misalignment (Experiment 5A) all algorithms achieve very low failure rates for outlier compositions up to 20%, with exception of GICP which has high failure rate at 20% outliers and beyond. At 30% outliers, the failure rates of Robust ICP and IMLP moderately increase whereas the failure rates of ICP and CPD remain low with CPD achieving no registration failure. For large misalignment, the failure rates of all algorithms are increased, with CPD again providing the best performance. IMLP is approximately on-par with CPD for outliers up to 10%. At 20% outliers, the failure rate of IMLP increases to a moderate 2–6.7%; at 30% outliers, the failure rate increases significantly to 12% and beyond. In contrast, the Robust ICP algorithm performs poorly across the board with an average failure rate above 10% for all percentages of outliers.</p>
<table-wrap id="pone.0117688.t010" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0117688.t010</object-id>
<label>Table 10</label>
<caption>
<title>Registration failure rates for registering a point-cloud target shape with outliers. (Experiment 5).</title>
</caption>
<alternatives>
<graphic id="pone.0117688.t010g" mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.t010"/>
<table frame="box" rules="all" border="0">
<colgroup span="1">
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
</colgroup>
<thead>
<tr>
<th align="left" rowspan="1" colspan="1"><bold>Exp.</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Outliers</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Alg.</bold></th>
<th align="center" colspan="9" rowspan="1"><bold>Failure Rate (%) by Test Case</bold></th>
</tr>
<tr>
<th align="left" rowspan="1" colspan="1"/>
<th align="left" rowspan="1" colspan="1"/>
<th align="left" rowspan="1" colspan="1"/>
<th align="left" rowspan="1" colspan="1"><bold>1</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>2</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>3</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>4</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>5</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>6</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>7</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>8</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>9</bold></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" rowspan="1" colspan="1">5A-i</td>
<td align="left" rowspan="1" colspan="1">5%</td>
<td align="left" rowspan="1" colspan="1">ICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">GICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Robust ICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">CPD</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">5A-ii</td>
<td align="left" rowspan="1" colspan="1">10%</td>
<td align="left" rowspan="1" colspan="1">ICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">GICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Robust ICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">CPD</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">5A-iii</td>
<td align="left" rowspan="1" colspan="1">20%</td>
<td align="left" rowspan="1" colspan="1">ICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">GICP</td>
<td align="char" char="." rowspan="1" colspan="1">5.7</td>
<td align="char" char="." rowspan="1" colspan="1">7.0</td>
<td align="char" char="." rowspan="1" colspan="1">6.3</td>
<td align="char" char="." rowspan="1" colspan="1">5.7</td>
<td align="char" char="." rowspan="1" colspan="1">8.0</td>
<td align="char" char="." rowspan="1" colspan="1">9.3</td>
<td align="char" char="." rowspan="1" colspan="1">5.3</td>
<td align="char" char="." rowspan="1" colspan="1">4.3</td>
<td align="char" char="." rowspan="1" colspan="1">8.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Robust ICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">CPD</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">5A-iv</td>
<td align="left" rowspan="1" colspan="1">30%</td>
<td align="left" rowspan="1" colspan="1">ICP</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">GICP</td>
<td align="char" char="." rowspan="1" colspan="1">17.0</td>
<td align="char" char="." rowspan="1" colspan="1">13.3</td>
<td align="char" char="." rowspan="1" colspan="1">18.7</td>
<td align="char" char="." rowspan="1" colspan="1">15.7</td>
<td align="char" char="." rowspan="1" colspan="1">21.3</td>
<td align="char" char="." rowspan="1" colspan="1">15.3</td>
<td align="char" char="." rowspan="1" colspan="1">14.3</td>
<td align="char" char="." rowspan="1" colspan="1">18.0</td>
<td align="char" char="." rowspan="1" colspan="1">15.7</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Robust ICP</td>
<td align="char" char="." rowspan="1" colspan="1">4.7</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">3.3</td>
<td align="char" char="." rowspan="1" colspan="1">2.3</td>
<td align="char" char="." rowspan="1" colspan="1">3.0</td>
<td align="char" char="." rowspan="1" colspan="1">4.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">CPD</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP</td>
<td align="char" char="." rowspan="1" colspan="1">4.7</td>
<td align="char" char="." rowspan="1" colspan="1">3.0</td>
<td align="char" char="." rowspan="1" colspan="1">5.3</td>
<td align="char" char="." rowspan="1" colspan="1">3.3</td>
<td align="char" char="." rowspan="1" colspan="1">6.0</td>
<td align="char" char="." rowspan="1" colspan="1">3.3</td>
<td align="char" char="." rowspan="1" colspan="1">3.3</td>
<td align="char" char="." rowspan="1" colspan="1">3.0</td>
<td align="char" char="." rowspan="1" colspan="1">4.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">5B-i</td>
<td align="left" rowspan="1" colspan="1">5%</td>
<td align="left" rowspan="1" colspan="1">ICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">GICP</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">3.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Robust ICP</td>
<td align="char" char="." rowspan="1" colspan="1">14.3</td>
<td align="char" char="." rowspan="1" colspan="1">9.7</td>
<td align="char" char="." rowspan="1" colspan="1">8.3</td>
<td align="char" char="." rowspan="1" colspan="1">12.7</td>
<td align="char" char="." rowspan="1" colspan="1">15.0</td>
<td align="char" char="." rowspan="1" colspan="1">11.3</td>
<td align="char" char="." rowspan="1" colspan="1">11.0</td>
<td align="char" char="." rowspan="1" colspan="1">12.7</td>
<td align="char" char="." rowspan="1" colspan="1">8.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">CPD</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">5B-ii</td>
<td align="left" rowspan="1" colspan="1">10%</td>
<td align="left" rowspan="1" colspan="1">ICP</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">GICP</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
<td align="char" char="." rowspan="1" colspan="1">2.7</td>
<td align="char" char="." rowspan="1" colspan="1">2.3</td>
<td align="char" char="." rowspan="1" colspan="1">3.0</td>
<td align="char" char="." rowspan="1" colspan="1">3.3</td>
<td align="char" char="." rowspan="1" colspan="1">3.3</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">2.7</td>
<td align="char" char="." rowspan="1" colspan="1">2.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Robust ICP</td>
<td align="char" char="." rowspan="1" colspan="1">12.7</td>
<td align="char" char="." rowspan="1" colspan="1">12.3</td>
<td align="char" char="." rowspan="1" colspan="1">11.3</td>
<td align="char" char="." rowspan="1" colspan="1">11.0</td>
<td align="char" char="." rowspan="1" colspan="1">12.0</td>
<td align="char" char="." rowspan="1" colspan="1">10.7</td>
<td align="char" char="." rowspan="1" colspan="1">10.7</td>
<td align="char" char="." rowspan="1" colspan="1">11.3</td>
<td align="char" char="." rowspan="1" colspan="1">9.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">CPD</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">5B-iii</td>
<td align="left" rowspan="1" colspan="1">20%</td>
<td align="left" rowspan="1" colspan="1">ICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">GICP</td>
<td align="char" char="." rowspan="1" colspan="1">5.0</td>
<td align="char" char="." rowspan="1" colspan="1">5.0</td>
<td align="char" char="." rowspan="1" colspan="1">8.0</td>
<td align="char" char="." rowspan="1" colspan="1">9.0</td>
<td align="char" char="." rowspan="1" colspan="1">9.7</td>
<td align="char" char="." rowspan="1" colspan="1">8.3</td>
<td align="char" char="." rowspan="1" colspan="1">8.7</td>
<td align="char" char="." rowspan="1" colspan="1">5.3</td>
<td align="char" char="." rowspan="1" colspan="1">7.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Robust ICP</td>
<td align="char" char="." rowspan="1" colspan="1">10.0</td>
<td align="char" char="." rowspan="1" colspan="1">7.0</td>
<td align="char" char="." rowspan="1" colspan="1">9.7</td>
<td align="char" char="." rowspan="1" colspan="1">13.7</td>
<td align="char" char="." rowspan="1" colspan="1">11.0</td>
<td align="char" char="." rowspan="1" colspan="1">14.7</td>
<td align="char" char="." rowspan="1" colspan="1">12.7</td>
<td align="char" char="." rowspan="1" colspan="1">10.0</td>
<td align="char" char="." rowspan="1" colspan="1">11.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">CPD</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">2.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">2.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP</td>
<td align="char" char="." rowspan="1" colspan="1">2.7</td>
<td align="char" char="." rowspan="1" colspan="1">4.3</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">4.7</td>
<td align="char" char="." rowspan="1" colspan="1">6.7</td>
<td align="char" char="." rowspan="1" colspan="1">4.7</td>
<td align="char" char="." rowspan="1" colspan="1">5.7</td>
<td align="char" char="." rowspan="1" colspan="1">3.7</td>
<td align="char" char="." rowspan="1" colspan="1">3.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">5B-iv</td>
<td align="left" rowspan="1" colspan="1">30%</td>
<td align="left" rowspan="1" colspan="1">ICP</td>
<td align="char" char="." rowspan="1" colspan="1">2.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">1.3</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.7</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">GICP</td>
<td align="char" char="." rowspan="1" colspan="1">15.0</td>
<td align="char" char="." rowspan="1" colspan="1">17.7</td>
<td align="char" char="." rowspan="1" colspan="1">12.3</td>
<td align="char" char="." rowspan="1" colspan="1">17.7</td>
<td align="char" char="." rowspan="1" colspan="1">19.3</td>
<td align="char" char="." rowspan="1" colspan="1">20.7</td>
<td align="char" char="." rowspan="1" colspan="1">18.3</td>
<td align="char" char="." rowspan="1" colspan="1">21.7</td>
<td align="char" char="." rowspan="1" colspan="1">20.7</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">Robust ICP</td>
<td align="char" char="." rowspan="1" colspan="1">16.3</td>
<td align="char" char="." rowspan="1" colspan="1">10.0</td>
<td align="char" char="." rowspan="1" colspan="1">15.3</td>
<td align="char" char="." rowspan="1" colspan="1">15.3</td>
<td align="char" char="." rowspan="1" colspan="1">16.0</td>
<td align="char" char="." rowspan="1" colspan="1">15.3</td>
<td align="char" char="." rowspan="1" colspan="1">12.7</td>
<td align="char" char="." rowspan="1" colspan="1">17.0</td>
<td align="char" char="." rowspan="1" colspan="1">16.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">CPD</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">3.3</td>
<td align="char" char="." rowspan="1" colspan="1">3.3</td>
<td align="char" char="." rowspan="1" colspan="1">3.7</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">2.0</td>
<td align="char" char="." rowspan="1" colspan="1">1.7</td>
<td align="char" char="." rowspan="1" colspan="1">2.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1"/>
<td align="left" rowspan="1" colspan="1">IMLP</td>
<td align="char" char="." rowspan="1" colspan="1">18.7</td>
<td align="char" char="." rowspan="1" colspan="1">12.0</td>
<td align="char" char="." rowspan="1" colspan="1">16.0</td>
<td align="char" char="." rowspan="1" colspan="1">16.7</td>
<td align="char" char="." rowspan="1" colspan="1">19.0</td>
<td align="char" char="." rowspan="1" colspan="1">20.7</td>
<td align="char" char="." rowspan="1" colspan="1">15.3</td>
<td align="char" char="." rowspan="1" colspan="1">16.7</td>
<td align="char" char="." rowspan="1" colspan="1">15.7</td>
</tr>
</tbody>
</table>
</alternatives>
<table-wrap-foot>
<fn id="t010fn001">
<p>Source shapes were randomly generated from a mesh model of a human hip (<xref ref-type="fig" rid="pone.0117688.g001">Fig. 1A</xref>), misaligned by [15, 30] mm / degrees in (Experiment 5A) and [30, 60] mm / degrees in (Experiment 5B), and registered back to a point-cloud representation of the mesh. The test cases represent the different noise models used to generate noise on the source shape (<xref ref-type="table" rid="pone.0117688.t004">Table 4</xref>). Outliers were added to the source shape constituting 5% (-i), 10% (-ii), 20% (-iii), and 30% (-iv) of the source points. For each test case, 300 randomized trials were conducted with the percent of unsuccessful registrations (TRE &gt; 10 mm) being shown in the table. The proposed IMLP algorithm was evaluated relative to standard ICP [<xref ref-type="bibr" rid="pone.0117688.ref001">1</xref>], GICP [<xref ref-type="bibr" rid="pone.0117688.ref011">11</xref>], a robust variant of ICP [<xref ref-type="bibr" rid="pone.0117688.ref004">4</xref>], and CPD [<xref ref-type="bibr" rid="pone.0117688.ref020">20</xref>].</p></fn>
</table-wrap-foot>
</table-wrap>
</sec>
<sec id="sec003f">
<title>Experiment 6: Sub-Shape Registration</title>
<p>This study investigates the more challenging problem of registering sub-shape data to a complete-shape model, which arises when measurements are taken from a sub-region of a shape to be registered. This scenario is investigated by simulating random measurements from a sub-region of a proximal human femur that has been segmented from CT imaging to form a mesh of the bone surface (<xref ref-type="fig" rid="pone.0117688.g001">Fig. 1B</xref>).</p>
<p>The experimental procedure for this study parallels that of Experiment 4, except that the area sampled for the source shape is confined to a sub-region of the target, which is represented by the darkly shaded region of the mesh in <xref ref-type="fig" rid="pone.0117688.g001">Fig. 1B</xref>. Random misalignments for this study are generated on the interval [10, 20] mm translation and [10, 20] degrees rotation. The same algorithms as in Experiment 4 are evaluated using identical settings except that the maximum iteration count for CPD was increased to 200, as 100 iterations was insufficient (other algorithms did not require this increase).</p>
<p>In order to diversify the range of noise conditions considered overall, a different set of noise conditions was investigated for this study. <xref ref-type="table" rid="pone.0117688.t011">Table 11</xref> defines the seven noise models investigated, which includes the zero-noise case, two magnitudes of isotropic noise, two cases of surface-oriented noise to test high variance in both surface-normal and surface-parallel directions, and two test cases involving randomly oriented noise models applied at a global and at a per-point scale. For the test cases involving randomly oriented noise models, different covariances were randomly generated for each trial. As in the prior experiments, 300 randomized trials were conducted for each test case.</p>
<table-wrap id="pone.0117688.t011" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0117688.t011</object-id>
<label>Table 11</label>
<caption>
<title>Generative noise models (test cases) used in the randomized registration trials of Experiment 6.</title>
</caption>
<alternatives>
<graphic id="pone.0117688.t011g" mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.t011"/>
<table frame="box" rules="all" border="0">
<colgroup span="1">
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
</colgroup>
<thead>
<tr>
<th align="left" rowspan="1" colspan="1"><bold>Noise Covariance</bold></th>
<th align="center" colspan="7" rowspan="1"><bold>Test Case</bold></th>
</tr>
<tr>
<th align="left" rowspan="1" colspan="1"/>
<th align="left" rowspan="1" colspan="1"><bold>1</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>2</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>3</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>4</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>5</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>6</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>7</bold></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" rowspan="1" colspan="1">Orientation</td>
<td align="left" rowspan="1" colspan="1">-</td>
<td align="left" rowspan="1" colspan="1">-</td>
<td align="left" rowspan="1" colspan="1">-</td>
<td align="left" rowspan="1" colspan="1">Surface</td>
<td align="left" rowspan="1" colspan="1">Surface</td>
<td align="left" rowspan="1" colspan="1">Random-Global</td>
<td align="left" rowspan="1" colspan="1">Random-Per-Point</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">Magnitude: <inline-formula id="pone.0117688.e135"><mml:math id="M135" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>λ</mml:mi> <mml:mn>1</mml:mn> <mml:mrow><mml:mn>1</mml:mn> <mml:mo>/</mml:mo> <mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> (mm)</td>
<td align="left" rowspan="1" colspan="1">0.0</td>
<td align="left" rowspan="1" colspan="1">0.5</td>
<td align="left" rowspan="1" colspan="1">1.0</td>
<td align="left" rowspan="1" colspan="1">1.0</td>
<td align="left" rowspan="1" colspan="1">0.5</td>
<td align="left" rowspan="1" colspan="1">0.5</td>
<td align="left" rowspan="1" colspan="1">0.5</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">Magnitude: <inline-formula id="pone.0117688.e136"><mml:math id="M136" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>λ</mml:mi> <mml:mrow><mml:mn>2</mml:mn> <mml:mo>,</mml:mo> <mml:mn>3</mml:mn></mml:mrow> <mml:mrow><mml:mn>1</mml:mn> <mml:mo>/</mml:mo> <mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> (mm)</td>
<td align="left" rowspan="1" colspan="1">0.0</td>
<td align="left" rowspan="1" colspan="1">0.5</td>
<td align="left" rowspan="1" colspan="1">1.0</td>
<td align="left" rowspan="1" colspan="1">0.5</td>
<td align="left" rowspan="1" colspan="1">1.0</td>
<td align="left" rowspan="1" colspan="1">1.0</td>
<td align="left" rowspan="1" colspan="1">1.0</td>
</tr>
</tbody>
</table>
</alternatives>
<table-wrap-foot>
<fn id="t011fn001">
<p>This table defines the covariances used to generate the zero-mean, multi-variate, Gaussian noise applied to the source shape in each test case of Experiment 6. The table defines both the eigenvalues (<italic>λ</italic><sub>1</sub>, <italic>λ</italic><sub>2</sub>, <italic>λ</italic><sub>3</sub>) (magnitude) and the eigenvectors (orientation) of the covariance matrices for each test case. Orientation “Surface” defines the eigenvectors relative to the orientation of the surface at each source point, where <italic>λ</italic><sub>1</sub> is the variance in the surface-normal direction and (<italic>λ</italic><sub>2</sub>, <italic>λ</italic><sub>3</sub>) are the variances in the surface-parallel directions. Orientation “Random-Global” defines the matrix of eigenvectors to be a randomly generated rotation matrix, which is applied globally over the source shape (i.e. every point in the source shape has the same noise model). Orientation “Random-Per-Point” is similar to the “Random-Global” case except that every point in the source shape is associated with a different randomly generated rotation (i.e. every point in the source shape has a different noise model). Orientation “-” means that the noise model is isotropic and thus unaffected by the choice of eigenvectors.</p></fn>
</table-wrap-foot>
</table-wrap>
<p><xref ref-type="fig" rid="pone.0117688.g008">Fig. 8</xref> shows the registration errors and <xref ref-type="table" rid="pone.0117688.t012">Table 12</xref> presents the registration failure rates achieved by each algorithm in this study. The standard ICP algorithm turns out poor performance across the board in terms of both registration error (above 3.5 mm) and failure rate (approximately 11–19%). CPD has the best success rate with almost no failures overall. The failure rates of other anisotropic methods are approximately on-par with the IMLP failure rate of 3–7%, with the IMLP-CP variant being marginally lower than the others. As seen in the figure, IMLP achieves the lowest registration error in every test case. Compared to CPD the improvement in registration error by IMLP is often substantial, especially for the zero-noise case where IMLP achieves nearly zero registration error and CPD has an average TRE near 1 mm. Again, we find that the Mahalanobis-distance match criterion, as assessed by IMLP-MD, computes substantially worse registration error than the closest-point match criterion, as assessed by IMLP-CP and as also used by GICP; on the other hand, the most-likely match criterion of IMLP achieves the lowest registration error in every case.</p>
<fig id="pone.0117688.g008" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0117688.g008</object-id>
<label>Fig 8</label>
<caption>
<title>Registration errors for registering a sub-shape. (Experiment 6).</title>
<p>Source shapes were randomly generated from a sub-region of a mesh model of a human proximal femur (<xref ref-type="fig" rid="pone.0117688.g001">Fig. 1B</xref>), misaligned by [10, 20] mm / degrees, and registered back to a point-cloud representation of the mesh. The test cases represent the different noise models used to generate noise on the source shape (<xref ref-type="table" rid="pone.0117688.t011">Table 11</xref>). For each test case, 300 randomized trials were conducted, with successful registrations being used to compute an average target registration error (TRE). The error bars provide approximate standard deviations of the reported average TRE values. The proposed IMLP algorithm was evaluated relative to standard ICP [<xref ref-type="bibr" rid="pone.0117688.ref001">1</xref>], GICP [<xref ref-type="bibr" rid="pone.0117688.ref011">11</xref>], and CPD [<xref ref-type="bibr" rid="pone.0117688.ref020">20</xref>], as well as relative to near-comparisons of GTLS-ICP [<xref ref-type="bibr" rid="pone.0117688.ref010">10</xref>] and A-ICP [<xref ref-type="bibr" rid="pone.0117688.ref012">12</xref>] using the two variants IMLP-CP and IMLP-MD, which modify IMLP’s most-likely match criteria to that of closest-point and Mahalanobis-distance matching, respectively.</p>
</caption>
<graphic mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.g008"/>
</fig>
<table-wrap id="pone.0117688.t012" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0117688.t012</object-id>
<label>Table 12</label>
<caption>
<title>Registration failure rates for sub-shape registration. (Experiment 6).</title>
</caption>
<alternatives>
<graphic id="pone.0117688.t012g" mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.t012"/>
<table frame="box" rules="all" border="0">
<colgroup span="1">
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
</colgroup>
<thead>
<tr>
<th align="left" rowspan="1" colspan="1"><bold>Alg.</bold></th>
<th align="center" colspan="7" rowspan="1"><bold>Failure Rate (%) by Test Case</bold></th>
</tr>
<tr>
<th align="left" rowspan="1" colspan="1"/>
<th align="left" rowspan="1" colspan="1"><bold>1</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>2</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>3</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>4</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>5</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>6</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>7</bold></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" rowspan="1" colspan="1">ICP</td>
<td align="char" char="." rowspan="1" colspan="1">15.0</td>
<td align="left" rowspan="1" colspan="1">10.7</td>
<td align="char" char="." rowspan="1" colspan="1">17.3</td>
<td align="char" char="." rowspan="1" colspan="1">13.7</td>
<td align="char" char="." rowspan="1" colspan="1">14.7</td>
<td align="char" char="." rowspan="1" colspan="1">18.7</td>
<td align="char" char="." rowspan="1" colspan="1">16.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">IMLP-CP</td>
<td align="char" char="." rowspan="1" colspan="1">4.7</td>
<td align="left" rowspan="1" colspan="1">2</td>
<td align="char" char="." rowspan="1" colspan="1">5.3</td>
<td align="char" char="." rowspan="1" colspan="1">4.3</td>
<td align="char" char="." rowspan="1" colspan="1">4.3</td>
<td align="char" char="." rowspan="1" colspan="1">4.3</td>
<td align="char" char="." rowspan="1" colspan="1">4.0</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">IMLP-MD</td>
<td align="char" char="." rowspan="1" colspan="1">6.0</td>
<td align="left" rowspan="1" colspan="1">3.3</td>
<td align="char" char="." rowspan="1" colspan="1">7.3</td>
<td align="char" char="." rowspan="1" colspan="1">5.3</td>
<td align="char" char="." rowspan="1" colspan="1">7.0</td>
<td align="char" char="." rowspan="1" colspan="1">6.7</td>
<td align="char" char="." rowspan="1" colspan="1">5.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">GICP</td>
<td align="char" char="." rowspan="1" colspan="1">6.0</td>
<td align="left" rowspan="1" colspan="1">4.3</td>
<td align="char" char="." rowspan="1" colspan="1">8.3</td>
<td align="char" char="." rowspan="1" colspan="1">6.3</td>
<td align="char" char="." rowspan="1" colspan="1">6.0</td>
<td align="char" char="." rowspan="1" colspan="1">5.3</td>
<td align="char" char="." rowspan="1" colspan="1">4.7</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">CPD</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="left" rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.0</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
<td align="char" char="." rowspan="1" colspan="1">0.3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">IMLP</td>
<td align="char" char="." rowspan="1" colspan="1">6.0</td>
<td align="left" rowspan="1" colspan="1">3.0</td>
<td align="char" char="." rowspan="1" colspan="1">7.0</td>
<td align="char" char="." rowspan="1" colspan="1">5.0</td>
<td align="char" char="." rowspan="1" colspan="1">6.0</td>
<td align="char" char="." rowspan="1" colspan="1">6.3</td>
<td align="char" char="." rowspan="1" colspan="1">5.0</td>
</tr>
</tbody>
</table>
</alternatives>
<table-wrap-foot>
<fn id="t012fn001">
<p>Source shapes were randomly generated from from a mesh model of a human femur (<xref ref-type="fig" rid="pone.0117688.g001">Fig. 1B</xref>), misaligned by [10, 20] mm / degrees, and registered back to a point-cloud representation of the mesh. The test cases represent different noise models used to generate noise on the source shape (<xref ref-type="table" rid="pone.0117688.t011">Table 11</xref>). For each test case, 300 randomized trials were conducted with the percent of unsuccessful registrations (TRE &gt; 10 mm) being shown in the table. The proposed IMLP algorithm was evaluated relative to standard ICP [<xref ref-type="bibr" rid="pone.0117688.ref001">1</xref>], GICP [<xref ref-type="bibr" rid="pone.0117688.ref011">11</xref>], and CPD [<xref ref-type="bibr" rid="pone.0117688.ref020">20</xref>], as well as relative to near-comparisons of GTLS-ICP [<xref ref-type="bibr" rid="pone.0117688.ref010">10</xref>] and A-ICP [<xref ref-type="bibr" rid="pone.0117688.ref012">12</xref>] using the two IMLP variants IMLP-CP and IMLP-MD, which modify IMLP’s most-likely match criteria to that of closest-point and Mahalanobis-distance matching, respectively.</p></fn>
</table-wrap-foot>
</table-wrap>
</sec>
<sec id="sec003g">
<title>Experiment 7: Registering Shapes with Partial Overlap</title>
<p>This study investigates a yet more challenging problem of registering two shapes that have only partial overlap, meaning there are regions of both the source and target shape that do not have any true correspondence with the other shape. To investigate this scenario, we use a model of the statue Laurana (<xref ref-type="fig" rid="pone.0117688.g009">Fig. 9A</xref>) provided by the Institute of Science and Technologies (ISTI-CNR), Pisa, Italy, which was downloaded under a Creative Commons License from <ext-link ext-link-type="uri" xlink:href="http://vcg.isti.cnr.it/downloads/3dgallery/form_laurana.htm" xlink:type="simple">http://vcg.isti.cnr.it/downloads/3dgallery/form_laurana.htm</ext-link>. A decimation was applied to the original mesh using the Quadric Edge Collapse Decimation in MeshLab [<xref ref-type="bibr" rid="pone.0117688.ref042">42</xref>] to reduce the model to 50,000 triangles, and the coordinate system was adjusted to position the origin at the mesh centroid. Two divisions of the mesh were then performed to extract the front (<xref ref-type="fig" rid="pone.0117688.g009">Fig. 9B</xref>) and right (<xref ref-type="fig" rid="pone.0117688.g009">Fig. 9C</xref>) half-sections of the model. A dense point cloud for the source shape was formed from the vertices of the right half-section, and a dense point cloud for the target shape was defined from the center points of the triangles of the front half-section. Thus, the region of overlap between the source and target shapes comprised 50% of each shape (<xref ref-type="fig" rid="pone.0117688.g009">Fig. 9D</xref>).</p>
<fig id="pone.0117688.g009" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0117688.g009</object-id>
<label>Fig 9</label>
<caption>
<title>Registration of shapes having partial overlap. (Experiment 7).</title>
<p>(A): The statue Laurana sub-divided into (B): front and (C): right half-sections, such that (D): a 50% overlap exists between the two sub-shapes. The sub-shapes were (E): misaligned by 10 mm and 10 degrees in a random direction and then registered using (F): CPD [<xref ref-type="bibr" rid="pone.0117688.ref020">20</xref>], (G): GICP [<xref ref-type="bibr" rid="pone.0117688.ref011">11</xref>], and (H): the proposed IMLP algorithm. Sub-figures (E-H) show the initial misalignment and the final registered alignments of the two shapes for the 6th randomized trial of Experiment 7, which involved 10 randomized trials in total.</p>
</caption>
<graphic mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.g009"/>
</fig>
<p>Ten randomized registration trials were performed by applying 0.5 mm standard deviation of isotropic Gaussian noise to the source points and applying misalignments of 10 mm and 10 degrees in random directions. Validation points for computing the TRE were selected randomly from the target shape, not being confined to the region of overlap.</p>
<p>The algorithms evaluated in this study were GICP [<xref ref-type="bibr" rid="pone.0117688.ref011">11</xref>], CPD [<xref ref-type="bibr" rid="pone.0117688.ref020">20</xref>], and IMLP. Various values were experimentally tested for the match threshold distance of GICP, with 3 mm finally selected as having the lowest TRE. For CPD, various outlier weights were tested with poor results obtained in every case; we therefore applied the standard outlier weight of 0.5. For IMLP, we used the default chi-square inverse CDF threshold (<inline-formula id="pone.0117688.e137"><mml:math id="M137" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>χ</mml:mi> <mml:mtext mathvariant="normal">thresh</mml:mtext> <mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula>) value of 7.81. To minimize bias from the non-overlapping region, matches identified as outliers were configured to be completely disregarded in the registration phase of the IMLP algorithm (rather than inflating their variances), as suggested in the Methods section for this type of application. The measurement-error covariances of IMLP were set to zero in this study in order to, as much as possible, enable the noise model to adapt to the region of overlap based on the match uncertainty term. To restrict “good” matches to the region of overlap, the max threshold for the match uncertainty parameter (<inline-formula id="pone.0117688.e138"><mml:math id="M138" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi> <mml:mtext mathvariant="normal">max</mml:mtext> <mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula>) was set to 0.1 mm<sup>2</sup>. The surface-model covariances for both GICP and IMLP were set to the same values as used in Experiment 4.</p>
<p><xref ref-type="table" rid="pone.0117688.t013">Table 13</xref> shows the TREs computed by each algorithm for each of the 10 randomized trials. As indicated in the table, CPD is unable to properly register any of the trials in this scenario, whereas both IMLP and GICP register all of them nearly perfectly, with GICP having a moderate to slight accuracy advantage. The bottom row of <xref ref-type="fig" rid="pone.0117688.g009">Fig. 9</xref> provides a visualization of the initial shape misalignment (<xref ref-type="fig" rid="pone.0117688.g009">Fig. 9E</xref>) and of the registered alignments computed by each algorithm, including CPD (<xref ref-type="fig" rid="pone.0117688.g009">Fig. 9F</xref>), GICP (<xref ref-type="fig" rid="pone.0117688.g009">Fig. 9G</xref>), and IMLP (<xref ref-type="fig" rid="pone.0117688.g009">Fig. 9H</xref>). The visualizations of <xref ref-type="fig" rid="pone.0117688.g009">Figs. 9E-H</xref> represent the 6th randomized registration trial of this experiment.</p>
<table-wrap id="pone.0117688.t013" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0117688.t013</object-id>
<label>Table 13</label>
<caption>
<title>Registration errors for registering shapes having partial overlap. (Experiment 7).</title>
</caption>
<alternatives>
<graphic id="pone.0117688.t013g" mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.t013"/>
<table frame="box" rules="all" border="0">
<colgroup span="1">
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
</colgroup>
<thead>
<tr>
<th align="left" rowspan="1" colspan="1"><bold>Alg.</bold></th>
<th align="center" colspan="10" rowspan="1"><bold>TRE (mm) per Registration Trial</bold></th>
</tr>
<tr>
<th align="left" rowspan="1" colspan="1"/>
<th align="left" rowspan="1" colspan="1"><bold>1</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>2</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>3</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>4</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>5</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>6</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>7</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>8</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>9</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>10</bold></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" rowspan="1" colspan="1">CPD</td>
<td align="char" char="." rowspan="1" colspan="1">63.533</td>
<td align="char" char="." rowspan="1" colspan="1">69.988</td>
<td align="char" char="." rowspan="1" colspan="1">82.186</td>
<td align="char" char="." rowspan="1" colspan="1">83.449</td>
<td align="char" char="." rowspan="1" colspan="1">72.612</td>
<td align="char" char="." rowspan="1" colspan="1">71.378</td>
<td align="char" char="." rowspan="1" colspan="1">69.431</td>
<td align="char" char="." rowspan="1" colspan="1">79.822</td>
<td align="char" char="." rowspan="1" colspan="1">78.071</td>
<td align="char" char="." rowspan="1" colspan="1">68.675</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">GICP</td>
<td align="char" char="." rowspan="1" colspan="1">0.138</td>
<td align="char" char="." rowspan="1" colspan="1">0.150</td>
<td align="char" char="." rowspan="1" colspan="1">0.187</td>
<td align="char" char="." rowspan="1" colspan="1">0.060</td>
<td align="char" char="." rowspan="1" colspan="1">0.124</td>
<td align="char" char="." rowspan="1" colspan="1">0.165</td>
<td align="char" char="." rowspan="1" colspan="1">0.272</td>
<td align="char" char="." rowspan="1" colspan="1">0.252</td>
<td align="char" char="." rowspan="1" colspan="1">0.158</td>
<td align="char" char="." rowspan="1" colspan="1">0.242</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">IMLP</td>
<td align="char" char="." rowspan="1" colspan="1">0.264</td>
<td align="char" char="." rowspan="1" colspan="1">0.306</td>
<td align="char" char="." rowspan="1" colspan="1">0.283</td>
<td align="char" char="." rowspan="1" colspan="1">0.224</td>
<td align="char" char="." rowspan="1" colspan="1">0.352</td>
<td align="char" char="." rowspan="1" colspan="1">0.294</td>
<td align="char" char="." rowspan="1" colspan="1">0.295</td>
<td align="char" char="." rowspan="1" colspan="1">0.277</td>
<td align="char" char="." rowspan="1" colspan="1">0.250</td>
<td align="char" char="." rowspan="1" colspan="1">0.365</td>
</tr>
</tbody>
</table>
</alternatives>
<table-wrap-foot>
<fn id="t013fn001">
<p>Target registration error (TRE) is reported for each of 10 registration trials conducted for Experiment 7, which involve registering two half-sections of the statue Laurana that have 50% true overlap (<xref ref-type="fig" rid="pone.0117688.g009">Fig. 9D</xref>). The half-sections were randomly misaligned by 10 mm and 10 degrees and then registered using CPD [<xref ref-type="bibr" rid="pone.0117688.ref020">20</xref>], GICP [<xref ref-type="bibr" rid="pone.0117688.ref011">11</xref>], and the proposed IMLP algorithm.</p></fn>
</table-wrap-foot>
</table-wrap>
</sec>
<sec id="sec003h">
<title>Experiment 8: Runtime Comparison of Methods for Computing the Most-Likely Matches</title>
<p>As a final study, an investigation is made concerning the speedup afforded by the PD-tree search technique used to compute the most-likely matches for IMLP. We compare the runtime of a naive exhaustive search to that of the proposed PD-tree method using both the spherical (<xref ref-type="disp-formula" rid="pone.0117688.e075">14</xref>) and simple ellipsoidal (<xref ref-type="disp-formula" rid="pone.0117688.e076">15</xref>) bounding techniques, as described in the Methods section.</p>
<p><xref ref-type="table" rid="pone.0117688.t014">Table 14</xref> shows the average runtimes obtained from running IMLP over all 300 trials of Test Case 1 from Experiment 4B for each method of computing the most-likely matches. As seen in the table, the proposed PD-tree strategy achieves more than 140x speedup over the naive search when using the simple ellipsoidal bounding technique. Comparing the two alternative PD-tree bounding methods indicates that the more compact simple ellipsoidal bound achieves approximately 10% greater runtime efficiency than the spherical bound, even though its computations are significantly more complex.</p>
<table-wrap id="pone.0117688.t014" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0117688.t014</object-id>
<label>Table 14</label>
<caption>
<title>IMLP runtime comparison using different PD-tree bounding methods for computing the most-likely matches.</title>
</caption>
<alternatives>
<graphic id="pone.0117688.t014g" mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.t014"/>
<table frame="box" rules="all" border="0">
<colgroup span="1">
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
</colgroup>
<thead>
<tr>
<th align="left" rowspan="1" colspan="1"><bold>Search Method</bold></th>
<th align="left" rowspan="1" colspan="1">Naive Search</th>
<th align="left" rowspan="1" colspan="1">PD-Tree: Spherical Bound</th>
<th align="left" rowspan="1" colspan="1">PD-Tree: Simple Ellipsoidal Bound</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" rowspan="1" colspan="1"><bold>Runtime (sec.)</bold></td>
<td align="char" char="." rowspan="1" colspan="1">18.523</td>
<td align="char" char="." rowspan="1" colspan="1">0.141</td>
<td align="char" char="." rowspan="1" colspan="1">0.128</td>
</tr>
</tbody>
</table>
</alternatives>
<table-wrap-foot>
<fn id="t014fn001">
<p>Average runtimes are reported for the proposed IMLP algorithm over the 300 registration trials of Experiment 4B, Test Case 1, which involves registering 100 random samples to a point-cloud representation of a hip model (<xref ref-type="fig" rid="pone.0117688.g001">Fig. 1A</xref>). Runtimes were recorded for the naive exhaustive search and for the proposed PD-tree search strategy comparing two of the proposed PD-tree bounding methods: the spherical (<xref ref-type="disp-formula" rid="pone.0117688.e075">14</xref>) and simple ellipsoidal (<xref ref-type="disp-formula" rid="pone.0117688.e076">15</xref>) bounds. The compact ellipsoidal bound (<xref ref-type="disp-formula" rid="pone.0117688.e078">17</xref>) was not evaluated.</p></fn>
</table-wrap-foot>
</table-wrap>
<p>We note that the most compact ellipsoidal bound (<xref ref-type="disp-formula" rid="pone.0117688.e078">17</xref>), which is not evaluated here, may enable even further speedup over the simple ellipsoidal bound evaluated above. This is a likely outcome, since the runtime computations performed for each ellipsoidal bounding technique are very similar; thus, the most compact bound should provide the best performance.</p>
</sec>
</sec>
<sec id="sec004" sec-type="conclusions">
<title>Conclusions</title>
<p>We have presented a novel variant of the Iterative Closest Point (ICP) algorithm, called the Iterative Most-Likely Point (IMLP) algorithm, which has the ability to compute optimal shape alignment under anisotropic noise conditions by incorporating a probabilistic framework within both the correspondence and registration phases of the algorithm. Another advantage of this framework is the ability to model locally-linear regions of a continuous surface, as also done by prior methods, which greatly improves the registration accuracy attainable from discrete representations of a surface. Dynamic estimation of the match uncertainty enables IMLP to adaptively adjust its noise model to different levels of misalignment, which provides robustness under large initial misalignments and high accuracy and sensitivity to outliers when in the vicinity of the correct solution. In addition, the probabilistic underpinning provides a cohesive and flexible framework for detection and mitigation of outliers, as well as enabling registration of shapes having only partial overlap via a user-defined maximum threshold on the match uncertainty term.</p>
<p>Through an extensive set of experiments, involving more than 50,000 randomized executions of the IMLP algorithm alone, IMLP has been shown to possess significant registration accuracy and robustness advantages compared to long-established and recently introduced algorithms over a broad range of test conditions including various noise conditions, percentages of outliers, ranges of misalignment, and test shapes. Other algorithms evaluated include the long-established algorithm of standard ICP [<xref ref-type="bibr" rid="pone.0117688.ref001">1</xref>] and a robust ICP variant [<xref ref-type="bibr" rid="pone.0117688.ref004">4</xref>], as well as the more recent, leading algorithms of GICP [<xref ref-type="bibr" rid="pone.0117688.ref011">11</xref>] and CPD [<xref ref-type="bibr" rid="pone.0117688.ref020">20</xref>]. In addition, close comparison is made to the prior anisotropic registration methods of GTLS-ICP [<xref ref-type="bibr" rid="pone.0117688.ref010">10</xref>] and A-ICP [<xref ref-type="bibr" rid="pone.0117688.ref012">12</xref>] using modifications on our own method, IMLP-CP and IMLP-MD, respectively. Relative to all tested algorithms, IMLP demonstrated a clear accuracy advantage overall.</p>
<p>Compared to CPD, which has a very effective outlier mitigation capability, IMLP was demonstrated to achieve equivalent registration success rates for outlier percentages of 10% and below, with marginal to moderate relative increase in failure rate at 20% outliers and large relative increase at 30% outliers. On the other hand, in terms of the registration accuracy of successful trials, IMLP achieves significantly better or on-par accuracy compared to CPD for all levels of outliers studied (up to 30%). Based on our results, we conclude that IMLP is a very effective method for registering shapes with up to 10% outliers and retains excellent performance at 20% outliers for moderate levels of misalignment.</p>
<p>Only for the experiment involving registration of partially-overlapping shapes did another algorithm (GICP) clearly come ahead of IMLP in terms of registration accuracy. However, IMLP nonetheless demonstrated a strong performance in this scenario and achieved higher accuracy than GICP in all other experiments performed. Further, the CPD algorithm failed completely in this scenario.</p>
<p>A surprising outcome of our experiments reveal that the Mahalanobis-distance match criterion consistently performs worse than the closest-point match criterion for registrations involving point-cloud targets, whereas for the case of a mesh target the opposite is true. In contrast, the most-likely match criterion of IMLP provides the best performance in both scenarios. These observations were evaluated using two variants of IMLP—IMLP-CP and IMLP-MD— which incorporate the modified match criteria of closest-point and Mahalnobis-distance matching, respectively, all else being equal.</p>
<p>Although IMLP is several times slower than standard ICP, it nonetheless provides a very competitive runtime, considering the substantial reduction in registration error that it achieves. Compared to CPD (the next-best performing algorithm overall), IMLP achieves better registration accuracy in the majority of test cases considered, while being approximately two orders of magnitude more efficient. While IMLP is efficient enough to run on its own, further substantial speed-up could be easily obtained by initializing the registration with a faster algorithm such as standard ICP, as demonstrated in prior work [<xref ref-type="bibr" rid="pone.0117688.ref012">12</xref>]. Furthermore, the computations performed by IMLP are highly parallelizable and may be efficiently implemented on a GPU as also demonstrated in prior work regarding ICP-based algorithms [<xref ref-type="bibr" rid="pone.0117688.ref043">43</xref>]. Finally, since we have used the simple ellipsoidal bounding method (<xref ref-type="disp-formula" rid="pone.0117688.e076">15</xref>) for the PD-tree search in our implementation, further speedup may be possible by implementing the more compact ellipsoidal bound of (<xref ref-type="disp-formula" rid="pone.0117688.e078">17</xref>).</p>
<p>As alluded to in the foregoing paragraph, we have also presented in this paper an effective and novel search strategy for computing the most-likely matches on a target shape with respect to IMLP’s most-likely match criterion. As demonstrated in our results, the proposed search strategy provides a massive speedup (&gt;140x) over a naive search. This speedup is a key enabler of the efficient runtime performance achieved by IMLP. While this search strategy was devised to compute point correspondences based on the most-likely match criterion of IMLP, our method is equally applicable to the anisotropic Mahalanobis-distance match criterion of A-ICP.</p>
<p>In this paper, we have also presented an alternative approach for solving the generalized total-least-squares (GTLS) problem of aligning two corresponding point sets under a generalized noise model. The proposed approach turns out to be that of a Gauss-Newton-based method, which we have demonstrated to be more accurate, efficient, and stable compared to prior solutions proposed for this problem. The proposed approach supports anisotropic error in both sets of points being registered and is easily implemented using a standard least-squares solver, which avoids the software dependency of a nonlinear optimization library. In addition to its incorporation within the IMLP algorithm, our GTLS registration approach may also be used to implement related algorithms that incorporate generalized noise models, such as GICP.</p>
<p>In future work, we will investigate use of the compact ellipsoidal bounding method (<xref ref-type="disp-formula" rid="pone.0117688.e078">17</xref>) for the PD-tree search to determine what added speedup may be gained by incorporating this improved bound. It will also be interesting to further investigate the problem of registering partially-overlapping shapes to determine how the performance of IMLP may be improved to that of GICP for this particular scenario.</p>
</sec>
<sec id="sec005">
<title>Supporting Information</title>
<supplementary-material id="pone.0117688.s001" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.s001" mimetype="application/pdf" xlink:type="simple">
<label>S1 Appendix</label>
<caption>
<title>Computing the Point of Most-Likely Correspondence on a PD-Tree Datum.</title>
<p>(PDF)</p>
</caption>
</supplementary-material>
<supplementary-material id="pone.0117688.s002" position="float" xlink:href="info:doi/10.1371/journal.pone.0117688.s002" mimetype="application/pdf" xlink:type="simple">
<label>S2 Appendix</label>
<caption>
<title>Equivalent Forms for the Generalized Total-Least-Squares (GTLS) Problem of Aligning Corresponding Point Sets.</title>
<p>(PDF)</p>
</caption>
</supplementary-material>
</sec>
</body>
<back>
<ack>
<p>The authors would like to thank our anonymous reviewers for their helpful insights and suggestions, which have improved the clarity and strengthened the content of this manuscript</p>
</ack>
<ref-list>
<title>References</title>
<ref id="pone.0117688.ref001">
<label>1</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Besl</surname> <given-names>PJ</given-names></name>, <name name-style="western"><surname>McKay</surname> <given-names>ND</given-names></name> (<year>1992</year>) <article-title>A method for registration of 3-D shapes</article-title>. <source>Pattern Anal Mach Intell IEEE Trans</source> <volume>14</volume>: <fpage>239</fpage>–<lpage>256</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1109/34.121791" xlink:type="simple">10.1109/34.121791</ext-link></comment></mixed-citation>
</ref>
<ref id="pone.0117688.ref002">
<label>2</label>
<mixed-citation xlink:type="simple" publication-type="other">Samet H (2006) Foundations of multidimensional and metric data structures. Morgan Kaufmann.</mixed-citation>
</ref>
<ref id="pone.0117688.ref003">
<label>3</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Chen</surname> <given-names>Y</given-names></name>, <name name-style="western"><surname>Medioni</surname> <given-names>G</given-names></name> (<year>1992</year>) <article-title>Object modelling by registration of multiple range images</article-title>. <source>Image Vis Comput</source> <volume>10</volume>: <fpage>145</fpage>–<lpage>155</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1016/0262-8856(92)90066-C" xlink:type="simple">10.1016/0262-8856(92)90066-C</ext-link></comment></mixed-citation>
</ref>
<ref id="pone.0117688.ref004">
<label>4</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Zhang</surname> <given-names>Z</given-names></name> (<year>1994</year>) <article-title>Iterative point matching for registration of free-form curves and surfaces</article-title>. <source>Int J Comput Vis</source> <volume>13</volume>: <fpage>119</fpage>–<lpage>152</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1007/BF01427149" xlink:type="simple">10.1007/BF01427149</ext-link></comment></mixed-citation>
</ref>
<ref id="pone.0117688.ref005">
<label>5</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Maurer</surname> <given-names>CR</given-names> <suffix>Jr</suffix></name>, <name name-style="western"><surname>Aboutanos</surname> <given-names>GB</given-names></name>, <name name-style="western"><surname>Dawant</surname> <given-names>BM</given-names></name>, <name name-style="western"><surname>Maciunas</surname> <given-names>RJ</given-names></name>, <name name-style="western"><surname>Fitzpatrick</surname> <given-names>JM</given-names></name> (<year>1996</year>) <article-title>Registration of 3-D images using weighted geometrical features</article-title>. <source>Med Imaging, IEEE Trans</source> <volume>15</volume>: <fpage>836</fpage>–<lpage>849</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1109/42.544501" xlink:type="simple">10.1109/42.544501</ext-link></comment></mixed-citation>
</ref>
<ref id="pone.0117688.ref006">
<label>6</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Sharp</surname> <given-names>GC</given-names></name>, <name name-style="western"><surname>Lee</surname> <given-names>SW</given-names></name>, <name name-style="western"><surname>Wehe</surname> <given-names>DK</given-names></name> (<year>2002</year>) <article-title>ICP registration using invariant features</article-title>. <source>Pattern Anal Mach Intell IEEE Trans</source> <volume>24</volume>: <fpage>90</fpage>–<lpage>102</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1109/34.982886" xlink:type="simple">10.1109/34.982886</ext-link></comment></mixed-citation>
</ref>
<ref id="pone.0117688.ref007">
<label>7</label>
<mixed-citation xlink:type="simple" publication-type="other">Armesto L, Minguez J, Montesano L (2010) A generalization of the metric-based iterative closest point technique for 3D scan matching. In: Robot. Autom. (ICRA), 2010 IEEE Int. Conf. IEEE, pp. 1367–1372.</mixed-citation>
</ref>
<ref id="pone.0117688.ref008">
<label>8</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Minguez</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Montesano</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Lamiraux</surname> <given-names>F</given-names></name> (<year>2006</year>) <article-title>Metric-based iterative closest point scan matching for sensor displacement estimation</article-title>. <source>Robot IEEE Trans</source> <volume>22</volume>: <fpage>1047</fpage>–<lpage>1054</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1109/TRO.2006.878961" xlink:type="simple">10.1109/TRO.2006.878961</ext-link></comment></mixed-citation>
</ref>
<ref id="pone.0117688.ref009">
<label>9</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Fitzgibbon</surname> <given-names>AW</given-names></name> (<year>2003</year>) <article-title>Robust registration of 2D and 3D point sets</article-title>. <source>Image Vis Comput</source> <volume>21</volume>: <fpage>1145</fpage>–<lpage>1153</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1016/j.imavis.2003.09.004" xlink:type="simple">10.1016/j.imavis.2003.09.004</ext-link></comment></mixed-citation>
</ref>
<ref id="pone.0117688.ref010">
<label>10</label>
<mixed-citation xlink:type="simple" publication-type="book">
<name name-style="western"><surname>Estépar</surname> <given-names>RSJ</given-names></name>, <name name-style="western"><surname>Brun</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Westin</surname> <given-names>CF</given-names></name> (<year>2004</year>) <chapter-title>Robust generalized total least squares iterative closest point registration</chapter-title>. In: <source>Med. Image Comput. Comput. Interv. 2004</source>, <publisher-name>Springer</publisher-name>. pp. <fpage>234</fpage>–<lpage>241</lpage>.</mixed-citation>
</ref>
<ref id="pone.0117688.ref011">
<label>11</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Segal</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Haehnel</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Thrun</surname> <given-names>S</given-names></name> (<year>2009</year>) <article-title>Generalized-ICP</article-title>. In: <source>Robot. Sci. Syst.</source> <volume>volume 2</volume>.</mixed-citation>
</ref>
<ref id="pone.0117688.ref012">
<label>12</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Maier-Hein</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Franz</surname> <given-names>AM</given-names></name>, <name name-style="western"><surname>Dos Santos</surname> <given-names>TR</given-names></name>, <name name-style="western"><surname>Schmidt</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Fangerau</surname> <given-names>M</given-names></name>, <etal>et al</etal>. (<year>2012</year>) <article-title>Convergent iterative closest-point algorithm to accomodate anisotropic and inhomogenous localization error</article-title>. <source>IEEE Trans Pattern Anal Mach Intell</source> <volume>34</volume>: <fpage>1520</fpage>–<lpage>1532</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1109/TPAMI.2011.248" xlink:type="simple">10.1109/TPAMI.2011.248</ext-link></comment> <object-id pub-id-type="pmid">22184256</object-id></mixed-citation>
</ref>
<ref id="pone.0117688.ref013">
<label>13</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Moghari</surname> <given-names>MH</given-names></name>, <name name-style="western"><surname>Abolmaesumi</surname> <given-names>P</given-names></name> (<year>2007</year>) <article-title>Point-based rigid-body registration using an unscented Kalman filter</article-title>. <source>Med Imaging, IEEE Trans</source> <volume>26</volume>: <fpage>1708</fpage>–<lpage>1728</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1109/TMI.2007.901984" xlink:type="simple">10.1109/TMI.2007.901984</ext-link></comment></mixed-citation>
</ref>
<ref id="pone.0117688.ref014">
<label>14</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Nazem</surname> <given-names>F</given-names></name>, <name name-style="western"><surname>Ahmadian</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Seraj</surname> <given-names>ND</given-names></name>, <name name-style="western"><surname>Giti</surname> <given-names>M</given-names></name> (<year>2014</year>) <article-title>Two-stage point-based registration method between ultrasound and CT imaging of the liver based on ICP and unscented Kalman filter: a phantom study</article-title>. <source>Int J Comput Assist Radiol Surg</source> <volume>9</volume>: <fpage>39</fpage>–<lpage>48</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1007/s11548-013-0907-6" xlink:type="simple">10.1007/s11548-013-0907-6</ext-link></comment> <object-id pub-id-type="pmid">23784223</object-id></mixed-citation>
</ref>
<ref id="pone.0117688.ref015">
<label>15</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Pennec</surname> <given-names>X</given-names></name>, <name name-style="western"><surname>Thirion</surname> <given-names>JP</given-names></name> (<year>1997</year>) <article-title>A framework for uncertainty and validation of 3-D registration methods based on points and frames</article-title>. <source>Int J Comput Vis</source> <volume>25</volume>: <fpage>203</fpage>–<lpage>229</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1023/A:1007976002485" xlink:type="simple">10.1023/A:1007976002485</ext-link></comment></mixed-citation>
</ref>
<ref id="pone.0117688.ref016">
<label>16</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Gold</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Rangarajan</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Lu</surname> <given-names>CP</given-names></name>, <name name-style="western"><surname>Pappu</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Mjolsness</surname> <given-names>E</given-names></name> (<year>1998</year>) <article-title>New algorithms for 2d and 3d point matching: pose estimation and correspondence</article-title>. <source>Pattern Recognit</source> <volume>31</volume>: <fpage>1019</fpage>–<lpage>1031</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1016/S0031-3203(98)80010-1" xlink:type="simple">10.1016/S0031-3203(98)80010-1</ext-link></comment></mixed-citation>
</ref>
<ref id="pone.0117688.ref017">
<label>17</label>
<mixed-citation xlink:type="simple" publication-type="other">Chui H, Rangarajan A (2000) A feature registration framework using mixture models. In: Math. Methods Biomed. Image Anal. 2000. Proceedings. IEEE Work. IEEE, pp. 190–197.</mixed-citation>
</ref>
<ref id="pone.0117688.ref018">
<label>18</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Granger</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Xavier</surname> <given-names>P</given-names></name> (<year>2002</year>) <article-title>Multi-scale EM-ICP: a fast and robust approach for surface registration</article-title>. <source>Proc ECCV</source>: <fpage>418</fpage>–<lpage>432</lpage>.</mixed-citation>
</ref>
<ref id="pone.0117688.ref019">
<label>19</label>
<mixed-citation xlink:type="simple" publication-type="book">
<name name-style="western"><surname>Combès</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Prima</surname> <given-names>S</given-names></name> (<year>2010</year>) <chapter-title>An efficient EM-ICP algorithm for symmetric consistent non-linear registration of point sets</chapter-title>. In: <source>Med. Image Comput. Comput. Interv. 2010</source>, <publisher-name>Springer</publisher-name>. pp. <fpage>594</fpage>–<lpage>601</lpage>.</mixed-citation>
</ref>
<ref id="pone.0117688.ref020">
<label>20</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Myronenko</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Song</surname> <given-names>X</given-names></name> (<year>2010</year>) <article-title>Point set registration: coherent point drift</article-title>. <source>Pattern Anal Mach Intell IEEE Trans</source> <volume>32</volume>: <fpage>2262</fpage>–<lpage>2275</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1109/TPAMI.2010.46" xlink:type="simple">10.1109/TPAMI.2010.46</ext-link></comment></mixed-citation>
</ref>
<ref id="pone.0117688.ref021">
<label>21</label>
<mixed-citation xlink:type="simple" publication-type="book">
<name name-style="western"><surname>Tsin</surname> <given-names>Y</given-names></name>, <name name-style="western"><surname>Kanade</surname> <given-names>T</given-names></name> (<year>2004</year>) <chapter-title>A correlation-based approach to robust point set registration</chapter-title>. In: <source>Comput. Vision—ECCV 2004</source>, <publisher-name>Springer</publisher-name>. pp. <fpage>558</fpage>–<lpage>569</lpage>.</mixed-citation>
</ref>
<ref id="pone.0117688.ref022">
<label>22</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Jian</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Vemuri</surname> <given-names>BC</given-names></name> (<year>2011</year>) <article-title>Robust point set registration using gaussian mixture models</article-title>. <source>Pattern Anal Mach Intell IEEE Trans</source> <volume>33</volume>: <fpage>1633</fpage>–<lpage>1645</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1109/TPAMI.2010.223" xlink:type="simple">10.1109/TPAMI.2010.223</ext-link></comment></mixed-citation>
</ref>
<ref id="pone.0117688.ref023">
<label>23</label>
<mixed-citation xlink:type="simple" publication-type="book">
<name name-style="western"><surname>Verma</surname> <given-names>N</given-names></name>, <name name-style="western"><surname>Kpotufe</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Dasgupta</surname> <given-names>S</given-names></name> (<year>2009</year>) <chapter-title>Which spatial partition trees are adaptive to intrinsic dimension?</chapter-title> In: <source>Proc. Twenty-Fifth Conf. Uncertain. Artif. Intell</source>. <publisher-name>AUAI Press</publisher-name>, pp. <fpage>565</fpage>–<lpage>574</lpage>.</mixed-citation>
</ref>
<ref id="pone.0117688.ref024">
<label>24</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Williams</surname> <given-names>JP</given-names></name>, <name name-style="western"><surname>Taylor</surname> <given-names>RH</given-names></name>, <name name-style="western"><surname>Wolff</surname> <given-names>LB</given-names></name> (<year>1997</year>) <article-title>Augmented KD techniques for accelerated registration and distance measurement of surfaces</article-title>. In: <source>Comput. Aided Surg. Comput. Surg. Head Spine</source>. pp. <fpage>1</fpage>–<lpage>21</lpage>.</mixed-citation>
</ref>
<ref id="pone.0117688.ref025">
<label>25</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Horn</surname> <given-names>BKP</given-names></name> (<year>1987</year>) <source>Closed-form solution of absolute orientation using unit quaternions</source> <volume>4</volume>.</mixed-citation>
</ref>
<ref id="pone.0117688.ref026">
<label>26</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Arun</surname> <given-names>KS</given-names></name>, <name name-style="western"><surname>Huang</surname> <given-names>TS</given-names></name>, <name name-style="western"><surname>Blostein</surname> <given-names>SD</given-names></name> (<year>1987</year>) <article-title>Least-squares fitting of two 3-D point sets</article-title>. <source>Pattern Anal Mach Intell IEEE Trans</source> <volume>9</volume>: <fpage>698</fpage>–<lpage>700</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1109/TPAMI.1987.4767965" xlink:type="simple">10.1109/TPAMI.1987.4767965</ext-link></comment></mixed-citation>
</ref>
<ref id="pone.0117688.ref027">
<label>27</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Walker</surname> <given-names>MW</given-names></name>, <name name-style="western"><surname>Shao</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Volz</surname> <given-names>RA</given-names></name> (<year>1991</year>) <article-title>Estimating 3-D location parameters using dual number quaternions</article-title>. <source>CVGIP image Underst</source> <volume>54</volume>: <fpage>358</fpage>–<lpage>367</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1016/1049-9660(91)90036-O" xlink:type="simple">10.1016/1049-9660(91)90036-O</ext-link></comment></mixed-citation>
</ref>
<ref id="pone.0117688.ref028">
<label>28</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Ohta</surname> <given-names>N</given-names></name>, <name name-style="western"><surname>Kanatani</surname> <given-names>K</given-names></name> (<year>1998</year>) <article-title>Optimal estimation of three-dimensional rotation and reliability evaluation</article-title>. <source>IEICE Trans Inf Syst</source> <volume>81</volume>: <fpage>1247</fpage>–<lpage>1252</lpage>.</mixed-citation>
</ref>
<ref id="pone.0117688.ref029">
<label>29</label>
<mixed-citation xlink:type="simple" publication-type="book"><name name-style="western"><surname>Kanatani</surname> <given-names>K</given-names></name> (<year>2005</year>) <source>Statistical optimization for geometric computation: theory and practice</source>. <publisher-name>Courier Dover Publications</publisher-name>.</mixed-citation>
</ref>
<ref id="pone.0117688.ref030">
<label>30</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Matei</surname> <given-names>BC</given-names></name>, <name name-style="western"><surname>Meer</surname> <given-names>P</given-names></name> (<year>2006</year>) <article-title>Estimation of nonlinear errors-in-variables models for computer vision applications</article-title>. <source>Pattern Anal Mach Intell IEEE Trans</source> <volume>28</volume>: <fpage>1537</fpage>–<lpage>1552</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1109/TPAMI.2006.205" xlink:type="simple">10.1109/TPAMI.2006.205</ext-link></comment></mixed-citation>
</ref>
<ref id="pone.0117688.ref031">
<label>31</label>
<mixed-citation xlink:type="simple" publication-type="other">Balachandran R, Fitzpatrick JM (2009) Iterative solution for rigid-body point-based registration with anisotropic weighting. In: SPIE Med. Imaging. International Society for Optics and Photonics, pp. 72613D-72613D-10.</mixed-citation>
</ref>
<ref id="pone.0117688.ref032">
<label>32</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Danilchenko</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Fitzpatrick</surname> <given-names>JM</given-names></name> (<year>2011</year>) <article-title>General approach to first-order error prediction in rigid point registration</article-title>. <source>Med Imaging, IEEE Trans</source> <volume>30</volume>: <fpage>679</fpage>–<lpage>693</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1109/TMI.2011.2173637" xlink:type="simple">10.1109/TMI.2011.2173637</ext-link></comment></mixed-citation>
</ref>
<ref id="pone.0117688.ref033">
<label>33</label>
<mixed-citation xlink:type="simple" publication-type="book">
<name name-style="western"><surname>Rice</surname> <given-names>J</given-names></name> (<year>2006</year>) <chapter-title>Mathematical statistics and data analysis</chapter-title>. <source>Cengage Learning</source>, <edition>third edition</edition>.</mixed-citation>
</ref>
<ref id="pone.0117688.ref034">
<label>34</label>
<mixed-citation xlink:type="simple" publication-type="book">
<name name-style="western"><surname>Craig</surname> <given-names>JJ</given-names></name> (<year>2005</year>) <chapter-title>Introduction to robotics: mechanics and control</chapter-title>. <source>Pearson/Prentice Hall Upper Saddle River</source>, <publisher-loc>NJ, USA</publisher-loc>:.</mixed-citation>
</ref>
<ref id="pone.0117688.ref035">
<label>35</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Larsson</surname> <given-names>T</given-names></name> (<year>2008</year>) <article-title>An efficient ellipsoid-OBB intersection test</article-title>. <source>J Graph GPU, Game Tools</source> <volume>13</volume>: <fpage>31</fpage>–<lpage>43</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1080/2151237X.2008.10129253" xlink:type="simple">10.1080/2151237X.2008.10129253</ext-link></comment></mixed-citation>
</ref>
<ref id="pone.0117688.ref036">
<label>36</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Fiedler</surname> <given-names>M</given-names></name> (<year>1971</year>) <article-title>Bounds for the determinant of the sum of hermitian matrices</article-title>. <source>Proc Am Math Soc</source> <volume>30</volume>: <fpage>27</fpage>–<lpage>31</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1090/S0002-9939-1971-0286814-1" xlink:type="simple">10.1090/S0002-9939-1971-0286814-1</ext-link></comment></mixed-citation>
</ref>
<ref id="pone.0117688.ref037">
<label>37</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Yildirim</surname> <given-names>EA</given-names></name> (<year>2006</year>) <article-title>On the minimum volume covering ellipsoid of ellipsoids</article-title>. <source>SIAM J Optim</source> <volume>17</volume>: <fpage>621</fpage>–<lpage>641</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1137/050622560" xlink:type="simple">10.1137/050622560</ext-link></comment></mixed-citation>
</ref>
<ref id="pone.0117688.ref038">
<label>38</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Ramsey</surname> <given-names>PH</given-names></name> (<year>1994</year>) <article-title>Data fitting in the chemical sciences</article-title>. <source>Technometrics</source> <volume>36</volume>: <fpage>430</fpage>–<lpage>431</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1080/00401706.1994.10485864" xlink:type="simple">10.1080/00401706.1994.10485864</ext-link></comment></mixed-citation>
</ref>
<ref id="pone.0117688.ref039">
<label>39</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Wentworth</surname> <given-names>WE</given-names></name> (<year>1965</year>) <article-title>Rigorous least squares adjustment: application to some non-linear equations, I</article-title>. <source>J Chem Educ</source> <volume>42</volume>: <fpage>96</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1021/ed042p96" xlink:type="simple">10.1021/ed042p96</ext-link></comment></mixed-citation>
</ref>
<ref id="pone.0117688.ref040">
<label>40</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Deguet</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Kumar</surname> <given-names>R</given-names></name>, <name name-style="western"><surname>Taylor</surname> <given-names>R</given-names></name>, <name name-style="western"><surname>Kazanzides</surname> <given-names>P</given-names></name> (<year>2008</year>) <article-title>The CISST libraries for computer assisted intervention systems</article-title>. <source>MIDAS J Syst Arch Comput Assist Interv</source>: <fpage>1</fpage>–<lpage>8</lpage>.</mixed-citation>
</ref>
<ref id="pone.0117688.ref041">
<label>41</label>
<mixed-citation xlink:type="simple" publication-type="book">
<name name-style="western"><surname>Eberly</surname> <given-names>DH</given-names></name> (<year>2010</year>) <chapter-title>Game physics</chapter-title>. <source>Morgan Kaufmann</source>, <edition>second edition</edition>.</mixed-citation>
</ref>
<ref id="pone.0117688.ref042">
<label>42</label>
<mixed-citation xlink:type="simple" publication-type="other">Cignoni P, Callieri M, Corsini M, Dellepiane M, Ganovelli F, et al. (2008) Meshlab: an open-source mesh processing tool. In: Eurographics Ital. Chapter Conf. The Eurographics Association, pp. 129–136.</mixed-citation>
</ref>
<ref id="pone.0117688.ref043">
<label>43</label>
<mixed-citation xlink:type="simple" publication-type="other">Tamaki T, Abe M, Raytchev B, Kaneda K (2010) Softassign and EM-ICP on GPU. In: Netw. Comput. (ICNC), 2010 First Int. Conf. IEEE, pp. 179–183.</mixed-citation>
</ref>
</ref-list>
</back>
</article>